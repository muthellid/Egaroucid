

// ===== FILE: Egaroucid/src/engine/ai.hpp =====

ï»¿

#pragma once
#include <iostream>
#include <future>
#include <unordered_set>
#include <iomanip>
#include "level.hpp"
#include "setting.hpp"
#include "midsearch.hpp"
#include "book.hpp"
#include "util.hpp"
#include "clogsearch.hpp"
#include "time_management.hpp"
#include "common_select.hpp"

constexpr int AI_TYPE_BOOK = 1000;

constexpr int IDSEARCH_ENDSEARCH_PRESEARCH_OFFSET = 10;
constexpr int IDSEARCH_ENDSEARCH_PRESEARCH_OFFSET_TIMELIMIT = 12;
constexpr int PONDER_ENDSEARCH_PRESEARCH_OFFSET_TIMELIMIT = 4;

constexpr int PONDER_START_SELFPLAY_DEPTH = 17;

constexpr int AI_TL_EARLY_BREAK_THRESHOLD = 5;

constexpr double AI_TL_ADDITIONAL_SEARCH_THRESHOLD = 1.5;

#if USE_LAZY_SMP2
constexpr int N_MAIN_SEARCH_THREADS = 25;
#endif

struct Ponder_elem {
    Flip flip;
    double value;
    int count;
    int level;
    int depth;
    uint_fast8_t mpc_level;
    bool is_endgame_search;
    bool is_complete_search;
};

std::vector<Ponder_elem> ai_ponder(Board board, bool show_log, thread_id_t thread_id, bool *searching);
std::vector<Ponder_elem> ai_get_values(Board board, bool show_log, uint64_t time_limit, thread_id_t thread_id);
std::pair<int, int> ponder_selfplay(Board board_start, int root_depth, uint_fast8_t root_mpc_level, bool show_log, bool use_multi_thread, bool *searching);
std::vector<Ponder_elem> ai_align_move_levels(Board board, bool show_log, std::vector<Ponder_elem> move_list, int n_good_moves, uint64_t time_limit, thread_id_t thread_id, int aligned_min_level);
std::vector<Ponder_elem> ai_additional_selfplay(Board board, bool show_log, std::vector<Ponder_elem> move_list, int n_good_moves, double threshold, uint64_t time_limit, thread_id_t thread_id);
Search_result ai_legal_window(Board board, int alpha, int beta, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, uint64_t use_legal);
Search_result selfplay_and_analyze_search_result(Board board, int level, bool show_log, thread_id_t thread_id, bool *searching);

inline uint64_t get_this_search_time_limit(uint64_t time_limit, uint64_t elapsed) {
    if (time_limit <= elapsed) {
        return 0;
    }
    return time_limit - elapsed;
}

#if USE_LAZY_SMP2
inline std::pair<int, uint64_t> lazy_smp(Board board, int alpha, int beta, uint64_t use_legal, int n_threads, int thread_id, int main_depth, uint_fast8_t main_mpc_level, bool *searching) {
    if (n_threads <= 0) {
        return std::make_pair(0, 0ULL);
    }
    int n_worker = 0;
    uint64_t nodes = 0;
    std::vector<Search> searches(n_threads);
    for (Search &search: searches) {
        search.n_nodes = 0;
        search.thread_id = thread_id;
    }
    std::vector<std::future<int>> parallel_tasks;
    std::vector<int> sub_depth_arr;
    int sub_max_mpc_level[61];
    int sub_depth = main_depth;
    int max_thread_size = n_threads;
    
    
    
    const int max_depth = HW2 - board.n_discs() - common_select::get_N_INVALID();
    sub_max_mpc_level[main_depth] = main_mpc_level;
    for (int i = main_depth; i < 61; ++i) {
        sub_max_mpc_level[i] = MPC_74_LEVEL;
    }
    for (int sub_thread_idx = 0; sub_thread_idx < max_thread_size && sub_thread_idx < searches.size() && global_searching && *searching; ++sub_thread_idx) {
        int ntz = ctz_uint32(sub_thread_idx + 1);
        int sub_depth = std::min(max_depth, main_depth + ntz);
        uint_fast8_t sub_mpc_level = sub_max_mpc_level[sub_depth];
        bool sub_is_end_search = (sub_depth == max_depth);
        if (sub_mpc_level <= MPC_100_LEVEL) {
            searches[sub_thread_idx] = Search{&board, sub_mpc_level, false, true};
            bool pushed = false;
            parallel_tasks.emplace_back(thread_pool.push(thread_id, &pushed, std::bind(&nega_scout, &searches[sub_thread_idx], alpha, beta, sub_depth, false, use_legal, sub_is_end_search, searching)));
            sub_depth_arr.emplace_back(sub_depth);
            if (!pushed) {
                parallel_tasks.pop_back();
                sub_depth_arr.pop_back();
            } else {
                ++sub_max_mpc_level[sub_depth];
                ++n_worker;
            }
        }
    }
    int max_sub_search_depth = -1;
    int max_sub_main_mpc_level = 0;
    bool max_is_only_one = false;
    for (int i = 0; i < (int)parallel_tasks.size(); ++i) {
        if (sub_depth_arr[i] > max_sub_search_depth) {
            max_sub_search_depth = sub_depth_arr[i];
            max_sub_main_mpc_level = searches[i].mpc_level;
            max_is_only_one = true;
        } else if (sub_depth_arr[i] == max_sub_search_depth && max_sub_main_mpc_level < searches[i].mpc_level) {
            max_sub_main_mpc_level = searches[i].mpc_level;
            max_is_only_one = true;
        } else if (sub_depth_arr[i] == max_sub_search_depth && searches[i].mpc_level == max_sub_main_mpc_level) {
            max_is_only_one = false;
        }
    }
    for (std::future<int> &task: parallel_tasks) {
        task.get();
    }
    for (Search &search: searches) {
        nodes += search.n_nodes;
    }
    
    return std::make_pair(n_worker, nodes);
}
#endif

void iterative_deepening_search(Board board, int alpha, int beta, int depth, uint_fast8_t mpc_level, bool show_log, std::vector<Clog_result> clogs, uint64_t use_legal, bool use_multi_thread, thread_id_t thread_id, Search_result *result, bool *searching) {
    const int n_usable_threads = std::min(thread_pool.size(), thread_pool.get_max_thread_size(thread_id)) + 1;
    uint64_t strt = tim();
    result->value = SCORE_UNDEFINED;
    int main_depth = 1;
    int main_mpc_level = mpc_level;
    const int max_depth = HW2 - board.n_discs() - common_select::get_N_INVALID();
    depth = std::min(depth, max_depth);
    bool is_end_search = (depth == max_depth);
    if (is_end_search) {
        main_mpc_level = MPC_74_LEVEL;
    }
    if (show_log) {
        std::cerr << "thread pool size " << thread_pool.size() << " n_idle " << thread_pool.get_n_idle() << std::endl;
    }
#if USE_LAZY_SMP
    std::vector<Search> searches(thread_pool.size() + 1);
#endif
#if USE_LAZY_SMP2
    bool sub_searching = true;
    int n_lazy_smp_threads = n_usable_threads - N_MAIN_SEARCH_THREADS;
    if (is_end_search) {
        n_lazy_smp_threads = 0;
    }
    std::future<std::pair<int, uint64_t>> lazy_smp_future = std::async(std::launch::async, lazy_smp, board, alpha, beta, use_legal, n_lazy_smp_threads, thread_id, depth, mpc_level, &sub_searching);
#endif
    while (main_depth <= depth && main_mpc_level <= mpc_level && global_searching && *searching) {
#if USE_LAZY_SMP
        for (Search &search: searches) {
            search.n_nodes = 0;
            search.thread_id = thread_id;
        }
#endif
        bool main_is_end_search = false;
        if (main_depth >= max_depth) {
            main_is_end_search = true;
            main_depth = max_depth;
        }
        bool is_last_search = (main_depth == depth) && (main_mpc_level == mpc_level);
#if USE_LAZY_SMP
        std::vector<std::future<int>> parallel_tasks;
        std::vector<int> sub_depth_arr;
        int sub_max_mpc_level[61];
        bool sub_searching = true;
        int sub_depth = main_depth;
        if (use_multi_thread && !(is_end_search && main_depth == depth) && main_depth <= 10) {
            int max_thread_size = std::min(thread_pool.size(), thread_pool.get_max_thread_size(thread_id));
            for (int i = 0; i < main_depth - 14; ++i) {
                max_thread_size *= 0.9;
            }
            sub_max_mpc_level[main_depth] = main_mpc_level + 1;
            for (int i = main_depth + 1; i < 61; ++i) {
                sub_max_mpc_level[i] = MPC_74_LEVEL;
            }
            for (int sub_thread_idx = 0; sub_thread_idx < max_thread_size && sub_thread_idx < searches.size() && global_searching && *searching; ++sub_thread_idx) {
                int ntz = ctz_uint32(sub_thread_idx + 1);
                int sub_depth = std::min(max_depth, main_depth + ntz);
                uint_fast8_t sub_mpc_level = sub_max_mpc_level[sub_depth];
                bool sub_is_end_search = (sub_depth == max_depth);
                if (sub_mpc_level <= MPC_100_LEVEL) {
                    
                    searches[sub_thread_idx] = Search{&board, sub_mpc_level, false, true};
                    bool pushed = false;
                    parallel_tasks.emplace_back(thread_pool.push(thread_id, &pushed, std::bind(&nega_scout, &searches[sub_thread_idx], alpha, beta, sub_depth, false, use_legal, sub_is_end_search, &sub_searching)));
                    sub_depth_arr.emplace_back(sub_depth);
                    ++sub_max_mpc_level[sub_depth];
                    if (!pushed) {
                        parallel_tasks.pop_back();
                        sub_depth_arr.pop_back();
                    }
                }
            }
            int max_sub_search_depth = -1;
            int max_sub_main_mpc_level = 0;
            bool max_is_only_one = false;
            for (int i = 0; i < (int)parallel_tasks.size(); ++i) {
                if (sub_depth_arr[i] > max_sub_search_depth) {
                    max_sub_search_depth = sub_depth_arr[i];
                    max_sub_main_mpc_level = searches[i].mpc_level;
                    max_is_only_one = true;
                } else if (sub_depth_arr[i] == max_sub_search_depth && max_sub_main_mpc_level < searches[i].mpc_level) {
                    max_sub_main_mpc_level = searches[i].mpc_level;
                    max_is_only_one = true;
                } else if (sub_depth_arr[i] == max_sub_search_depth && searches[i].mpc_level == max_sub_main_mpc_level) {
                    max_is_only_one = false;
                }
            }
        }
#endif
        Search main_search(&board, main_mpc_level, use_multi_thread, !is_last_search);
        main_search.thread_id = thread_id;
        std::pair<int, int> id_result = first_nega_scout_legal(&main_search, alpha, beta, main_depth, main_is_end_search, clogs, use_legal, strt, searching);
#if USE_LAZY_SMP
        sub_searching = false;
        for (std::future<int> &task: parallel_tasks) {
            task.get();
        }
        for (Search &search: searches) {
            result->nodes += search.n_nodes;
        }
#endif
        result->nodes += main_search.n_nodes;
        if (*searching) {
            if (result->value != SCORE_UNDEFINED && !main_is_end_search) {
                double n_value = (0.9 * result->value + 1.1 * id_result.first) / 2.0;
                result->value = round(n_value);
            } else{
                result->value = id_result.first;
            }
            result->policy = id_result.second;
            result->depth = main_depth;
            result->is_end_search = main_is_end_search;
            result->probability = SELECTIVITY_PERCENTAGE[main_mpc_level];
        }
        result->time = tim() - strt;
        result->nps = calc_nps(result->nodes, result->time);
        if (show_log) {
            if (is_last_search) {
                std::cerr << "main ";
            } else{
                std::cerr << "pre ";
            }
            if (main_is_end_search) {
                std::cerr << "end ";
            } else{
                std::cerr << "mid ";
            }
#if USE_LAZY_SMP
            std::cerr << "depth " << result->depth << "@" << SELECTIVITY_PERCENTAGE[main_mpc_level] << "%" << " value " << result->value << " (raw " << id_result.first << ") policy " << idx_to_coord(id_result.second) << " n_worker " << parallel_tasks.size() << " n_nodes " << result->nodes << " time " << result->time << " NPS " << result->nps << std::endl;
            
#else
            std::cerr << "depth " << result->depth << "@" << SELECTIVITY_PERCENTAGE[main_mpc_level] << "%" << " value " << result->value << " (raw " << id_result.first << ") policy " << idx_to_coord(id_result.second) << " n_nodes " << result->nodes << " time " << result->time << " NPS " << result->nps << std::endl;
#endif
        }
        if (is_end_search && main_depth >= depth - IDSEARCH_ENDSEARCH_PRESEARCH_OFFSET) {
            if (main_depth < depth) {
                main_depth = depth;
                if (depth <= 27 && mpc_level >= MPC_88_LEVEL) {
                    main_mpc_level = MPC_88_LEVEL;
                } else {
                    main_mpc_level = MPC_74_LEVEL;
                }
            } else{
                if (main_mpc_level < mpc_level) {
                    if (
                        (main_mpc_level >= MPC_74_LEVEL && mpc_level > MPC_74_LEVEL && depth <= 22) || 
                        (main_mpc_level >= MPC_88_LEVEL && mpc_level > MPC_88_LEVEL && depth <= 25) || 
                        (main_mpc_level >= MPC_93_LEVEL && mpc_level > MPC_93_LEVEL && depth <= 29) || 
                        (main_mpc_level >= MPC_98_LEVEL && mpc_level > MPC_98_LEVEL)
                    ) {
                        main_mpc_level = mpc_level;
                    } else{
                        ++main_mpc_level;
                    }
                } else{
                    break;
                }
            }
        } else {
            if (main_depth <= 15 && main_depth < depth - 3) {
                main_depth += 3;
            } else{
                ++main_depth;
            }
        }
    }
#if USE_LAZY_SMP2
    sub_searching = false;
    std::pair<int, uint64_t> lazy_smp_result = lazy_smp_future.get();
    int n_worker = lazy_smp_result.first;
    uint64_t lazy_smp_nodes = lazy_smp_result.second;
    result->nodes += lazy_smp_nodes;
    result->time = tim() - strt;
    result->nps = calc_nps(result->nodes, result->time);
    if (show_log) {
        std::cerr << "lazy smp finished n_worker " << n_worker << " worker_n_nodes " << lazy_smp_nodes << " whole_n_nodes " << result->nodes << " whole_time " << result->time << " whole_NPS " << result->nps << std::endl;
    }
#endif
}

void iterative_deepening_search_time_limit(Board board, int alpha, int beta, bool show_log, std::vector<Clog_result> clogs, uint64_t use_legal, bool use_multi_thread, thread_id_t thread_id, Search_result *result, uint64_t time_limit, bool *searching) {
    const int n_usable_threads = thread_pool.get_max_thread_size(thread_id);
    uint64_t strt = tim();
    result->value = SCORE_UNDEFINED;
    int main_depth = 1;
    int main_mpc_level = MPC_100_LEVEL;
    const int max_depth = HW2 - board.n_discs() - common_select::get_N_INVALID();
    if (show_log) {
        std::cerr << "thread pool size " << thread_pool.size() << " n_idle " << thread_pool.get_n_idle() << std::endl;
    }
    int before_raw_value = -100;
    bool policy_changed_before = true;
    while (global_searching && (*searching) && ((tim() - strt < time_limit) || main_depth <= 1)) {
        bool main_is_end_search = false;
        if (main_depth >= max_depth) {
            main_is_end_search = true;
            main_depth = max_depth;
        }
        bool main_is_complete_search = main_is_end_search && main_mpc_level == MPC_100_LEVEL;
        if (show_log) {
            if (main_is_end_search) {
                std::cerr << "end ";
            } else{
                std::cerr << "mid ";
            }
            std::cerr << "depth " << main_depth << "@" << SELECTIVITY_PERCENTAGE[main_mpc_level] << "% " << std::flush;
        }
        Search main_search(&board, main_mpc_level, use_multi_thread, false);
        main_search.thread_id = thread_id;
        std::pair<int, int> id_result;
        bool search_success = false;
        bool main_searching = true;
        uint64_t time_limit_this_search = get_this_search_time_limit(time_limit, tim() - strt);
        std::future<std::pair<int, int>> f = std::async(std::launch::async, first_nega_scout_legal, &main_search, alpha, beta, main_depth, main_is_end_search, clogs, use_legal, strt, &main_searching);
        if (f.wait_for(std::chrono::milliseconds(time_limit_this_search)) == std::future_status::ready) {
            id_result = f.get();
            search_success = true;
        } else {
            main_searching = false;
            try {
                f.get();
            } catch (const std::exception &e) {
            }
            if (show_log) {
                std::cerr << "terminated " << tim() - strt << " ms" << std::endl;
            }
        }
        result->nodes += main_search.n_nodes;
        result->time = tim() - strt;
        result->nps = calc_nps(result->nodes, result->time);
        if (search_success) {
            if (result->value != SCORE_UNDEFINED && !main_is_end_search) {
                double n_value = (0.9 * result->value + 1.1 * id_result.first) / 2.0;
                result->value = round(n_value);
            } else{
                result->value = id_result.first;
            }
            bool policy_changed = result->policy != id_result.second;
            result->policy = id_result.second;
            result->depth = main_depth;
            result->is_end_search = main_is_end_search;
            result->probability = SELECTIVITY_PERCENTAGE[main_mpc_level];
            if (show_log) {
                std::cerr << "value " << result->value << " (raw " << id_result.first << ") policy " << idx_to_coord(id_result.second) << " n_nodes " << result->nodes << " time " << result->time << " NPS " << result->nps << std::endl;
            }
            uint64_t legal_without_bestmove = use_legal ^ (1ULL << result->policy);
            if (
                (!main_is_end_search && main_depth >= 29 && main_depth <= 30) && 
                max_depth >= 44 && 
                !policy_changed && 
                !policy_changed_before && 
                main_mpc_level == MPC_74_LEVEL && 
                legal_without_bestmove != 0
            ) {
                int nws_alpha = result->value - AI_TL_EARLY_BREAK_THRESHOLD;
                if (nws_alpha >= -SCORE_MAX) {
                    Search nws_search(&board, main_mpc_level, use_multi_thread, false);
                    nws_search.thread_id = thread_id;
                    bool nws_searching = true;
                    if (show_log) {
                        std::cerr << "trying early break [" << nws_alpha << ", " << nws_alpha + 1 << "] ";
                    }
                    uint64_t time_limit_nws = get_this_search_time_limit(time_limit, tim() - strt);
                    std::future<std::pair<int, int>> nws_f = std::async(std::launch::async, first_nega_scout_legal, &nws_search, nws_alpha, nws_alpha + 1, main_depth, main_is_end_search, clogs, legal_without_bestmove, strt, &nws_searching);
                    int nws_value = SCORE_INF;
                    int nws_move = MOVE_NOMOVE;
                    bool nws_success = false;
                    if (nws_f.wait_for(std::chrono::milliseconds(time_limit_nws)) == std::future_status::ready) {
                        std::pair<int, int> nws_result = nws_f.get();
                        nws_value = nws_result.first;
                        nws_move = nws_result.second;
                        nws_success = true;
                    } else {
                        nws_searching = false;
                        try {
                            nws_f.get();
                        } catch (const std::exception &e) {
                        }
                        if (show_log) {
                            std::cerr << "terminate early cut nws by time limit " << tim() - strt << " ms" << std::endl;
                        }
                    }
                    result->nodes += nws_search.n_nodes;
                    result->time = tim() - strt;
                    result->nps = calc_nps(result->nodes, result->time);
                    if (nws_success) {
                        if (nws_value <= nws_alpha) {
                            if (show_log) {
                                std::cerr << "SUCCEEDED second best " << idx_to_coord(nws_move) << " value <= " << nws_value << " time " << tim() - strt << std::endl;
                            }
                            break;
                        } else if (nws_searching) {
                            if (show_log) {
                                std::cerr << "FAILED second best " << idx_to_coord(nws_move) << " value >= " << nws_value << " time " << tim() - strt << std::endl;
                            }
                        }
                    }
                }
            }
            
            
            before_raw_value = id_result.first;
            policy_changed_before = policy_changed;
        }
        
        
        
        if (main_depth < max_depth - IDSEARCH_ENDSEARCH_PRESEARCH_OFFSET_TIMELIMIT) { 
            if (main_depth <= 15 && main_depth < max_depth - 3) {
                main_depth += 3;
                if (main_depth > 13 && main_mpc_level == MPC_100_LEVEL) {
                    main_mpc_level = MPC_74_LEVEL;
                }
            } else {
                if (main_depth + 1 < 23) {
                    ++main_depth;
                    if (main_depth > 13 && main_mpc_level == MPC_100_LEVEL) {
                        main_mpc_level = MPC_74_LEVEL;
                    }
                } else {
                    ++main_depth;
                    
                }
            }
        } else { 

            
            
            
            

            if (main_depth < max_depth) {
                main_depth = max_depth;
                main_mpc_level = MPC_74_LEVEL;
            } else {
                if (main_mpc_level < MPC_100_LEVEL) {
                    ++main_mpc_level;
                } else {
                    
                    
                    
                    break;
                }
            }
        }
    }
    if (show_log && result->is_end_search && result->probability == 100) {
        std::cerr << "completely searched" << std::endl;
    }
}

inline Search_result tree_search_legal(Board board, int alpha, int beta, int depth, uint_fast8_t mpc_level, bool show_log, uint64_t use_legal, bool use_multi_thread, uint64_t time_limit, thread_id_t thread_id, bool *searching) {
    
    Search_result res;
    depth = std::min(HW2 - board.n_discs() - common_select::get_N_INVALID(), depth);
bool is_end_search = (HW2 - board.n_discs() - common_select::get_N_INVALID() == depth);
    bool use_time_limit = (time_limit != TIME_LIMIT_INF);
    std::vector<Clog_result> clogs;
    uint64_t clog_nodes = 0;
    uint64_t clog_time = 0;
    if (mpc_level != MPC_100_LEVEL || use_time_limit) {
        uint64_t strt = tim();
        int clog_depth = std::min(depth, CLOG_SEARCH_MAX_DEPTH);
        if (use_time_limit) {
            clog_depth = CLOG_SEARCH_MAX_DEPTH;
        }
        clogs = first_clog_search(board, &clog_nodes, clog_depth, use_legal, searching);
        clog_time = tim() - strt;
        if (show_log) {
            std::cerr << "clog search depth " << clog_depth << " time " << clog_time << " nodes " << clog_nodes << " nps " << calc_nps(clog_nodes, clog_time) << std::endl;
            for (int i = 0; i < (int)clogs.size(); ++i) {
                std::cerr << "clogsearch " << i + 1 << "/" << clogs.size() << " " << idx_to_coord(clogs[i].pos) << " value " << clogs[i].val << std::endl;
            }
        }
        res.clog_nodes = clog_nodes;
        res.clog_time = clog_time;
    }
    if (use_legal) {
        uint64_t time_limit_proc = TIME_LIMIT_INF;
        if (use_time_limit) {
            if (time_limit > clog_time) {
                time_limit_proc = time_limit - clog_time;
            } else {
                time_limit_proc = 1;
            }
        }
        if (use_time_limit) {
            iterative_deepening_search_time_limit(board, alpha, beta, show_log, clogs, use_legal, use_multi_thread, thread_id, &res, time_limit_proc, searching);
        } else {
            iterative_deepening_search(board, alpha, beta, depth, mpc_level, show_log, clogs, use_legal, use_multi_thread, thread_id, &res, searching);
        }
    }
    
    
    
    return res;
}

Search_result ai_common(Board board, int alpha, int beta, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, uint64_t use_legal, bool use_specified_move_book, uint64_t time_limit, thread_id_t thread_id, bool *searching) {
    Search_result res;
    int value_sign = 1;
    if (board.get_legal() == 0ULL) {
        board.pass();
        if (board.get_legal() == 0ULL) {
            res.level = MAX_LEVEL;
            res.policy = 64;
            res.value = -board.score_player();
            res.depth = 0;
            res.nps = 0;
            res.is_end_search = true;
            res.probability = 100;
            return res;
        } else{
            if (show_log) {
                std::cerr << "pass found in ai_common!" << std::endl;
            }
            value_sign = -1;
        }
    }
    
    if (use_book && board.invalid_mask != 0ULL) {
    if (show_log) std::cerr << "[Book] Skipped due to invalid_mask\n";
    use_book = false;
    }
    
    Book_value book_result;
    if (use_specified_move_book) {
        book_result = book.get_specified_best_move(&board, use_legal);
    } else{
        book_result = book.get_random(&board, book_acc_level, use_legal);
    }
    if (is_valid_policy(book_result.policy) && use_book) {
        if (show_log) {
            std::cerr << "book found " << value_sign * book_result.value << " " << idx_to_coord(book_result.policy) << std::endl;
        }
        res.level = LEVEL_TYPE_BOOK;
        res.policy = book_result.policy;
        res.value = value_sign * book_result.value;
        res.depth = SEARCH_BOOK;
        res.nps = 0;
        res.is_end_search = false;
        res.probability = 100;
        if (book_acc_level == 0) { 
            std::vector<Book_value> book_moves = book.get_all_moves_with_value(&board);
            for (const Book_value &move: book_moves) {
                use_legal &= ~(1ULL << move.policy);
            }
            if (use_legal != 0) { 
                if (show_log) {
                    std::cerr << "there are good moves out of book" << std::endl;
                }
                bool need_to_check = false;
                Flip flip;
                calc_flip(&flip, &board, book_result.policy);
                board.move_board(&flip);
                    bool passed = false;
                    bool game_over = false;
                    if (board.get_legal() == 0) {
                        passed = true;
                        board.pass();
                        if (board.get_legal() == 0) {
                            game_over = true;
                        }
                    }
                    if (!game_over) {
                        Book_elem book_elem = book.get(board);
                        if (book_elem.level < level) {
                            need_to_check = true;
                        }
                    }
                    if (passed) {
                        board.pass();
                    }
                board.undo_board(&flip);
                if (need_to_check) {
                    int n_alpha = std::max(alpha, book_result.value + 1);
                    int level_proc = level;
                    if (time_limit != TIME_LIMIT_INF) {
                        level_proc = 25;
                    }
                    Search_result additional_result = ai_legal_window(board, n_alpha, beta, level_proc, true, 0, true, false, use_legal);
                    if (value_sign * additional_result.value >= res.value + 2) {
                        if (show_log) {
                            std::cerr << "better move found out of book " << idx_to_coord(additional_result.policy) << "@" << value_sign * additional_result.value << " book " << idx_to_coord(res.policy) << "@" << res.value << std::endl;
                        }
                        res = additional_result;
                        res.level = level;
                        res.value *= value_sign;
                    }
                }
            } else {
                if (show_log) {
                    std::cerr << "all moves are in book" << std::endl;
                }
            }
        }
    } else { 
        int depth;
        bool is_mid_search;
        uint_fast8_t mpc_level;
        get_level(level, board.n_discs() - 4, &is_mid_search, &depth, &mpc_level);
        if (show_log && time_limit == TIME_LIMIT_INF) {
            std::cerr << "level status " << level << " " << board.n_discs() - 4 << " discs depth " << depth << "@" << SELECTIVITY_PERCENTAGE[mpc_level] << "%" << std::endl;
        }
        
        res = tree_search_legal(board, alpha, beta, depth, mpc_level, show_log, use_legal, use_multi_thread, time_limit, thread_id, searching);
        
        res.level = level;
        res.value *= value_sign;
    }
    return res;
}


Search_result ai(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log) {
    bool searching = true;
    return ai_common(board, -SCORE_MAX, SCORE_MAX, level, use_book, book_acc_level, use_multi_thread, show_log, board.get_legal(), false, TIME_LIMIT_INF, THREAD_ID_NONE, &searching);
}

Search_result ai_searching(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, bool *searching) {
    return ai_common(board, -SCORE_MAX, SCORE_MAX, level, use_book, book_acc_level, use_multi_thread, show_log, board.get_legal(), false, TIME_LIMIT_INF, THREAD_ID_NONE, searching);
}

Search_result ai_searching_thread_id(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, thread_id_t thread_id, bool *searching) {
    return ai_common(board, -SCORE_MAX, SCORE_MAX, level, use_book, book_acc_level, use_multi_thread, show_log, board.get_legal(), false, TIME_LIMIT_INF, thread_id, searching);
}

Search_result ai_legal(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, uint64_t use_legal) {
    bool searching = true;
    return ai_common(board, -SCORE_MAX, SCORE_MAX, level, use_book, book_acc_level, use_multi_thread, show_log, use_legal, false, TIME_LIMIT_INF, THREAD_ID_NONE, &searching);
}

Search_result ai_legal_window(Board board, int alpha, int beta, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, uint64_t use_legal) {
    bool searching = true;
    return ai_common(board, alpha, beta, level, use_book, book_acc_level, use_multi_thread, show_log, use_legal, false, TIME_LIMIT_INF, THREAD_ID_NONE, &searching);
}

Search_result ai_legal_searching(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, uint64_t use_legal, bool *searching) {
    return ai_common(board, -SCORE_MAX, SCORE_MAX, level, use_book, book_acc_level, use_multi_thread, show_log, use_legal, false, TIME_LIMIT_INF, THREAD_ID_NONE, searching);
}

Search_result ai_legal_searching_thread_id(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, uint64_t use_legal, thread_id_t thread_id, bool *searching) {
    return ai_common(board, -SCORE_MAX, SCORE_MAX, level, use_book, book_acc_level, use_multi_thread, show_log, use_legal, false, TIME_LIMIT_INF, thread_id, searching);
}

Search_result ai_window_legal(Board board, int alpha, int beta, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, uint64_t use_legal) {
    bool searching = true;
    return ai_common(board, alpha, beta, level, use_book, book_acc_level, use_multi_thread, show_log, use_legal, false, TIME_LIMIT_INF, THREAD_ID_NONE, &searching);
}

Search_result ai_window_legal_searching(Board board, int alpha, int beta, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, uint64_t use_legal, bool *searching) {
    return ai_common(board, alpha, beta, level, use_book, book_acc_level, use_multi_thread, show_log, use_legal, false, TIME_LIMIT_INF, THREAD_ID_NONE, searching);
}

Search_result ai_window_searching(Board board, int alpha, int beta, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, bool *searching) {
    return ai_common(board, alpha, beta, level, use_book, book_acc_level, use_multi_thread, show_log, board.get_legal(), false, TIME_LIMIT_INF, THREAD_ID_NONE, searching);
}

Search_result ai_specified(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log) {
    bool searching = true;
    return ai_common(board, -SCORE_MAX, SCORE_MAX, level, use_book, book_acc_level, use_multi_thread, show_log, board.get_legal(), true, TIME_LIMIT_INF, THREAD_ID_NONE, &searching);
}

std::vector<Search_result> ai_best_n_moves_searching(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, int n_moves, bool *searching) {
    Search_result best = ai_searching(board, level, true, 0, true, show_log, searching);
    std::vector<Search_result> search_results;
    search_results.emplace_back(best);
    int alpha = -SCORE_MAX;
    int beta = best.value;
    uint64_t legal = board.get_legal() ^ (1ULL << best.policy);
    while (legal && search_results.size() < n_moves) {
        Search_result result_loss = ai_window_legal_searching(board, alpha, beta, level, true, 0, true, show_log, legal, searching);
        legal ^= 1ULL << result_loss.policy;
        search_results.emplace_back(result_loss);
    }
    return search_results;
}

std::vector<Search_result> ai_best_moves_loss_searching(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, int loss_max, bool *searching) {
    Search_result best = ai_searching(board, level, true, 0, true, show_log, searching);
    std::vector<Search_result> search_results;
    search_results.emplace_back(best);
    int alpha = best.value - loss_max - 1;
    int beta = best.value;
    uint64_t legal = board.get_legal() ^ (1ULL << best.policy);
    while (legal && (*searching)) {
        Search_result result_loss = ai_window_legal_searching(board, alpha, beta, level, true, 0, true, show_log, legal, searching);
        legal ^= 1ULL << result_loss.policy;
        if (*searching) {
            if (result_loss.value >= best.value - loss_max) {
                search_results.emplace_back(result_loss);
            } else {
                break;
            }
        }
    }
    return search_results;
}

Search_result ai_loss_searching(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, int loss_max, bool *searching) {
    std::vector<Search_result> search_results = ai_best_moves_loss_searching(board, level, use_book, book_acc_level, use_multi_thread, show_log, loss_max, searching);
    if (show_log){
        std::cerr << "play loss candidate " << search_results.size() << " moves: ";
        for (const Search_result &elem: search_results) {
            std::cerr << idx_to_coord(elem.policy) << "@" << elem.value << " ";
        }
        std::cerr << std::endl;
    }
    return search_results[myrandrange(0, (int)search_results.size())];
}

Search_result ai_loss(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, int loss_max) {
    bool searching = true;
    return ai_loss_searching(board, level, use_book, book_acc_level, use_multi_thread, show_log, loss_max, &searching);
}




struct AI_TL_Elem {
    Board board;
    AI_TL_Elem* parent;
    AI_TL_Elem* children[40] = {nullptr}; 
    int n_children;
    int n;
    double v;
    double search_v;
    int last_move;
    bool is_complete_search;
    bool good_moves_already_searched;
    int sgn;

    void reset() {
        parent = nullptr;
        n_children = 0;
        n = 0;
        v = SCORE_UNDEFINED;
        search_v = -SCORE_MAX;
        last_move = MOVE_UNDEFINED;
        is_complete_search = false;
        good_moves_already_searched = false;
        sgn = 1;
    }

    AI_TL_Elem() {
        reset();
    }
};



constexpr int AI_TIME_LIMIT_LEVEL = 21;
constexpr int AI_TIME_LIMIT_LEVEL_ROOT = 25;
constexpr int N_MAX_NODES_AI_TL = 1000000;
constexpr int AI_TIME_LIMIT_EXPAND_THRESHOLD = 4;
constexpr int START_NORMAL_SEARCH_EMPTIES = 38;

struct AI_TL_Array {
    std::mutex mtx;
    AI_TL_Elem ai_time_limit_elems[N_MAX_NODES_AI_TL];
    int n_expanded_nodes;

    AI_TL_Array() {
        n_expanded_nodes = 0;
    }
};

AI_TL_Array ai_tl_array;

Search_result ai_time_limit(Board board, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, uint64_t remaining_time_msec, thread_id_t thread_id, bool *searching) {
    uint64_t time_limit = calc_time_limit_ply(board, remaining_time_msec, show_log);
    if (show_log) {
        std::cerr << "ai_time_limit start! tl " << time_limit << " remaining " << remaining_time_msec << " n_empties " << (HW2 - board.n_discs() - common_select::get_N_INVALID()) << " " << board.to_str() << std::endl;
    }
    uint64_t strt = tim();
    int n_empties = HW2 - board.n_discs() - common_select::get_N_INVALID();
    if (n_empties >= 38  && time_limit >= 2000ULL) {
        bool get_values_searching = true;
        uint64_t get_values_tl = 600ULL;
        if (show_log) {
            std::cerr << "getting values tl " << get_values_tl << std::endl;
        }
        uint64_t strt_get_values = tim();
            std::vector<Ponder_elem> get_values_move_list = ai_get_values(board, show_log, get_values_tl, thread_id);
        uint64_t elapsed_get_values = tim() - strt_get_values;
        if (time_limit > elapsed_get_values) {
            time_limit -= elapsed_get_values;
        } else {
            time_limit = 10;
        }
        if (remaining_time_msec > elapsed_get_values) {
            remaining_time_msec -= elapsed_get_values;
        } else {
            remaining_time_msec = 0;
        }

        if (time_limit > 5000ULL && get_values_move_list.size() >= 2) {
            double best_value = get_values_move_list[0].value;
            int n_good_moves = 0;
            if (show_log) {
                std::cerr << "good moves (1):";
            }
            for (const Ponder_elem &elem: get_values_move_list) {
                if (elem.value >= best_value - AI_TL_ADDITIONAL_SEARCH_THRESHOLD * 2.0) {
                    ++n_good_moves;
                    if (show_log) {
                        std::cerr << " " << idx_to_coord(elem.flip.pos);
                    }
                }
            }
            if (show_log) {
                std::cerr << std::endl;
            }
            if (n_good_moves >= 2) {
                uint64_t align_moves_tl = 0;
                if (remaining_time_msec > 40000) {
                    align_moves_tl = std::min<uint64_t>(10000ULL, time_limit * 0.8);
                }
                uint64_t strt_align_move_levels = tim();
                    std::vector<Ponder_elem> after_move_list = ai_align_move_levels(board, show_log, get_values_move_list, n_good_moves, align_moves_tl, thread_id, 29);
                uint64_t elapsed_align_move_levels = tim() - strt_align_move_levels;
                if (time_limit > elapsed_align_move_levels) {
                    time_limit -= elapsed_align_move_levels;
                } else {
                    time_limit = 10;
                }
                if (remaining_time_msec > elapsed_align_move_levels) {
                    remaining_time_msec -= elapsed_align_move_levels;
                } else {
                    remaining_time_msec = 0;
                }

                double new_best_value = after_move_list[0].value;
                int new_n_good_moves = 0;
                if (show_log) {
                    std::cerr << "good moves (2):";
                }
                for (const Ponder_elem &elem: after_move_list) {
                    if (elem.value >= new_best_value - AI_TL_ADDITIONAL_SEARCH_THRESHOLD) {
                        ++new_n_good_moves;
                        if (show_log) {
                            std::cerr << " " << idx_to_coord(elem.flip.pos);
                        }
                    }
                }
                if (show_log) {
                    std::cerr << std::endl;
                }
                if (new_n_good_moves >= 2) {
                    time_limit = request_more_time(board, remaining_time_msec, time_limit, show_log);
                }
            }
        }
    }
    if (show_log) {
        std::cerr << "ai_common main search tl " << time_limit << std::endl;
    }
    Search_result search_result = ai_common(board, -SCORE_MAX, SCORE_MAX, MAX_LEVEL, use_book, book_acc_level, use_multi_thread, show_log, board.get_legal(), false, time_limit, thread_id, searching);
    if (show_log) {
        std::cerr << "ai_time_limit selected " << idx_to_coord(search_result.policy) << " value " << search_result.value << " depth " << search_result.depth << "@" << search_result.probability << "%" << " time " << tim() - strt << " " << board.to_str() << std::endl << std::endl;
    }
    return search_result;
    }

Analyze_result ai_analyze(Board board, int level, bool use_multi_thread, uint_fast8_t played_move) {
    int depth;
    bool is_mid_search;
    uint_fast8_t mpc_level;
    get_level(level, board.n_discs() - 4, &is_mid_search, &depth, &mpc_level);
    depth = std::min(HW2 - board.n_discs() - common_select::get_N_INVALID(), depth);
    bool is_end_search = (HW2 - board.n_discs() - common_select::get_N_INVALID() == depth);
    bool searching = true;
    std::vector<Clog_result> clogs;
    uint64_t clog_nodes = 0;
    uint64_t clog_time = 0;
    int clog_depth = std::min(depth, CLOG_SEARCH_MAX_DEPTH);
    if (mpc_level != MPC_100_LEVEL) {
        uint64_t clog_strt = tim();
        clogs = first_clog_search(board, &clog_nodes, clog_depth, board.get_legal(), &searching);
        clog_time = tim() - clog_strt;
    }
    Search search(&board, mpc_level, use_multi_thread, false);
    uint64_t strt = tim();
    
    Analyze_result res = first_nega_scout_analyze(&search, -SCORE_MAX, SCORE_MAX, depth, is_end_search, clogs, clog_depth, played_move, strt, &searching);
    
    return res;
}



Search_result ai_accept_loss(Board board, int level, int acceptable_loss) {
    uint64_t strt = tim();
    Flip flip;
    int v = SCORE_UNDEFINED;
    uint64_t legal = board.get_legal();
    std::vector<std::pair<int, int>> moves;
    
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&flip, &board, cell);
        board.move_board(&flip);
            int g = -ai(board, level, true, 0, true, false).value;
        board.undo_board(&flip);
        v = std::max(v, g);
        moves.emplace_back(std::make_pair(g, cell));
    }
    
    std::vector<std::pair<int, int>> acceptable_moves;
    for (std::pair<int, int> move: moves) {
        if (move.first >= v - acceptable_loss)
            acceptable_moves.emplace_back(move);
    }
    int rnd_idx = myrandrange(0, (int)acceptable_moves.size());
    int use_policy = acceptable_moves[rnd_idx].second;
    int use_value = acceptable_moves[rnd_idx].first;
    Search_result res;
    res.depth = 1;
    res.nodes = 0;
    res.time = tim() - strt;
    res.nps = calc_nps(res.nodes, res.time);
    res.policy = use_policy;
    res.value = use_value;
    res.is_end_search = board.n_discs() == HW2 - 1 - common_select::get_N_INVALID();
    res.probability = SELECTIVITY_PERCENTAGE[MPC_100_LEVEL];
    return res;
}

void ai_hint(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, int n_display, double values[], int hint_types[]) {
    uint64_t legal = board.get_legal();
    if (use_book) {
        std::vector<Book_value> links = book.get_all_moves_with_value(&board);
        for (Book_value &link: links) {
            values[link.policy] = link.value;
            hint_types[link.policy] = AI_TYPE_BOOK;
            legal ^= 1ULL << link.policy;
            --n_display;
        }
    }
    
    for (int search_level = 1; search_level <= level && global_searching; ++search_level) {
        
        
        
        uint64_t search_legal = legal;
        for (int i = 0; i < n_display && search_legal && global_searching; ++i) {
            Search_result elem = ai_legal(board, search_level, use_book, book_acc_level, use_multi_thread, false, search_legal);
            if (global_searching && (search_legal & (1ULL << elem.policy))) {
                search_legal ^= 1ULL << elem.policy;
                values[elem.policy] = elem.value;
                if (elem.is_end_search) {
                    hint_types[elem.policy] = elem.probability;
                } else{
                    hint_types[elem.policy] = search_level;
                }
            }
        }
    }
    
}

double selfplay_and_analyze(Board board, int level, bool show_log, thread_id_t thread_id, double before_val, bool *searching) {
    uint64_t strt = tim();
    
    std::vector<Board> boards;
    Flip flip;
    int score_sgn = -1;
    while (*searching) {
        if (board.get_legal() == 0ULL) {
            board.pass();
            score_sgn *= -1;
            if (board.get_legal() == 0ULL) {
                if (show_log) {
                    std::cerr << " result " << score_sgn * board.score_player();
                }
                break;
            }
        }
        boards.emplace_back(board);
        if (*searching) {
            Search_result search_result = ai_searching_thread_id(board, level, false, 0, true, false, thread_id, searching);
            if (*searching && is_valid_policy(search_result.policy)) {
                if (show_log) {
                    std::cerr << idx_to_coord(search_result.policy);
                }
                if (board.n_discs() >= HW2 - 21 - common_select::get_N_INVALID() && boards.size()) { 
                    if (show_log) {
                        std::cerr << "... result " << score_sgn * search_result.value;
                    }
                    break;
                }
                calc_flip(&flip, &board, search_result.policy);
                board.move_board(&flip);
                score_sgn *= -1;
            }
        }
        if (!(*searching)) {
            if (show_log) {
                std::cerr << " terminated" << std::endl;
            }
            break;
        }
    }
    if (!(*searching)) {
        return SCORE_UNDEFINED;
    }
    if (show_log) {
        std::cerr << " selfplay " << tim() - strt << " ms";
    }
    
    double res = SCORE_UNDEFINED;
    for (int i = boards.size() - 1; i >= 0; --i) {
        if (*searching) {
            transposition_table.del(&boards[i], boards[i].hash());
            Search_result search_result = ai_searching_thread_id(boards[i], level, false, 0, true, false, thread_id, searching);
            if (*searching) {
                int v = search_result.value;
                if (i == 0) {
                    if (show_log) {
                        std::cerr << " analyzed raw " << -v;
                    }
                    if (search_result.is_end_search) {
                        res = -v;
                    } else {
                        res = (0.9 * before_val + 1.1 * -v) / 2.0;
                    }
                }
            }
        }
        if (!(*searching)) {
            if (show_log) {
                std::cerr << " terminated" << std::endl;
            }
            break;
        }
    }
    return res;
}




Search_result selfplay_and_analyze_search_result(Board board, int level, bool show_log, thread_id_t thread_id, bool *searching) {
    uint64_t strt = tim();
    Search_result res;
    
    std::vector<Board> boards;
    Flip flip;
    int score_sgn = -1;
    while (*searching) {
        if (board.get_legal() == 0ULL) {
            board.pass();
            score_sgn *= -1;
            if (board.get_legal() == 0ULL) {
                if (show_log) {
                    std::cerr << " result " << score_sgn * board.score_player();
                }
                break;
            }
        }
        boards.emplace_back(board);
        if (*searching) {
            Search_result search_result = ai_searching_thread_id(board, level, false, 0, true, false, thread_id, searching);
            if (*searching && is_valid_policy(search_result.policy)) {
                if (show_log) {
                    std::cerr << idx_to_coord(search_result.policy);
                }
                if (board.n_discs() >= HW2 - 21 - common_select::get_N_INVALID() && boards.size()) { 
                    if (show_log) {
                        std::cerr << "... result " << score_sgn * search_result.value;
                    }
                    break;
                }
                calc_flip(&flip, &board, search_result.policy);
                board.move_board(&flip);
                score_sgn *= -1;
            }
        }
        if (!(*searching)) {
            if (show_log) {
                std::cerr << " terminated" << std::endl;
            }
            break;
        }
    }
    if (!(*searching)) {
        return res;
    }
    if (show_log) {
        std::cerr << " selfplay " << tim() - strt << " ms";
    }
    
    for (int i = boards.size() - 1; i >= 0; --i) {
        if (*searching) {
            transposition_table.del(&boards[i], boards[i].hash());
            Search_result search_result = ai_searching_thread_id(boards[i], level, false, 0, true, false, thread_id, searching);
            if (*searching) {
                int v = search_result.value;
                if (i == 0) {
                    if (show_log) {
                        std::cerr << " analyzed raw " << -v;
                    }
                    res.value = -v;
                    res.policy = search_result.policy;
                }
            }
        }
        if (!(*searching)) {
            if (show_log) {
                std::cerr << " terminated" << std::endl;
            }
            break;
        }
    }
    std::cerr << std::endl;
    return res;
}


bool comp_ponder_elem(Ponder_elem &a, Ponder_elem &b) {
    if (a.count == b.count) {
        return a.value > b.value;
    }
    return a.count > b.count;
}

std::vector<Ponder_elem> ai_ponder(Board board, bool show_log, thread_id_t thread_id, bool *searching) {
    uint64_t strt = tim();
    uint64_t legal = board.get_legal();
    if (legal == 0) {
        board.pass();
        legal = board.get_legal();
        if (legal == 0) {
            if (show_log) {
                std::cerr << "no ponder needed because of game over" << std::endl;
            }
            std::vector<Ponder_elem> empty_list;
            return empty_list;
        } else {
            std::cerr << "ponder pass found" << std::endl;
        }
    }
    const int canput = pop_count_ull(legal);
    std::vector<Ponder_elem> move_list(canput);
    int idx = 0;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&move_list[idx].flip, &board, cell);
        move_list[idx].value = INF;
        move_list[idx].count = 0;
        move_list[idx].level = 0;
        move_list[idx].depth = 0;
        move_list[idx].mpc_level = MPC_74_LEVEL;
        move_list[idx].is_endgame_search = false;
        move_list[idx].is_complete_search = false;
        ++idx;
    }
    const int max_depth = HW2 - board.n_discs() - common_select::get_N_INVALID() - 1;
    int n_searched_all = 0;
    while (*searching) {
        bool all_complete = true;
        for (int i = 0; i < canput; ++i) {
            all_complete &= move_list[i].is_complete_search;
        }
        if (all_complete) {
            if (show_log) {
                std::cerr << "ponder completely searched" << std::endl;
            }
            break;
        }

        int selected_idx = -1;
        double max_ucb = -INF - 1;
        for (int i = 0; i < canput; ++i) {
            double ucb = -INF;
            if (n_searched_all == 0) { 
                ucb = move_list[i].value;
            } else if (move_list[i].count == 0) { 
                ucb = INF;
            } else if (move_list[i].is_complete_search) { 
                ucb = -INF;
            } else {
                
                ucb = move_list[i].value / (double)HW2 + 0.6 * sqrt(log(2.0 * (double)n_searched_all) / (double)move_list[i].count);
            }
            if (ucb > max_ucb) {
                selected_idx = i;
                max_ucb = ucb;
            }
        }
        
        if (selected_idx == -1) {
            if (show_log) {
                std::cerr << "ponder: no move selected n_moves " << canput << std::endl;
            }
            break;
        }
        Board n_board = board.copy();
        n_board.move_board(&move_list[selected_idx].flip);
        int max_depth = HW2 - n_board.n_discs() - common_select::get_N_INVALID();
        int level = move_list[selected_idx].level + 1;
        Search_result search_result = ai_searching_thread_id(n_board, level, false, 0, true, false, thread_id, searching);
        double v = -search_result.value;
        if (move_list[selected_idx].depth >= PONDER_START_SELFPLAY_DEPTH && !move_list[selected_idx].is_endgame_search) { 
            double max_value = -INF;
            for (int i = 0; i < canput; ++i) {
                max_value = std::max(max_value, move_list[i].value);
            }
            if (v >= max_value - 3.25 && level >= 17) {
                
                double selfplay_val = selfplay_and_analyze(n_board, level, false, thread_id, v, searching);
                if (selfplay_val != SCORE_UNDEFINED) {
                    v = selfplay_val;
                }
            }
        }
        if (*searching) {
            move_list[selected_idx].level = level;
            bool is_mid_search;
            get_level(move_list[selected_idx].level, board.n_discs() - 4, &is_mid_search, &move_list[selected_idx].depth, &move_list[selected_idx].mpc_level);
            move_list[selected_idx].is_endgame_search = !is_mid_search;
            move_list[selected_idx].is_complete_search = !is_mid_search && move_list[selected_idx].mpc_level == MPC_100_LEVEL;
            ++move_list[selected_idx].count;
            if (move_list[selected_idx].value == INF || !is_mid_search) {
                move_list[selected_idx].value = v;
            } else {
                move_list[selected_idx].value = (0.9 * move_list[selected_idx].value + 1.1 * v) / 2.0;
            }
            ++n_searched_all;
        }
    }
    std::sort(move_list.begin(), move_list.end(), comp_ponder_elem);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    return move_list;
}

void print_ponder_result(std::vector<Ponder_elem> move_list) {
    std::cerr << "ponder result" << std::endl;
    for (int i = 0; i < move_list.size(); ++i) {
        std::cerr << "pd " << idx_to_coord(move_list[i].flip.pos) << " value " << std::fixed << std::setprecision(2) << move_list[i].value;
        std::cerr << " count " << move_list[i].count << " level " << move_list[i].level << " depth " << move_list[i].depth << "@" << SELECTIVITY_PERCENTAGE[move_list[i].mpc_level] << "%";
        if (move_list[i].is_complete_search) {
            std::cerr << " complete";
        } else if (move_list[i].is_endgame_search) {
            std::cerr << " endgame";
        }
        std::cerr << std::endl;
    }
    std::cerr << std::endl;
}

bool comp_get_values_elem(Ponder_elem &a, Ponder_elem &b) {
    if (a.value == b.value) {
        if (a.depth == b.depth) {
            return a.mpc_level > b.mpc_level;
        }
        return a.depth > b.depth;
    }
    return a.value > b.value;
}

std::vector<Ponder_elem> ai_get_values(Board board, bool show_log, uint64_t time_limit, thread_id_t thread_id) {
    uint64_t strt = tim();
    uint64_t legal = board.get_legal();
    if (legal == 0) {
        board.pass();
        legal = board.get_legal();
        if (legal == 0) {
            if (show_log) {
                std::cerr << "get values game overgame over" << std::endl;
            }
            std::vector<Ponder_elem> empty_list;
            return empty_list;
        } else {
            std::cerr << "get values pass found" << std::endl;
        }
    }
    const int canput = pop_count_ull(legal);
    std::vector<Ponder_elem> move_list(canput);
    int idx = 0;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&move_list[idx].flip, &board, cell);
        move_list[idx].value = INF;
        move_list[idx].count = 0;
        move_list[idx].depth = 0;
        move_list[idx].mpc_level = MPC_74_LEVEL;
        move_list[idx].is_endgame_search = false;
        move_list[idx].is_complete_search = false;
        ++idx;
    }
    uint64_t tl_per_move = time_limit / canput;
    if (show_log) {
        std::cerr << "get values tl per move " << tl_per_move << std::endl;
    }
    const int max_depth = HW2 - board.n_discs() - common_select::get_N_INVALID() - 1;
    for (Ponder_elem &elem: move_list) {
        uint64_t elem_strt = tim();
        while (tim() - elem_strt < tl_per_move && !elem.is_complete_search && global_searching) {
            Board n_board = board.copy();
            n_board.move_board(&elem.flip);
            int max_depth = HW2 - n_board.n_discs();
            int new_depth = elem.depth + 1;
            uint_fast8_t new_mpc_level = elem.mpc_level;
            if (new_depth > max_depth) {
                new_depth = max_depth;
                ++new_mpc_level;
            } else if (new_depth > max_depth - PONDER_ENDSEARCH_PRESEARCH_OFFSET_TIMELIMIT) {
                new_depth = max_depth;
            }
            bool new_is_end_search = (new_depth == max_depth);
            bool new_is_complete_search = new_is_end_search && new_mpc_level == MPC_100_LEVEL;
            Search search(&n_board, new_mpc_level, true, false);
            search.thread_id = thread_id;
            bool n_searching = true;
            uint64_t time_limit_this_search = get_this_search_time_limit(tl_per_move, tim() - elem_strt);
            std::future<int> v_future = std::async(std::launch::async, nega_scout, &search, -SCORE_MAX, SCORE_MAX, new_depth, false, LEGAL_UNDEFINED, new_is_end_search, &n_searching);
            if (v_future.wait_for(std::chrono::milliseconds(time_limit_this_search)) == std::future_status::ready) {
                int v = -v_future.get();
                if (global_searching) {
                    if (elem.value == INF || new_is_end_search) {
                        elem.value = v;
                    } else {
                        elem.value = (0.9 * elem.value + 1.1 * v) / 2.0;
                    }
                    elem.depth = new_depth;
                    elem.mpc_level = new_mpc_level;
                    elem.is_endgame_search = new_is_end_search;
                    elem.is_complete_search = new_is_complete_search;
                    ++elem.count;
                }
            } else {
                n_searching = false;
                try {
                    v_future.get();
                } catch (const std::exception &e) {
                }
            }
        }
    }
    std::sort(move_list.begin(), move_list.end(), comp_get_values_elem);
    if (show_log) {
        std::cerr << "ai_get_values searched in " << tim() - strt << " ms" << std::endl;
        std::cerr << "ai_get_values board " << board.to_str() << std::endl;
        for (int i = 0; i < canput; ++i) {
            std::cerr << "gb " << idx_to_coord(move_list[i].flip.pos) << " value " << std::fixed << std::setprecision(2) << move_list[i].value;
            std::cerr << " count " << move_list[i].count << " depth " << move_list[i].depth << "@" << SELECTIVITY_PERCENTAGE[move_list[i].mpc_level] << "%";
            if (move_list[i].is_complete_search) {
                std::cerr << " complete";
            } else if (move_list[i].is_endgame_search) {
                std::cerr << " endgame";
            }
            std::cerr << std::endl;
        }
    }
    return move_list;
}

std::vector<Ponder_elem> ai_align_move_levels(Board board, bool show_log, std::vector<Ponder_elem> move_list, int n_good_moves, uint64_t time_limit, thread_id_t thread_id, int aligned_min_level) {
    uint64_t strt = tim();
    if (show_log) {
        std::cerr << "align levels tl " << time_limit << " n_good_moves " << n_good_moves << " out of " << move_list.size() << std::endl;
    }
    const int max_depth = HW2 - board.n_discs() - common_select::get_N_INVALID() - 1;
    while (tim() - strt < time_limit) {
        int min_depth = 100;
        for (int i = 0; i < n_good_moves; ++i) {
            min_depth = std::min(min_depth, move_list[i].depth);
        }
        if (min_depth >= aligned_min_level) {
            std::cerr << "min depth >= " << aligned_min_level << std::endl;
            break;
        }
        bool level_aligned = true;
        for (int i = 0; i < n_good_moves; ++i) {
            if (move_list[i].depth != move_list[0].depth || move_list[i].mpc_level != move_list[0].mpc_level) {
                level_aligned = false;
                break;
            }
        }
        if (level_aligned && min_depth >= aligned_min_level) {
            if (show_log) {
                std::cerr << "level aligned & min depth >= " << aligned_min_level << std::endl;
            }
            break;
        }
        int min_depth2 = INF;
        uint_fast8_t min_mpc_level = 100;
        int selected_idx = -1;
        for (int i = 0; i < n_good_moves; ++i) {
            if (move_list[i].depth < min_depth2) {
                min_depth2 = move_list[i].depth;
                min_mpc_level = move_list[i].mpc_level;
                selected_idx = i;
            } else if (move_list[i].depth == min_depth2 && move_list[i].mpc_level < min_mpc_level) {
                min_mpc_level = move_list[i].mpc_level;
                selected_idx = i;
            }
        }
        if (move_list[selected_idx].is_complete_search) {
            if (show_log) {
                std::cerr << "completely searched" << std::endl;
            }
            break;
        }
        Board n_board = board.copy();
        n_board.move_board(&move_list[selected_idx].flip);
        int max_depth = HW2 - n_board.n_discs() - common_select::get_N_INVALID();
        int new_depth = move_list[selected_idx].depth + 1;
        uint_fast8_t new_mpc_level = move_list[selected_idx].mpc_level;
        if (new_depth > max_depth) {
            new_depth = max_depth;
            ++new_mpc_level;
        } else if (new_depth > max_depth - PONDER_ENDSEARCH_PRESEARCH_OFFSET_TIMELIMIT) {
            new_depth = max_depth;
        }
        bool new_is_end_search = (new_depth == max_depth);
        bool new_is_complete_search = new_is_end_search && new_mpc_level == MPC_100_LEVEL;
        Search search(&n_board, new_mpc_level, true, false);
        search.thread_id = thread_id;
        bool n_searching = true;
        uint64_t time_limit_this_search = get_this_search_time_limit(time_limit, tim() - strt);
        std::future<int> v_future = std::async(std::launch::async, nega_scout, &search, -SCORE_MAX, SCORE_MAX, new_depth, false, LEGAL_UNDEFINED, new_is_end_search, &n_searching);
        if (v_future.wait_for(std::chrono::milliseconds(time_limit_this_search)) == std::future_status::ready) {
            int v = -v_future.get();
            if (global_searching) {
                if (move_list[selected_idx].value == INF || new_is_end_search) {
                    move_list[selected_idx].value = v;
                } else {
                    move_list[selected_idx].value = (0.9 * move_list[selected_idx].value + 1.1 * v) / 2.0;
                }
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                move_list[selected_idx].depth = new_depth;
                move_list[selected_idx].mpc_level = new_mpc_level;
                move_list[selected_idx].is_endgame_search = new_is_end_search;
                move_list[selected_idx].is_complete_search = new_is_complete_search;
                ++move_list[selected_idx].count;
            }
        } else {
            n_searching = false;
            try {
                v_future.get();
            } catch (const std::exception &e) {
            }
        }
    }
    std::sort(move_list.begin(), move_list.end(), comp_get_values_elem);
    if (show_log) {
        std::cerr << "ai_align_move_levels searched in " << tim() - strt << " ms" << std::endl;
        std::cerr << "ai_align_move_levels board " << board.to_str() << std::endl;
        for (int i = 0; i < n_good_moves; ++i) {
            std::cerr << "ag " << idx_to_coord(move_list[i].flip.pos) << " value " << std::fixed << std::setprecision(2) << move_list[i].value;
            std::cerr << " count " << move_list[i].count << " depth " << move_list[i].depth << "@" << SELECTIVITY_PERCENTAGE[move_list[i].mpc_level] << "%";
            if (move_list[i].is_complete_search) {
                std::cerr << " complete";
            } else if (move_list[i].is_endgame_search) {
                std::cerr << " endgame";
            }
            std::cerr << std::endl;
        }
    }
    return move_list;
}

std::vector<Ponder_elem> ai_additional_selfplay(Board board, bool show_log, std::vector<Ponder_elem> move_list, int n_good_moves, double threshold, uint64_t time_limit, thread_id_t thread_id) {
    uint64_t strt = tim();
    if (show_log) {
        std::cerr << "additional selfplay tl " << time_limit << " n_good_moves " << n_good_moves << " out of " << move_list.size() << std::endl;
    }
    const int max_depth = HW2 - board.n_discs() - common_select::get_N_INVALID() - 1;
    const int initial_level = 21;
    constexpr int n_same_level = 1;
    std::vector<int> levels;
    for (int i = 0; i < n_good_moves; ++i) {
        levels.emplace_back(initial_level * n_same_level);
    }
    std::vector<bool> is_first_searches;
    for (int i = 0; i < n_good_moves; ++i) {
        is_first_searches.emplace_back(true);
    }
    
    std::vector<Clog_result> clogs;
    std::vector<Board> n_boards;
    Flip flip;
    while (tim() - strt < time_limit) {
        double first_val = -INF, second_val = -INF;
        int first_level = -1, second_level = -1;
        for (int i = 0; i < n_good_moves; ++i) {
            if (move_list[i].value > first_val) {
                second_val = first_val;
                first_val = move_list[i].value;
                first_level = (levels[i] - 1) / n_same_level;
            } else if (move_list[i].value > second_val) {
                second_val = move_list[i].value;
                second_level = (levels[i] - 1) / n_same_level;
            }
        }
        if (
            (first_val - second_val > threshold * 1.114 && first_level >= 25 && second_level >= 25) || 
            first_val - second_val > threshold * 1.686
        ) {
            if (show_log) {
                std::cerr << "enough differences found first " << first_val << "@lv." << first_level << " second " << second_val << "@lv." << second_level << std::endl;
            }
            break;
        }
        double max_val = -INF;
        int selected_idx = -1;
        for (int i = 0; i < n_good_moves; ++i) {
            
            if (!(move_list[i].is_endgame_search && move_list[i].mpc_level >= MPC_99_LEVEL)) {
                if (levels[i] == initial_level * n_same_level) {
                    selected_idx = i;
                    break;
                } else {
                    double val = move_list[i].value + myrandom() * threshold * 2.0 + (double)(60 - initial_level - levels[i] / n_same_level) * 0.5; 
                    if (val > max_val) {
                        max_val = val;
                        selected_idx = i;
                    }
                }
            }
        }
        if (selected_idx == -1) {
            if (show_log) {
                std::cerr << "enough searched" << std::endl;
            }
            break;
        }
        int level = levels[selected_idx] / n_same_level;
        std::cerr << "move " << idx_to_coord(move_list[selected_idx].flip.pos) << " selfplay lv." << level << " ";
        Board n_board = board.copy();
        n_board.move_board(&move_list[selected_idx].flip);
        uint64_t tl_selfplay = 1;
        uint64_t elapsed_now = tim() - strt;
        if (elapsed_now < time_limit) {
            tl_selfplay = time_limit - elapsed_now;
        }
        bool searching = true;
        std::future<double> selfplay_future = std::async(std::launch::async, selfplay_and_analyze, n_board, level, true, thread_id, move_list[selected_idx].value, &searching);
        if (selfplay_future.wait_for(std::chrono::milliseconds(tl_selfplay)) == std::future_status::ready) {
            double selfplay_val = selfplay_future.get();
            if (selfplay_val != SCORE_UNDEFINED) {
                move_list[selected_idx].value = selfplay_val;
                int depth;
                uint_fast8_t mpc_level;
                bool is_mid_search;
                get_level(level, n_board.n_discs() - 4, &is_mid_search, &depth, &mpc_level);
                move_list[selected_idx].depth = depth;
                move_list[selected_idx].mpc_level = mpc_level;
                move_list[selected_idx].is_endgame_search = (HW2 - n_board.n_discs() - common_select::get_N_INVALID()) <= depth;
                move_list[selected_idx].is_complete_search = move_list[selected_idx].is_endgame_search && mpc_level == MPC_100_LEVEL;
                ++move_list[selected_idx].count;
                std::cerr << " value " << move_list[selected_idx].value << " depth " << depth << "@" << SELECTIVITY_PERCENTAGE[mpc_level] << "% " << tim() - strt << " ms" << std::endl;
                is_first_searches[selected_idx] = false;
                ++levels[selected_idx];
            }
        } else {
            searching = false;
            selfplay_future.get();
        }
    }
    std::sort(move_list.begin(), move_list.end(), comp_get_values_elem);
    if (show_log) {
        std::cerr << "ai_additional_selfplay searched in " << tim() - strt << " ms" << std::endl;
        std::cerr << "ai_additional_selfplay board " << board.to_str() << std::endl;
        for (int i = 0; i < n_good_moves; ++i) {
            std::cerr << "sm " << idx_to_coord(move_list[i].flip.pos) << " value " << std::fixed << std::setprecision(2) << move_list[i].value;
            std::cerr << " count " << move_list[i].count << " depth " << move_list[i].depth << "@" << SELECTIVITY_PERCENTAGE[move_list[i].mpc_level] << "%";
            if (move_list[i].is_complete_search) {
                std::cerr << " complete";
            } else if (move_list[i].is_endgame_search) {
                std::cerr << " endgame";
            }
            std::cerr << std::endl;
        }
    }
    return move_list;
}

Search_result ai_range(Board board, int level, int score_min, int score_max, bool *searching) {
    std::vector<Search_result> moves_in_range;
    uint64_t legal = board.get_legal();
    for (uint_fast8_t cell = first_bit(&legal); legal && *searching; cell = next_bit(&legal)) {
        Flip flip;
        bool passed = false;
        calc_flip(&flip, &board, cell);
        board.move_board(&flip);
            if (board.is_end()) {
                board.undo_board(&flip);
                continue;
            }
            if (board.get_legal() == 0) {
                board.pass();
                passed = true;
            }
            int alpha = passed ? score_min : -score_max;
            int beta = passed ? score_max : -score_min;
            alpha = std::min(-SCORE_MAX, alpha - 1);
            beta = std::max(SCORE_MAX, beta + 1);
            Search_result res = ai_window_legal_searching(board, alpha, beta, level, true, 0, true, false, board.get_legal(), searching);
            if (res.value >= score_min && res.value <= score_max) {
                Search_result move_res = res;
                move_res.policy = cell;
                moves_in_range.push_back(move_res);
            }
            if (passed) {
                board.pass();
            }
        board.undo_board(&flip);
    }
    if (!moves_in_range.empty()) {
        return moves_in_range[myrandrange(0, (int)moves_in_range.size())];
    } else {
        Search_result res;
        res.value = SCORE_UNDEFINED;
        res.policy = MOVE_UNDEFINED;
        return res;
    }
}


// ===== FILE: Egaroucid/src/engine/bit_common.hpp =====



#pragma once
#include <iostream>


inline void bit_print_reverse(uint64_t x) {
    for (uint32_t i = 0; i < HW2; ++i) {
        std::cerr << (1 & (x >> i));
    }
    std::cerr << std::endl;
}


inline void bit_print(uint64_t x) {
    for (uint32_t i = 0; i < HW2; ++i) {
        std::cerr << (1 & (x >> (HW2_M1 - i)));
    }
    std::cerr << std::endl;
}


inline void bit_print_uchar(uint8_t x) {
    for (uint32_t i = 0; i < HW; ++i) {
        std::cerr << (1 & (x >> (HW_M1 - i)));
    }
    std::cerr << std::endl;
}


inline void bit_print_board(uint64_t x) {
    for (uint32_t i = 0; i < HW2; ++i) {
        std::cerr << (1 & (x >> (HW2_M1 - i)));
        if (i % HW == HW_M1) {
            std::cerr << std::endl;
        }
    }
    std::cerr << std::endl;
}


void print_board(uint64_t p, uint64_t o) {
    for (int i = 0; i < HW2; ++i) {
        if (1 & (p >> (HW2_M1 - i))) {
            std::cerr << '0';
        } else if (1 & (o >> (HW2_M1 - i))) {
            std::cerr << '1';
        } else {
            std::cerr << '.';
        }
        if (i % HW == HW_M1) {
            std::cerr << std::endl;
        }
    }
}

// ===== FILE: Egaroucid/src/engine/bit_generic.hpp =====



#pragma once
#include <iostream>
#include "common_select.hpp"


#define pop_count_ull(x) std::popcount(x)
#define pop_count_uint(x) std::popcount(x)
#define pop_count_uchar(x) std::popcount(x)




inline uint32_t pop_digit(uint64_t x, int place) {
    return (uint32_t)(1ULL & (x >> place));
}


inline uint64_t white_line_mirror(uint64_t x) {
    uint64_t a = (x ^ (x >> 7)) & 0x00AA00AA00AA00AAULL;
    x = x ^ a ^ (a << 7);
    a = (x ^ (x >> 14)) & 0x0000CCCC0000CCCCULL;
    x = x ^ a ^ (a << 14);
    a = (x ^ (x >> 28)) & 0x00000000F0F0F0F0ULL;
    return x ^ a ^ (a << 28);
}


inline uint64_t black_line_mirror(uint64_t x) {
    uint64_t a = (x ^ (x >> 9)) & 0x0055005500550055ULL;
    x = x ^ a ^ (a << 9);
    a = (x ^ (x >> 18)) & 0x0000333300003333ULL;
    x = x ^ a ^ (a << 18);
    a = (x ^ (x >> 36)) & 0x000000000F0F0F0FULL;
    return x ^ a ^ (a << 36);
}


inline uint64_t vertical_mirror(uint64_t x) {
    x = ((x >> 8) & 0x00FF00FF00FF00FFULL) | ((x << 8) & 0xFF00FF00FF00FF00ULL);
    x = ((x >> 16) & 0x0000FFFF0000FFFFULL) | ((x << 16) & 0xFFFF0000FFFF0000ULL);
    return ((x >> 32) & 0x00000000FFFFFFFFULL) | ((x << 32) & 0xFFFFFFFF00000000ULL);
}


inline uint64_t horizontal_mirror(uint64_t x) {
    x = ((x >> 1) & 0x5555555555555555ULL) | ((x << 1) & 0xAAAAAAAAAAAAAAAAULL);
    x = ((x >> 2) & 0x3333333333333333ULL) | ((x << 2) & 0xCCCCCCCCCCCCCCCCULL);
    return ((x >> 4) & 0x0F0F0F0F0F0F0F0FULL) | ((x << 4) & 0xF0F0F0F0F0F0F0F0ULL);
}


inline uint64_t rotate_90(uint64_t x) {
    return vertical_mirror(white_line_mirror(x));
}


inline uint64_t rotate_270(uint64_t x) {
    return vertical_mirror(black_line_mirror(x));
}


inline uint64_t rotate_180(uint64_t x) {
    x = ((x & 0x5555555555555555ULL) << 1) | ((x & 0xAAAAAAAAAAAAAAAAULL) >> 1);
    x = ((x & 0x3333333333333333ULL) << 2) | ((x & 0xCCCCCCCCCCCCCCCCULL) >> 2);
    x = ((x & 0x0F0F0F0F0F0F0F0FULL) << 4) | ((x & 0xF0F0F0F0F0F0F0F0ULL) >> 4);
    x = ((x & 0x00FF00FF00FF00FFULL) << 8) | ((x & 0xFF00FF00FF00FF00ULL) >> 8);
    x = ((x & 0x0000FFFF0000FFFFULL) << 16) | ((x & 0xFFFF0000FFFF0000ULL) >> 16);
    return ((x & 0x00000000FFFFFFFFULL) << 32) | ((x & 0xFFFFFFFF00000000ULL) >> 32);
}


#if USE_MINUS_NTZ
inline uint_fast8_t ctz(uint64_t *x) {
    return pop_count_ull((*x & (-(*x))) - 1);
}

inline uint_fast8_t ctz(uint64_t x) {
    return pop_count_ull((x & (-x)) - 1);
}

inline uint_fast8_t ctz_uint32(uint32_t x) {
    return pop_count_uint((x & (-x)) - 1);
}
#else
inline uint_fast8_t ctz(uint64_t *x) {
    return pop_count_ull((~(*x)) & ((*x) - 1));
}

inline uint_fast8_t ctz(uint64_t x) {
    return pop_count_ull((~x) & (x - 1));
}

inline uint_fast8_t ctz_uint32(uint32_t x) {
    return pop_count_uint((~x) & (x - 1));
}
#endif


inline uint_fast8_t first_bit(uint64_t *x) {
    return ctz(x);
}


inline uint_fast8_t next_bit(uint64_t *x) {
    *x &= *x - 1;
    return ctz(x);
}

inline uint_fast8_t join_h_line(uint64_t x, int t) {
    return (x >> (HW * t)) & 0b11111111U;
}

inline uint64_t split_h_line(uint_fast8_t x, int_fast8_t t) {
    return (uint64_t)x << (HW * t);
}

inline uint_fast8_t join_v_line(uint64_t x, int c) {
    x = (x >> c) & 0x0101010101010101ULL;
    return (x * 0x0102040810204080ULL) >> 56;
}

inline uint64_t split_v_line(uint8_t x, int c) {
    uint64_t res = ((uint64_t)x * 0x0002040810204081ULL) & 0x0101010101010101ULL;
    return res << c;
}

constexpr uint64_t join_d7_line_mask[15] = {
    0ULL, 0ULL, 0x0000000000010204ULL, 0x0000000001020408ULL, 
    0x0000000102040810ULL, 0x0000010204081020ULL, 0x0001020408102040ULL, 0x0102040810204080ULL, 
    0x0204081020408000ULL, 0x0408102040800000ULL, 0x0810204080000000ULL, 0x1020408000000000ULL, 
    0x2040800000000000ULL, 0ULL, 0ULL
};

constexpr uint8_t join_d7_line_leftshift[15] = {
    0, 0, 5, 4, 
    3, 2, 1, 0, 
    0, 0, 0, 0, 
    0, 0, 0
};

constexpr uint8_t join_d7_line_rightshift[15] = {
    0, 0, 0, 0, 
    0, 0, 0, 0, 
    8, 16, 24, 32, 
    40, 0, 0
};


inline int join_d7_line(uint64_t x, const int t) {
    x = (x & join_d7_line_mask[t]);
    x <<= join_d7_line_leftshift[t];
    x >>= join_d7_line_rightshift[t];
    uint64_t res = ((x * 0x0002082080000000ULL) & 0x0F00000000000000ULL) | ((x * 0x0000000002082080ULL) & 0xF000000000000000ULL);
    return res >> 56;
}

inline uint64_t split_d7_line(uint8_t x, const int t) {
    uint64_t res = ((uint64_t)(x & 0b00001111) * 0x0000000002082080ULL) & 0x0000000010204080ULL;
    res |= ((uint64_t)(x & 0b11110000) * 0x0002082080000000ULL) & 0x0102040800000000ULL;
    res >>= join_d7_line_leftshift[t];
    res <<= join_d7_line_rightshift[t];
    return res;
}

constexpr uint64_t join_d9_line_mask[15] = {
    0ULL, 0ULL, 0x0402010000000000ULL, 0x0804020100000000ULL, 
    0x1008040201000000ULL, 0x2010080402010000ULL, 0x4020100804020100ULL, 0x8040201008040201ULL, 
    0x0080402010080402ULL, 0x0000804020100804ULL, 0x0000008040201008ULL, 0x0000000080402010ULL, 
    0x0000000000804020ULL, 0ULL, 0ULL
};

constexpr uint8_t join_d9_line_rightshift[15] = {
    0, 0, 40, 32, 
    24, 16, 8, 0, 
    1, 2, 3, 4, 
    5, 0, 0
};


inline int join_d9_line(uint64_t x, int t) {
    x = x & join_d9_line_mask[t];
    x >>= join_d9_line_rightshift[t];
    return (x * 0x0101010101010101ULL) >> 56;
}

inline uint64_t split_d9_line(uint8_t x, int t) {
    uint64_t res = ((uint64_t)x * 0x0101010101010101ULL) & 0x8040201008040201ULL;
    res <<= join_d9_line_rightshift[t];
    return res;
}



void bit_init() {
}

// ===== FILE: Egaroucid/src/engine/bit.hpp =====



#pragma once
#include "setting.hpp"
#include "common_select.hpp"
#include "bit_common.hpp"
#if USE_SIMD
#include "bit_simd.hpp"
#else
#include "bit_generic.hpp"
#endif

// ===== FILE: Egaroucid/src/engine/bit_simd.hpp =====



#pragma once
#include <iostream>
#ifdef _MSC_VER
#include <intrin.h>
#include <stdlib.h>
#else
#include <x86intrin.h>
#include <immintrin.h>
#endif
#include "common_select.hpp"

void mm_print_epu16(__m128i v) {
    uint16_t* varray = (uint16_t*)&v;
    for (int i = 0; i < 8; ++i) {
        std::cerr << (int)varray[i] << " ";
    }
    std::cerr << std::endl;
}

void mm_print_epi32(__m128i v) {
    int* varray = (int*)&v;
    for (int i = 0; i < 4; ++i) {
        std::cerr << varray[i] << " ";
    }
    std::cerr << std::endl;
}

void mm_print_epu64(__m128i v) {
    uint64_t* varray = (uint64_t*)&v;
    for (int i = 0; i < 2; ++i) {
        std::cerr << varray[i] << " ";
    }
    std::cerr << std::endl;
}


void mm256_print_epu64(__m256i v) {
    uint64_t* varray = (uint64_t*)&v;
    for (int i = 0; i < 4; ++i) {
        std::cerr << varray[i] << " ";
    }
    std::cerr << std::endl;
}

void mm256_print_epi32(__m256i v) {
    int* varray = (int*)&v;
    for (int i = 0; i < 8; ++i) {
        std::cerr << varray[i] << " ";
    }
    std::cerr << std::endl;
}

void mm256_print_epu16(__m256i v) {
    uint16_t* varray = (uint16_t*)&v;
    for (int i = 0; i < 16; ++i) {
        std::cerr << varray[i] << " ";
    }
    std::cerr << std::endl;
}



#if USE_BUILTIN_POPCOUNT
#ifdef __GNUC__
#define pop_count_ull(x) (int)__builtin_popcountll(x)
#define pop_count_uint(x) (int)__builtin_popcount(x)
#define pop_count_uchar(x) (int)__builtin_popcount(x)
#else
#define pop_count_ull(x) (int)__popcnt64(x)
#define pop_count_uint(x) (int)__popcnt(x)
#define pop_count_uchar(x) (int)__popcnt(x)
#endif
#else
#define pop_count_ull(x) std::popcount(x)
#define pop_count_uint(x) std::popcount(x)
#define pop_count_uchar(x) std::popcount(x)
#endif


inline uint32_t pop_digit(uint64_t x, int place) {
    return (uint32_t)(1ULL & (x >> place));
}


inline uint64_t white_line_mirror(uint64_t x) {
    uint64_t a = (x ^ (x >> 7)) & 0x00AA00AA00AA00AAULL;
    x = x ^ a ^ (a << 7);
    a = (x ^ (x >> 14)) & 0x0000CCCC0000CCCCULL;
    x = x ^ a ^ (a << 14);
    a = (x ^ (x >> 28)) & 0x00000000F0F0F0F0ULL;
    return x ^ a ^ (a << 28);
}


inline uint64_t black_line_mirror(uint64_t x) {
    uint64_t a = (x ^ (x >> 9)) & 0x0055005500550055ULL;
    x = x ^ a ^ (a << 9);
    a = (x ^ (x >> 18)) & 0x0000333300003333ULL;
    x = x ^ a ^ (a << 18);
    a = (x ^ (x >> 36)) & 0x000000000F0F0F0FULL;
    return x ^ a ^ (a << 36);
}


#ifdef _MSC_VER
#define vertical_mirror(x) _byteswap_uint64(x)
#else
#define vertical_mirror(x) _bswap64(x)
#endif



inline uint64_t horizontal_mirror(uint64_t x) {
    x = ((x >> 1) & 0x5555555555555555ULL) | ((x << 1) & 0xAAAAAAAAAAAAAAAAULL);
    x = ((x >> 2) & 0x3333333333333333ULL) | ((x << 2) & 0xCCCCCCCCCCCCCCCCULL);
    return ((x >> 4) & 0x0F0F0F0F0F0F0F0FULL) | ((x << 4) & 0xF0F0F0F0F0F0F0F0ULL);
}


inline uint64_t rotate_90(uint64_t x) {
    return vertical_mirror(white_line_mirror(x));
}


inline uint64_t rotate_270(uint64_t x) {
    return vertical_mirror(black_line_mirror(x));
}


#ifdef __clang_version__
#define rotate_180(x) __builtin_bitreverse64(x)
#else
inline uint64_t rotate_180(uint64_t x) {
    x = ((x & 0x5555555555555555ULL) << 1) | ((x & 0xAAAAAAAAAAAAAAAAULL) >> 1);
    x = ((x & 0x3333333333333333ULL) << 2) | ((x & 0xCCCCCCCCCCCCCCCCULL) >> 2);
    x = ((x & 0x0F0F0F0F0F0F0F0FULL) << 4) | ((x & 0xF0F0F0F0F0F0F0F0ULL) >> 4);
    x = ((x & 0x00FF00FF00FF00FFULL) << 8) | ((x & 0xFF00FF00FF00FF00ULL) >> 8);
    x = ((x & 0x0000FFFF0000FFFFULL) << 16) | ((x & 0xFFFF0000FFFF0000ULL) >> 16);
    return ((x & 0x00000000FFFFFFFFULL) << 32) | ((x & 0xFFFFFFFF00000000ULL) >> 32);
}
#endif


#if USE_BUILTIN_NTZ
inline uint_fast8_t ctz(uint64_t *x) {
    return _tzcnt_u64(*x);
}

inline uint_fast8_t ctz(uint64_t x) {
    return _tzcnt_u64(x);
}

inline uint_fast8_t ctz_uint32(uint32_t x) {
    return _tzcnt_u32(x);
}
#elif USE_MINUS_NTZ
inline uint_fast8_t ctz(uint64_t *x) {
    return pop_count_ull((*x & (-(*x))) - 1);
}

inline uint_fast8_t ctz(uint64_t x) {
    return pop_count_ull((x & (-x)) - 1);
}

inline uint_fast8_t ctz_uint32(uint32_t x) {
    return pop_count_uint((x & (-x)) - 1);
}
#else
inline uint_fast8_t ctz(uint64_t *x) {
    
    return pop_count_ull((~(*x)) & ((*x) - 1));
    
}

inline uint_fast8_t ctz(uint64_t x) {
    return pop_count_ull((~x) & (x - 1));
}

inline uint_fast8_t ctz_uint32(uint32_t x) {
    return pop_count_uint((~x) & (x - 1));
}
#endif


inline uint_fast8_t first_bit(uint64_t *x) {
    return ctz(x);
}


inline uint_fast8_t next_bit(uint64_t *x) {
#if USE_FAST_NEXT_BIT
    *x = _blsr_u64(*x);
#else
    *x &= *x - 1;
#endif
    return ctz(x);
}

#if USE_BIT_GATHER_OPTIMIZE

inline uint64_t split_h_line(uint_fast8_t x, int_fast8_t t) {
    return (uint64_t)x << (HW * t);
}


inline uint64_t split_v_line(uint_fast8_t x, int_fast8_t t) {
    return _pdep_u64((uint64_t)x, 0x0101010101010101ULL) << t;
}


inline uint_fast8_t join_h_line(uint64_t x, int t) {
#if USE_FAST_JOIN_H_LINE
    return _bextr_u64(x, HW * t, 8);
#else
    return (x >> (HW * t)) & 0b11111111U;
#endif
}


inline uint8_t join_v_line(uint64_t x, int_fast8_t t) {
    
    x = (x >> t) & 0x0101010101010101ULL;
    return (x * 0x0102040810204080ULL) >> 56;
}


inline uint64_t split_d7_line(uint8_t x, int_fast8_t t) {
    return _pdep_u64((uint64_t)x, 0x0002040810204081ULL) << t;
}


inline uint64_t split_d9_line(uint8_t x, int_fast8_t t) {
    uint64_t res = _pdep_u64((uint64_t)x, 0x8040201008040201ULL);
    return t > 0 ? res << t : res >> (-t);
}

constexpr uint64_t join_d7_line_mask[15] = {
    0ULL, 0ULL, 0x0000000000010204ULL, 0x0000000001020408ULL, 
    0x0000000102040810ULL, 0x0000010204081020ULL, 0x0001020408102040ULL, 0x0102040810204080ULL, 
    0x0204081020408000ULL, 0x0408102040800000ULL, 0x0810204080000000ULL, 0x1020408000000000ULL, 
    0x2040800000000000ULL, 0ULL, 0ULL
};


inline uint_fast8_t join_d7_line(const uint64_t x, const uint_fast8_t t) {
    return _pext_u64(x, join_d7_line_mask[t]);
}

constexpr uint64_t join_d9_line_mask[15] = {
    0ULL, 0ULL, 0x0402010000000000ULL, 0x0804020100000000ULL, 
    0x1008040201000000ULL, 0x2010080402010000ULL, 0x4020100804020100ULL, 0x8040201008040201ULL, 
    0x0080402010080402ULL, 0x0000804020100804ULL, 0x0000008040201008ULL, 0x0000000080402010ULL, 
    0x0000000000804020ULL, 0ULL, 0ULL
};


inline uint_fast8_t join_d9_line(const uint64_t x, const uint_fast8_t t) {
    return _pext_u64(x, join_d9_line_mask[t]);
}
#else
inline uint_fast8_t join_h_line(uint64_t x, int t) {
    return (x >> (HW * t)) & 0b11111111U;
}

inline uint64_t split_h_line(uint_fast8_t x, int_fast8_t t) {
    return (uint64_t)x << (HW * t);
}

inline int join_v_line(uint64_t x, int c) {
    x = (x >> c) & 0x0101010101010101ULL;
    return (x * 0x0102040810204080ULL) >> 56;
}

inline uint64_t split_v_line(uint8_t x, int c) {
    uint64_t res = ((uint64_t)x * 0x0002040810204081ULL) & 0x0101010101010101ULL;
    return res << c;
}

constexpr uint64_t join_d7_line_mask[15] = {
    0ULL, 0ULL, 0x0000000000010204ULL, 0x0000000001020408ULL, 
    0x0000000102040810ULL, 0x0000010204081020ULL, 0x0001020408102040ULL, 0x0102040810204080ULL, 
    0x0204081020408000ULL, 0x0408102040800000ULL, 0x0810204080000000ULL, 0x1020408000000000ULL, 
    0x2040800000000000ULL, 0ULL, 0ULL
};

constexpr uint8_t join_d7_line_leftshift[15] = {
    0, 0, 5, 4, 
    3, 2, 1, 0, 
    0, 0, 0, 0, 
    0, 0, 0
};

constexpr uint8_t join_d7_line_rightshift[15] = {
    0, 0, 0, 0, 
    0, 0, 0, 0, 
    8, 16, 24, 32, 
    40, 0, 0
};

inline int join_d7_line(uint64_t x, const int t) {
    x = (x & join_d7_line_mask[t]);
    x <<= join_d7_line_leftshift[t];
    x >>= join_d7_line_rightshift[t];
    uint64_t res = ((x * 0x0002082080000000ULL) & 0x0F00000000000000ULL) | ((x * 0x0000000002082080ULL) & 0xF000000000000000ULL);
    return res >> 56;
}

inline uint64_t split_d7_line(uint8_t x, const int t) {
    uint64_t res = ((uint64_t)(x & 0b00001111) * 0x0000000002082080ULL) & 0x0000000010204080ULL;
    res |= ((uint64_t)(x & 0b11110000) * 0x0002082080000000ULL) & 0x0102040800000000ULL;
    res >>= join_d7_line_leftshift[t];
    res <<= join_d7_line_rightshift[t];
    return res;
}

constexpr uint64_t join_d9_line_mask[15] = {
    0ULL, 0ULL, 0x0402010000000000ULL, 0x0804020100000000ULL, 
    0x1008040201000000ULL, 0x2010080402010000ULL, 0x4020100804020100ULL, 0x8040201008040201ULL, 
    0x0080402010080402ULL, 0x0000804020100804ULL, 0x0000008040201008ULL, 0x0000000080402010ULL, 
    0x0000000000804020ULL, 0ULL, 0ULL
};

constexpr uint8_t join_d9_line_rightshift[15] = {
    0, 0, 40, 32, 
    24, 16, 8, 0, 
    1, 2, 3, 4, 
    5, 0, 0
};

inline int join_d9_line(uint64_t x, int t) {
    x = x & join_d9_line_mask[t];
    x >>= join_d9_line_rightshift[t];
    return (x * 0x0101010101010101ULL) >> 56;
}

inline uint64_t split_d9_line(uint8_t x, int t) {
    uint64_t res = ((uint64_t)x * 0x0101010101010101ULL) & 0x8040201008040201ULL;
    res <<= join_d9_line_rightshift[t];
    return res;
}
#endif


void bit_init() {
}

// ===== FILE: Egaroucid/src/engine/board1.hpp =====

#pragma once
#include "board.hpp"



class Board1 {
private:
    Board board;

public:
    static constexpr uint64_t INVALID_MASK = 0xC3C300000000C3C3ULL;
    static constexpr uint64_t CORNER_MASK =
0x2400810000810024ULL;

    int get_corner_n_moves(uint64_t legal) const {
        return pop_count_ull(legal & CORNER_MASK);
    }

    
    Board1() : board() { board.invalid_mask = INVALID_MASK; }
    Board1(uint64_t player_, uint64_t opponent_) : board(player_, opponent_) {
        board.invalid_mask = INVALID_MASK;
    }
    Board1(const std::string& board_str) : board(board_str) {
        board.invalid_mask = INVALID_MASK;
    }

    
    uint64_t get_legal() const {
        return board.get_legal();
    }

    
    void move_board(const Flip* flip) {
        if ((board.invalid_mask >> flip->pos) & 1ULL) {
            std::cerr << "[Board1] Invalid move at position " << (int)flip->pos << std::endl;
            return;
        }
        board.move_board(flip);
    }

    
    void undo_board(const Flip* flip) {
        if ((board.invalid_mask >> flip->pos) & 1ULL) {
            std::cerr << "[Board1] Invalid undo at position " << (int)flip->pos << std::endl;
            return;
        }
        board.undo_board(flip);
    }

    
    void reset() {
        board.player = 0x0000000810000000ULL;
        board.opponent = 0x0000001008000000ULL;
        board.invalid_mask = INVALID_MASK;
    }

    
    void print() const { board.print(); }
    void pass() { board.pass(); }
    bool is_end() const { return board.is_end(); }
    std::string to_str() const { return board.to_str(); }
    std::string to_str(int p) const { return board.to_str(p); }
    bool from_str(const std::string& s) { return board.from_str(s); }

    void board_white_line_mirror() { board.board_white_line_mirror(); }
    void board_black_line_mirror() { board.board_black_line_mirror(); }
    void board_vertical_mirror()   { board.board_vertical_mirror(); }
    void board_horizontal_mirror() { board.board_horizontal_mirror(); }
    void board_rotate_90()         { board.board_rotate_90(); }
    void board_rotate_180()        { board.board_rotate_180(); }
    void board_rotate_270()        { board.board_rotate_270(); }

    Board get_white_line_mirror() const { return board.get_white_line_mirror(); }
    Board get_black_line_mirror() const { return board.get_black_line_mirror(); }
    Board get_vertical_mirror()   const { return board.get_vertical_mirror(); }
    Board get_horizontal_mirror() const { return board.get_horizontal_mirror(); }

    void translate_to_arr_player(uint_fast8_t res[]) const { board.translate_to_arr_player(res); }
    void translate_to_arr_player(int res[]) const { board.translate_to_arr_player(res); }
    void translate_to_arr(int res[], int p) const { board.translate_to_arr(res, p); }
    void translate_to_arr(uint_fast8_t res[], int p) const { board.translate_to_arr(res, p); }
    void translate_to_arr_player_rev(uint_fast8_t res[]) const { board.translate_to_arr_player_rev(res); }
    void translate_to_arr_player_rev(int res[]) const { board.translate_to_arr_player_rev(res); }
    void translate_from_arr(const int arr[], int player_idx) { board.translate_from_arr(arr, player_idx); }
    void translate_from_ull(uint64_t pl, uint64_t op) { board.translate_from_ull(pl, op); }

    int score_player() const { return board.score_player(); }
    int score_opponent() const { return board.score_opponent(); }
    int count_player() const { return board.count_player(); }
    int count_opponent() const { return board.count_opponent(); }
    int n_discs() const { return board.n_discs(); }

    bool check_player() { return board.check_player(); }
    bool check_pass() { return board.check_pass(); }

    void move_copy(const Flip* flip, Board* res) const { board.move_copy(flip, res); }
    Board move_copy(const Flip* flip) const { return board.move_copy(flip); }

    const Board& raw() const { return board; }
    Board& raw() { return board; }
};

// ===== FILE: Egaroucid/src/engine/board2.hpp =====

#pragma once
#include "board.hpp"



class Board2 {
private:
    Board board;

public:
    static constexpr uint64_t INVALID_MASK = 0x0042000000004200ULL;
    static constexpr uint64_t CORNER_MASK = 0x8100000000000081ULL;

    int get_corner_n_moves(uint64_t legal) const {
        return pop_count_ull(legal & CORNER_MASK);
    }

    
    Board2() : board() { board.invalid_mask = INVALID_MASK; }
    Board2(uint64_t player_, uint64_t opponent_) : board(player_, opponent_) {
        board.invalid_mask = INVALID_MASK;
    }
    Board2(const std::string& board_str) : board(board_str) {
        board.invalid_mask = INVALID_MASK;
    }

    
    uint64_t get_legal() const {
        return board.get_legal();
    }

    
    void move_board(const Flip* flip) {
        if ((board.invalid_mask >> flip->pos) & 1ULL) {
            std::cerr << "[Board2] Invalid move at position " << (int)flip->pos << std::endl;
            return;
        }
        board.move_board(flip);
    }

    
    void undo_board(const Flip* flip) {
        if ((board.invalid_mask >> flip->pos) & 1ULL) {
            std::cerr << "[Board2] Invalid undo at position " << (int)flip->pos << std::endl;
            return;
        }
        board.undo_board(flip);
    }

    
    void print() const {
        for (int i = HW2_M1; i >= 0; --i) {
            if ((board.invalid_mask >> i) & 1ULL) {
                std::cerr << "# ";
            } else if ((board.player >> i) & 1ULL) {
                std::cerr << "X ";
            } else if ((board.opponent >> i) & 1ULL) {
                std::cerr << "O ";
            } else {
                std::cerr << ". ";
            }
            if (i % HW == 0)
                std::cerr << std::endl;
        }
    }

    
    void reset() {
        board.player = 0x0000000810000000ULL;
        board.opponent = 0x0000001008000000ULL;
        board.invalid_mask = INVALID_MASK;
    }

    
    void pass() { board.pass(); }
    bool is_end() const { return board.is_end(); }
    std::string to_str() const { return board.to_str(); }
    std::string to_str(int p) const { return board.to_str(p); }
    bool from_str(const std::string& s) { return board.from_str(s); }

    void board_vertical_mirror() { board.board_vertical_mirror(); }
    void board_horizontal_mirror() { board.board_horizontal_mirror(); }
    void board_rotate_90() { board.board_rotate_90(); }
    void board_rotate_180() { board.board_rotate_180(); }
    void board_rotate_270() { board.board_rotate_270(); }

    int score_player() const { return board.score_player(); }
    int score_opponent() const { return board.score_opponent(); }
    int count_player() const { return board.count_player(); }
    int count_opponent() const { return board.count_opponent(); }
    int n_discs() const { return board.n_discs(); }

    bool check_player() { return board.check_player(); }
    bool check_pass() { return board.check_pass(); }

    Board move_copy(const Flip* flip) const { return board.move_copy(flip); }
    void move_copy(const Flip* flip, Board* res) const { board.move_copy(flip, res); }

    const Board& raw() const { return board; }
    Board& raw() { return board; }
};

// ===== FILE: Egaroucid/src/engine/board3.hpp =====

#pragma once
#include "board.hpp"



class Board3 {
private:
    Board board;

public:
    static constexpr uint64_t INVALID_MASK =
0xC3810000000081C3ULL;

    static constexpr uint64_t CORNER_MASK =
0x2400810000810024ULL;   

    int get_corner_n_moves(uint64_t legal) const {
        return pop_count_ull(legal & CORNER_MASK);
    }

    
    Board3() : board() { board.invalid_mask = INVALID_MASK; }
    Board3(uint64_t player_, uint64_t opponent_) : board(player_, opponent_) {
        board.invalid_mask = INVALID_MASK;
    }
    Board3(const std::string& board_str) : board(board_str) {
        board.invalid_mask = INVALID_MASK;
    }

    
    uint64_t get_legal() const {
        return board.get_legal(); 
    }

    
    void move_board(const Flip* flip) {
        if ((board.invalid_mask >> flip->pos) & 1ULL) {
            std::cerr << "[Board3] Invalid move at position " << (int)flip->pos << std::endl;
            return;
        }
        board.move_board(flip);
    }

    
    void undo_board(const Flip* flip) {
        if ((board.invalid_mask >> flip->pos) & 1ULL) {
            std::cerr << "[Board3] Invalid undo at position " << (int)flip->pos << std::endl;
            return;
        }
        board.undo_board(flip);
    }

    
    void print() const {
        for (int i = HW2_M1; i >= 0; --i) {
            if ((board.invalid_mask >> i) & 1ULL) {
                std::cerr << "# ";
            } else if ((board.player >> i) & 1ULL) {
                std::cerr << "X ";
            } else if ((board.opponent >> i) & 1ULL) {
                std::cerr << "O ";
            } else {
                std::cerr << ". ";
            }
            if (i % HW == 0)
                std::cerr << std::endl;
        }
    }

    
    void reset() {
        board.player = 0x0000000810000000ULL;
        board.opponent = 0x0000001008000000ULL;
        board.invalid_mask = INVALID_MASK;
    }

    
    void pass() { board.pass(); }
    bool is_end() const { return board.is_end(); }
    std::string to_str() const { return board.to_str(); }
    std::string to_str(int p) const { return board.to_str(p); }
    bool from_str(const std::string& s) { return board.from_str(s); }

    void board_vertical_mirror() { board.board_vertical_mirror(); }
    void board_horizontal_mirror() { board.board_horizontal_mirror(); }
    void board_rotate_90() { board.board_rotate_90(); }
    void board_rotate_180() { board.board_rotate_180(); }
    void board_rotate_270() { board.board_rotate_270(); }

    int score_player() const { return board.score_player(); }
    int score_opponent() const { return board.score_opponent(); }
    int count_player() const { return board.count_player(); }
    int count_opponent() const { return board.count_opponent(); }
    int n_discs() const { return board.n_discs(); }

    bool check_player() { return board.check_player(); }
    bool check_pass() { return board.check_pass(); }

    Board move_copy(const Flip* flip) const { return board.move_copy(flip); }
    void move_copy(const Flip* flip, Board* res) const { board.move_copy(flip, res); }

    const Board& raw() const { return board; }
    Board& raw() { return board; }
};

// ===== FILE: Egaroucid/src/engine/board_factory.hpp =====

#pragma once
#include <string>
#include "board.hpp"
#include "board1.hpp"
#include "board2.hpp"
#include "board3.hpp"

inline Board create_board_by_name(const std::string& name) {
    if (name == "board1" || name == "b1")
        return Board1().raw();  
    if (name == "board2" || name == "b2")
        return Board2().raw();
    if (name == "board3" || name == "b3")
        return Board3().raw();
    return Board();  
}

// ===== FILE: Egaroucid/src/engine/board.hpp =====

#pragma once
#include <memory>
#include <iostream>
#include <algorithm>
#include "common_select.hpp"
#include "mobility.hpp"
#include "flip.hpp"
#include "last_flip.hpp"
#include "hash.hpp"

#if USE_CRC32C_HASH
uint32_t global_hash_bit_mask = (1U << DEFAULT_HASH_LEVEL) - 1;
#endif

class Board {
public:
    uint64_t player;
    uint64_t opponent;
    uint64_t invalid_mask = 0ULL;

public:
    Board(uint64_t player_, uint64_t opponent_) : player(player_), opponent(opponent_), invalid_mask(0ULL) {}
    Board(std::string board_str) : invalid_mask(0ULL) { from_str(board_str); }
    Board() : invalid_mask(0ULL) {}
    virtual ~Board() = default;

    inline Board copy() const {
        Board res(player, opponent);
        res.invalid_mask = invalid_mask;
        return res;
    }

    inline void copy(Board *res) const {
        res->player = player;
        res->opponent = opponent;
        res->invalid_mask = invalid_mask;
    }

    virtual inline std::unique_ptr<Board> clone() const {
        return std::make_unique<Board>(*this);
    }

#if USE_CRC32C_HASH
    inline uint32_t hash() const {
        uint64_t res = _mm_crc32_u64(0, player);
        res = _mm_crc32_u64(res, opponent);
        return global_hash_bit_mask & res;
    }
#else
    inline uint32_t hash() const {
        const uint16_t *p = (const uint16_t*)&player;
        const uint16_t *o = (const uint16_t*)&opponent;
        uint32_t h1 = hash_rand_player[0][p[0]];
        uint32_t h2 = hash_rand_opponent[0][o[0]];
        h1 ^= hash_rand_player[1][p[1]];    h2 ^= hash_rand_opponent[1][o[1]];
        h1 ^= hash_rand_player[2][p[2]];    h2 ^= hash_rand_opponent[2][o[2]];
        h1 ^= hash_rand_player[3][p[3]];    h2 ^= hash_rand_opponent[3][o[3]];
        return h1 ^ h2;
    }
#endif

    inline void board_white_line_mirror() {
        player = white_line_mirror(player);
        opponent = white_line_mirror(opponent);
    }

    inline void board_black_line_mirror() {
        player = black_line_mirror(player);
        opponent = black_line_mirror(opponent);
    }

    inline void board_vertical_mirror() {
        player = vertical_mirror(player);
        opponent = vertical_mirror(opponent);
    }

    inline void board_horizontal_mirror() {
        player = horizontal_mirror(player);
        opponent = horizontal_mirror(opponent);
    }

    inline void board_rotate_90() {
        player = rotate_90(player);
        opponent = rotate_90(opponent);
    }

    inline void board_rotate_270() {
        player = rotate_270(player);
        opponent = rotate_270(opponent);
    }

    inline void board_rotate_180() {
        player = rotate_180(player);
        opponent = rotate_180(opponent);
    }

    inline Board get_white_line_mirror() const {
        return Board(white_line_mirror(player), white_line_mirror(opponent));
    }

    inline Board get_black_line_mirror() const {
        return Board(black_line_mirror(player), black_line_mirror(opponent));
    }

    inline Board get_vertical_mirror() const {
        return Board(vertical_mirror(player), vertical_mirror(opponent));
    }

    inline Board get_horizontal_mirror() const {
        return Board(horizontal_mirror(player), horizontal_mirror(opponent));
    }

    virtual inline void print() const {
        for (int i = HW2_M1; i >= 0; --i) {
            if ((invalid_mask >> i) & 1ULL)
                std::cerr << "# ";
            else if (1 & (player >> i))
                std::cerr << "X ";
            else if (1 & (opponent >> i))
                std::cerr << "O ";
            else
                std::cerr << ". ";
            if (i % HW == 0)
                std::cerr << std::endl;
        }
    }

    virtual inline uint64_t get_legal() const {
        return calc_legal(player, opponent) & ~invalid_mask;
    }

    virtual inline void move_board(const Flip *flip) {
        if (((invalid_mask >> flip->pos) & 1ULL) != 0ULL ||
    ((player >> flip->pos) & 1ULL) != 0ULL ||
    ((opponent >> flip->pos) & 1ULL) != 0ULL) {
    std::cerr << "[Board] attempt to move into occupied or invalid square " << (int)flip->pos << std::endl;
    return;
        }
        player ^= flip->flip;
        opponent ^= flip->flip;
        player ^= 1ULL << flip->pos;
        std::swap(player, opponent);
    }

    inline void move_copy(const Flip *flip, Board *res) const {
        if (((invalid_mask >> flip->pos) & 1ULL) != 0ULL ||
    ((player >> flip->pos) & 1ULL) != 0ULL ||
    ((opponent >> flip->pos) & 1ULL) != 0ULL) {
    std::cerr << "[Board] attempt to move_copy into occupied or invalid square " << (int)flip->pos << std::endl;
    return;
        }
        res->opponent = player ^ flip->flip;
        res->player = opponent ^ flip->flip;
        res->opponent ^= 1ULL << flip->pos;
        res->invalid_mask = invalid_mask;
    }

    inline Board move_copy(const Flip *flip) const {
        Board res;
        move_copy(flip, &res);
        return res;
    }

    inline void pass() {
        std::swap(player, opponent);
    }

    inline void undo_board(const Flip *flip) {
        std::swap(player, opponent);
        player ^= 1ULL << flip->pos;
        player ^= flip->flip;
        opponent ^= flip->flip;
    }

    inline void translate_to_arr_player(uint_fast8_t res[]) const {
        for (int i = 0; i < HW2; ++i)
            res[HW2_M1 - i] = 2 - (1 & (player >> i)) * 2 - (1 & (opponent >> i));
    }

    inline void translate_to_arr_player(int res[]) const {
        for (int i = 0; i < HW2; ++i)
            res[HW2_M1 - i] = 2 - (1 & (player >> i)) * 2 - (1 & (opponent >> i));
    }

    inline void translate_to_arr(int res[], int p) const {
        if (p == 0) {
            for (int i = 0; i < HW2; ++i)
                res[HW2_M1 - i] = 2 - (1 & (player >> i)) * 2 - (1 & (opponent >> i));
        } else {
            for (int i = 0; i < HW2; ++i)
                res[HW2_M1 - i] = 2 - (1 & (player >> i)) - (1 & (opponent >> i)) * 2;
        }
    }

    inline void translate_to_arr(uint_fast8_t res[], int p) const {
        if (p == 0) {
            for (int i = 0; i < HW2; ++i)
                res[HW2_M1 - i] = 2 - (1 & (player >> i)) * 2 - (1 & (opponent >> i));
        } else {
            for (int i = 0; i < HW2; ++i)
                res[HW2_M1 - i] = 2 - (1 & (player >> i)) - (1 & (opponent >> i)) * 2;
        }
    }

    inline void translate_to_arr_player_rev(uint_fast8_t res[]) const {
        for (int i = 0; i < HW2; ++i)
            res[i] = 2 - (1 & (player >> i)) * 2 - (1 & (opponent >> i));
    }

    inline void translate_to_arr_player_rev(int res[]) const {
        for (int i = 0; i < HW2; ++i)
            res[i] = 2 - (1 & (player >> i)) * 2 - (1 & (opponent >> i));
    }

    inline void translate_from_arr(const int arr[], int player_idx) {
        int i;
        player = 0;
        opponent = 0;
        if (player_idx == BLACK) {
            for (i = 0; i < HW2; ++i) {
                if (arr[HW2_M1 - i] == BLACK)
                    player |= 1ULL << i;
                else if (arr[HW2_M1 - i] == WHITE)
                    opponent |= 1ULL << i;
            }
        } else {
            for (i = 0; i < HW2; ++i) {
                if (arr[HW2_M1 - i] == BLACK)
                    opponent |= 1ULL << i;
                else if (arr[HW2_M1 - i] == WHITE)
                    player |= 1ULL << i;
            }
        }
    }

    inline void translate_from_ull(const uint64_t pl, const uint64_t op) {
        if (pl & op)
            std::cerr << "both on same square" << std::endl;
        player = pl;
        opponent = op;
    }

    inline int score_player() const {
        int e = pop_count_ull(~(player | opponent));
        int score = pop_count_ull(player) * 2 + e;
        score += (((score >> 6) & 1) + (((score + HW2_M1) >> 7) & 1) - 1) * e;
        return score - HW2;
    }

    inline int score_opponent() const {
        int e = pop_count_ull(~(player | opponent));
        int score = pop_count_ull(opponent) * 2 + e;
        score += (((score >> 6) & 1) + (((score + HW2_M1) >> 7) & 1) - 1) * e;
        return score - HW2;
    }

    inline int count_player() const {
        return pop_count_ull(player);
    }

    inline int count_opponent() const {
        return pop_count_ull(opponent);
    }

    inline int n_discs() const {
        return pop_count_ull(player | opponent);
    }

    inline int n_blocked_squares() const {
    return pop_count_ull(invalid_mask);
    }

    inline bool check_player() {
        bool passed = (get_legal() == 0);
        if (passed) {
            pass();
            passed = (get_legal() == 0);
            if (passed)
                pass();
        }
        return passed;
    }

    inline bool is_end() const {
        uint64_t legal_cur = get_legal();
        uint64_t legal_opp = calc_legal(opponent, player) & ~invalid_mask;
        return (legal_cur == 0ULL) && (legal_opp == 0ULL);
    }

    inline bool check_pass() {
        bool passed = (get_legal() == 0);
        if (passed) {
            pass();
            passed = (get_legal() == 0);
            if (passed) {
                return false;
            }
        }
        return true;
    }

    virtual inline void reset() {
        player = 0x0000000810000000ULL;
        opponent = 0x0000001008000000ULL;
        invalid_mask = 0ULL;
    }

    inline std::string to_str() const {
        std::string res;
        uint64_t cell_bit = 1ULL << (HW2 - 1);
        for (int i = 0; i < HW2; ++i) {
            if (player & cell_bit) {
                res += "X";
            } else if (opponent & cell_bit) {
                res += "O";
            } else {
                res += "-";
            }
            cell_bit >>= 1;
        }
        res += " X";
        return res;
    }

    inline std::string to_str(int player_to_move) const {
        std::string res;
        uint64_t cell_bit = 1ULL << (HW2 - 1);
        for (int i = 0; i < HW2; ++i) {
            if (player & cell_bit) {
                if (player_to_move == BLACK) res += "X"; else res += "O";
            } else if (opponent & cell_bit) {
                if (player_to_move == BLACK) res += "O"; else res += "X";
            } else {
                res += "-";
            }
            cell_bit >>= 1;
        }
        res += (player_to_move == BLACK) ? " X" : " O";
        return res;
    }

    inline bool from_str(std::string board_str) {
        board_str.erase(std::remove_if(board_str.begin(), board_str.end(), ::isspace), board_str.end());
        if (board_str.length() != HW2 + 1) {
            std::cerr << "[ERROR] invalid argument got length " << board_str.length() << " expected " << HW2 + 1 << std::endl;
            return false;
        }
        player = 0ULL;
        opponent = 0ULL;
        for (int i = 0; i < HW2; ++i) {
            if (is_black_like_char(board_str[i])) {
                player |= 1ULL << (HW2_M1 - i);
            } else if (is_white_like_char(board_str[i])) {
                opponent |= 1ULL << (HW2_M1 - i);
            }
        }
        if (is_white_like_char(board_str[HW2])) {
            std::swap(player, opponent);
        } else if (!is_black_like_char(board_str[HW2])) {
            std::cerr << "[ERROR] invalid player argument" << std::endl;
            return false;
        }
        return true;
    }
};

inline bool operator==(const Board& a, const Board& b) {
    return a.player == b.player && a.opponent == b.opponent && a.invalid_mask == b.invalid_mask;
}

inline bool operator!=(const Board& a, const Board& b) {
    return a.player != b.player || a.opponent != b.opponent || a.invalid_mask != b.invalid_mask;
}

inline uint64_t calc_flip(Flip *flip, Board *board, uint_fast8_t place) {
    if (((board->player | board->opponent | board->invalid_mask) >> place) & 1ULL) {
        flip->flip = 0ULL;
        flip->pos = place;
        return 0ULL;
    }
    return flip->calc_flip(board->player, board->opponent, place);
}

// ===== FILE: Egaroucid/src/engine/book_accuracy.hpp =====



#pragma once
#include <iostream>
#include <unordered_map>
#include "common_select.hpp"
#include "board.hpp"
#include "book.hpp"

constexpr int BOOK_ACCURACY_LEVEL_UNDEFINED = -127;
constexpr int N_BOOK_ACCURACY_LEVEL = 6;
constexpr int BOOK_ACCURACY_A_SHIFT = 5;

constexpr int BOOK_ACCURACY_LEVEL_AA = (0 - BOOK_ACCURACY_A_SHIFT);
constexpr int BOOK_ACCURACY_LEVEL_AB = (1 - BOOK_ACCURACY_A_SHIFT);
constexpr int BOOK_ACCURACY_LEVEL_AC = (2 - BOOK_ACCURACY_A_SHIFT);
constexpr int BOOK_ACCURACY_LEVEL_AD = (3 - BOOK_ACCURACY_A_SHIFT);
constexpr int BOOK_ACCURACY_LEVEL_AE = (4 - BOOK_ACCURACY_A_SHIFT);
constexpr int BOOK_ACCURACY_LEVEL_AF = (5 - BOOK_ACCURACY_A_SHIFT);

constexpr int BOOK_ACCURACY_LEVEL_A = 0; 
constexpr int BOOK_ACCURACY_LEVEL_B = 1; 
constexpr int BOOK_ACCURACY_LEVEL_C = 2; 
constexpr int BOOK_ACCURACY_LEVEL_D = 3; 
constexpr int BOOK_ACCURACY_LEVEL_E = 4; 
constexpr int BOOK_ACCURACY_LEVEL_F = 5; 

class Book_accuracy {
    private:
        std::mutex mtx;
        std::unordered_map<Board, int, Book_hash> book_accuracy[2]; 
    
    public:
        void calculate(Board *board) {
            if (book.contain(board)) {
                int accuracy = book_accuracy_search(board->copy(), false);
                if (accuracy == BOOK_ACCURACY_LEVEL_A) {
                    book_accuracy_search(board->copy(), true);
                }
            }
        }

        void delete_all() {
            std::lock_guard<std::mutex> lock(mtx);
            for (int i = 0; i < 2; ++i) {
                book_accuracy[i].clear();
            }
        }

        int get(Board *board) {
            int res = get_raw(board, false);
            if (res == BOOK_ACCURACY_LEVEL_A) {
                int res2 = get_raw(board, true);
                if (res2 != BOOK_ACCURACY_LEVEL_UNDEFINED) {
                    res = res2 - BOOK_ACCURACY_A_SHIFT;
                } else{
                    res = BOOK_ACCURACY_LEVEL_UNDEFINED;
                }
            }
            return res;
        }

    private:
        int book_accuracy_search(Board board, bool is_high_level) {
            if (!global_searching) {
                return BOOK_ACCURACY_LEVEL_UNDEFINED;
            }
            int res = get_raw(&board, is_high_level);
            if (res != BOOK_ACCURACY_LEVEL_UNDEFINED) {
                return res;
            }
            if (board.get_legal() == 0ULL) {
                board.pass();
            }
            Book_elem book_elem = book.get(board);
            std::vector<Book_value> links = book.get_all_moves_with_value(&board);
            if (links.size() == 0) {
                int complete_depth = 60, endgame_depth = 60;
                if (book_elem.level < N_LEVEL) {
                    complete_depth = get_level_complete_depth(book_elem.level);
                    endgame_depth = get_level_endsearch_depth(book_elem.level);
                }
                int res = BOOK_ACCURACY_LEVEL_F;
                if (complete_depth >= HW2 - board.n_discs()) {
                    res = BOOK_ACCURACY_LEVEL_A;
                } else if (endgame_depth >= HW2 - board.n_discs()) {
                    res = BOOK_ACCURACY_LEVEL_C;
                }
                reg(board, res, is_high_level);
                return res;
            }
            int best_score = -INF;
            for (Book_value &link: links) {
                best_score = std::max(best_score, link.value);
            }
            bool is_end = true;
            uint32_t identifier = 0;
            Flip flip;
            int accept_loss = 1;
            if (is_high_level) {
                accept_loss = 2;
            }
            for (Book_value &link: links) {
                if (link.value >= best_score - accept_loss) {
                    calc_flip(&flip, &board, link.policy);
                    board.move_board(&flip);
                        int child_book_acc = book_accuracy_search(board, is_high_level);
                    board.undo_board(&flip);
                    if (child_book_acc == BOOK_ACCURACY_LEVEL_UNDEFINED) {
                        return BOOK_ACCURACY_LEVEL_UNDEFINED;
                    }
                    for (int i = 0; i < N_BOOK_ACCURACY_LEVEL; ++i) {
                        identifier |= (child_book_acc == i) << i;
                    }
                }
            }
            if (book_elem.leaf.value >= best_score - accept_loss) {
                int complete_depth = 60, endgame_depth = 60;
                if (book_elem.leaf.level < N_LEVEL) {
                    complete_depth = get_level_complete_depth(book_elem.leaf.level);
                    endgame_depth = get_level_endsearch_depth(book_elem.leaf.level);
                }
                if (HW2 - (board.n_discs() + 1) <= complete_depth) {
                    identifier |= 1 << BOOK_ACCURACY_LEVEL_A;
                } else if (HW2 - (board.n_discs() + 1) <= endgame_depth) {
                    identifier |= 1 << BOOK_ACCURACY_LEVEL_C;
                }
            }
            
            
            
            
            
            
            
            
            
            
            
            
            res = BOOK_ACCURACY_LEVEL_F;
            if (identifier & (1 << BOOK_ACCURACY_LEVEL_A)) { 
                if ((identifier & ~((1 << BOOK_ACCURACY_LEVEL_B) - 1)) == 0) { 
                    res = BOOK_ACCURACY_LEVEL_A;
                } else if ((identifier & ~((1 << BOOK_ACCURACY_LEVEL_D) - 1)) == 0) { 
                    res = BOOK_ACCURACY_LEVEL_B;
                } else { 
                    res = BOOK_ACCURACY_LEVEL_D;
                }
            } else if (identifier & (1 << BOOK_ACCURACY_LEVEL_B)) { 
                if ((identifier & ~((1 << BOOK_ACCURACY_LEVEL_D) - 1)) == 0) { 
                    res = BOOK_ACCURACY_LEVEL_B;
                } else { 
                    res = BOOK_ACCURACY_LEVEL_D;
                }
            } else if (identifier & (1 << BOOK_ACCURACY_LEVEL_C)) { 
                if ((identifier & ~((1 << BOOK_ACCURACY_LEVEL_D) - 1)) == 0) { 
                    res = BOOK_ACCURACY_LEVEL_C;
                } else { 
                    res = BOOK_ACCURACY_LEVEL_D;
                }
            } else { 
                uint32_t lsb = (identifier >> 3); 
                lsb = pop_count_uint(~lsb & (lsb - 1)); 
                res = BOOK_ACCURACY_LEVEL_D + lsb; 
            }
            reg(board, res, is_high_level);
            return res;
        }

        inline void reg(Board b, int val, bool is_high_level) {
            Board unique_board = get_representative_board(b);
            std::lock_guard<std::mutex> lock(mtx);
            book_accuracy[is_high_level][unique_board] = val;
        }

        inline int get_representive(Board b, bool is_high_level) {
            int res = BOOK_ACCURACY_LEVEL_UNDEFINED;
            if (book_accuracy[is_high_level].find(b) != book_accuracy[is_high_level].end())
                res = book_accuracy[is_high_level][b];
            return res;
        }

        inline bool contain(Board b, bool is_high_level) {
            Board unique_board = get_representative_board(b);
            return book_accuracy[is_high_level].find(unique_board) != book_accuracy[is_high_level].end();
        }

        inline void first_update_representative_board(Board *res, Board *sym) {
            uint64_t vp = vertical_mirror(sym->player);
            uint64_t vo = vertical_mirror(sym->opponent);
            if (res->player > vp || (res->player == vp && res->opponent > vo)) {
                res->player = vp;
                res->opponent = vo;
            }
        }

        inline void update_representative_board(Board *res, Board *sym) {
            if (res->player > sym->player || (res->player == sym->player && res->opponent > sym->opponent))
                sym->copy(res);
            uint64_t vp = vertical_mirror(sym->player);
            uint64_t vo = vertical_mirror(sym->opponent);
            if (res->player > vp || (res->player == vp && res->opponent > vo)) {
                res->player = vp;
                res->opponent = vo;
            }
        }

        inline Board get_representative_board(Board b) {
            Board res = b;
            first_update_representative_board(&res, &b);
            b.board_black_line_mirror();
            update_representative_board(&res, &b);
            b.board_horizontal_mirror();
            update_representative_board(&res, &b);
            b.board_white_line_mirror();
            update_representative_board(&res, &b);
            return res;
        }

        int get_raw(Board *board, bool is_high_level) {
            std::lock_guard<std::mutex> lock(mtx);
            Board unique_board = get_representative_board(board->copy());
            return get_representive(unique_board, is_high_level);
        }
};

Book_accuracy book_accuracy;

int calculate_book_accuracy(Board *b) {
    int res = book_accuracy.get(b);
    if (res == BOOK_ACCURACY_LEVEL_UNDEFINED) {
        book_accuracy.calculate(b);
        res = book_accuracy.get(b);
    }
    return res;
}

// ===== FILE: Egaroucid/src/engine/book_enlarge.hpp =====



#pragma once
#include <iostream>
#include <unordered_set>
#include "evaluate.hpp"
#include "board.hpp"
#include "ai.hpp"


constexpr uint64_t AUTO_BOOK_SAVE_TIME = 3600000ULL; 

constexpr int BOOK_DEVIATE_MAX_N_LOOPS_INF = 100000000;

Search_result ai(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log);

struct Book_deviate_todo_elem {
    Board board;
    int player;
    int max_error_per_move;
    int remaining_error;
    int max_leaf_error;

    void move(Flip *flip, int error) {
        board.move_board(flip);
        player ^= 1;
        if (error > 0)
            remaining_error -= error;
    }

    void undo(Flip *flip, int error) {
        board.undo_board(flip);
        player ^= 1;
        if (error > 0)
            remaining_error += error;
    }

    void pass() {
        board.pass();
        player ^= 1;
    }
};

bool operator==(const Book_deviate_todo_elem& a, const Book_deviate_todo_elem& b) {
    return a.board == b.board;
}

struct Book_deviate_hash {
    size_t operator()(Book_deviate_todo_elem elem) const{
        const uint16_t *p = (uint16_t*)&elem.board.player;
        const uint16_t *o = (uint16_t*)&elem.board.opponent;
        return 
            hash_rand_player_book[0][p[0]] ^ 
            hash_rand_player_book[1][p[1]] ^ 
            hash_rand_player_book[2][p[2]] ^ 
            hash_rand_player_book[3][p[3]] ^ 
            hash_rand_opponent_book[0][o[0]] ^ 
            hash_rand_opponent_book[1][o[1]] ^ 
            hash_rand_opponent_book[2][o[2]] ^ 
            hash_rand_opponent_book[3][o[3]];
    }
};



void get_book_recalculate_leaf_todo(Book_deviate_todo_elem todo_elem, int book_depth, int level, std::unordered_set<Book_deviate_todo_elem, Book_deviate_hash> &todo_list, uint64_t all_strt, bool *book_learning, Board *board_copy, int *player, bool only_illegal) {
    if (!global_searching || !(*book_learning)) {
        return;
    }
    
    if (todo_elem.board.get_legal() == 0) {
        todo_elem.pass();
        if (todo_elem.board.get_legal() == 0) {
            return; 
        }
    }
    
    if (todo_elem.board.n_discs() > book_depth + 4) {
        return;
    }
    todo_elem.board = representative_board(todo_elem.board);
    
    if (todo_list.find(todo_elem) != todo_list.end()) {
        return;
    }
    Book_elem book_elem = book.get(todo_elem.board);
    
    if (book_elem.value == SCORE_UNDEFINED) {
        return;
    }
    
    if (book_elem.seen) {
        return;
    }
    book.flag_book_elem(todo_elem.board);
    *board_copy = todo_elem.board;
    *player = todo_elem.player;
    
    std::vector<Book_value> links = book.get_all_moves_with_value(&todo_elem.board);
    uint64_t remaining_legal = todo_elem.board.get_legal();
    for (Book_value &link: links) {
        remaining_legal &= ~(1ULL << link.policy);
    }
    bool illegal_leaf = false;
    if (remaining_legal) {
        if (is_valid_policy(book_elem.leaf.move)) {
            if ((remaining_legal & (1ULL << book_elem.leaf.move)) == 0) {
                illegal_leaf = true;
            }
        } else {
            illegal_leaf = true;
        }
    } else if (book_elem.leaf.move != MOVE_NOMOVE) {
        illegal_leaf = true;
    }
    
    if (illegal_leaf || (!only_illegal && book_elem.leaf.level < level)) {
        todo_list.emplace(todo_elem);
        if (todo_list.size() % 100 == 0) {
            std::cerr << "book recalculate leaf todo " << todo_list.size() << " calculating... time " << ms_to_time_short(tim() - all_strt) << std::endl;
        }
    }
    
    Flip flip;
    for (Book_value &link: links) {
        calc_flip(&flip, &todo_elem.board, link.policy);
        int link_value = link.value;
        todo_elem.board.move_board(&flip);
            Book_elem link_elem = book.get(todo_elem.board);
            if (link_elem.value != SCORE_UNDEFINED && link_value < -link_elem.value) {
                link_value = link_elem.value;
            }
        todo_elem.board.undo_board(&flip);
        int link_error = book_elem.value - link_value;
        if (link_error <= todo_elem.max_error_per_move && link_error <= todo_elem.remaining_error) {
            todo_elem.move(&flip, link_error);
                get_book_recalculate_leaf_todo(todo_elem, book_depth, level, todo_list, all_strt, book_learning, board_copy, player, only_illegal);
            todo_elem.undo(&flip, link_error);
        }
    }
}

void book_search_leaf(Board board, int level, bool use_multi_thread) {
    book.search_leaf(board, level, use_multi_thread);
}

void book_recalculate_leaves(int level, std::unordered_set<Book_deviate_todo_elem, Book_deviate_hash> &todo_list, uint64_t all_strt, uint64_t strt, bool *book_learning, Board *board_copy, int *player) {
    int n_all = todo_list.size();
    if (n_all == 0) {
        return;
    }
    int n_done = 0, n_doing = 0;
    std::vector<std::future<void>> tasks;
    for (Book_deviate_todo_elem elem: todo_list) {
        if (!global_searching || !(*book_learning)) {
            break;
        }
        *board_copy = elem.board;
        *player = elem.player;
        bool use_multi_thread = (n_all - n_doing) < thread_pool.size() * 2;
        bool pushed;
        ++n_doing;
        if (use_multi_thread) {
            book_search_leaf(elem.board, level, true);
            ++n_done;
            if (n_done % 10 == 0) {
                int percent = 100ULL * n_done / n_all;
                uint64_t eta = (tim() - strt) * ((double)n_all / n_done - 1.0);
                std::cerr << "book recalculating leaves " << percent << "% " <<  n_done << "/" << n_all << " time " << ms_to_time_short(tim() - all_strt) << " ETA " << ms_to_time_short(eta) << std::endl;
            }
        } else{
            tasks.emplace_back(thread_pool.push(&pushed, std::bind(&book_search_leaf, elem.board, level, use_multi_thread)));
            if (!pushed) {
                tasks.pop_back();
                book_search_leaf(elem.board, level, true);
                ++n_done;
                if (n_done % 10 == 0) {
                    int percent = 100ULL * n_done / n_all;
                    uint64_t eta = (tim() - strt) * ((double)n_all / n_done - 1.0);
                    std::cerr << "book recalculating leaves " << percent << "% " <<  n_done << "/" << n_all << " time " << ms_to_time_short(tim() - all_strt) << " ETA " << ms_to_time_short(eta) << std::endl;
                }
            }
        }
        int tasks_size = tasks.size();
        for (int i = 0; i < tasks_size; ++i) {
            if (tasks[i].valid()) {
                if (tasks[i].wait_for(std::chrono::seconds(0)) == std::future_status::ready) {
                    tasks[i].get();
                    ++n_done;
                    if (n_done % 10 == 0) {
                        int percent = 100ULL * n_done / n_all;
                        uint64_t eta = (tim() - strt) * ((double)n_all / n_done - 1.0);
                        std::cerr << "book recalculating leaves " << percent << "% " <<  n_done << "/" << n_all << " time " << ms_to_time_short(tim() - all_strt) << " ETA " << ms_to_time_short(eta) << std::endl;
                    }
                }
            }
        }
        for (int i = 0; i < tasks_size; ++i) {
            if (i >= tasks.size()) {
                break;
            }
            if (!tasks[i].valid()) {
                tasks.erase(tasks.begin() + i);
                --i;
            }
        }
    }
    int tasks_size = tasks.size();
    for (int i = 0; i < tasks_size; ++i) {
        if (tasks[i].valid()) {
            tasks[i].get();
            ++n_done;
            if (n_done % 10 == 0) {
                int percent = 100ULL * n_done / n_all;
                uint64_t eta = (tim() - strt) * ((double)n_all / n_done - 1.0);
                std::cerr << "book recalculating leaves " << percent << "% " <<  n_done << "/" << n_all << " time " << ms_to_time_short(tim() - all_strt) << " ETA " << ms_to_time_short(eta) << std::endl;
            }
        }
    }
    int percent = 100ULL * n_done / n_all;
    uint64_t eta = (tim() - strt) * ((double)n_all / n_done - 1.0);
    std::cerr << "book recalculating leaves finished " << percent << "% " <<  n_done << "/" << n_all << " time " << ms_to_time_short(tim() - all_strt) << " ETA " << ms_to_time_short(eta) << std::endl;
}

inline void book_recalculate_leaf(Board root_board, int level, int book_depth, int max_error_per_move, int max_error_sum, Board *board_copy, int *player, bool *book_learning, bool only_illegal, uint64_t all_strt) {
    uint64_t strt_tim = tim();
    int before_player = *player;
    Book_deviate_todo_elem root_elem;
    root_elem.board = root_board;
    root_elem.player = *player;
    root_elem.max_error_per_move = max_error_per_move;
    root_elem.remaining_error = max_error_sum;
    int n_saved = 1;
    Book_elem book_elem = book.get(root_board);
    if (book_elem.value == SCORE_UNDEFINED) {
        std::cerr << "board not registered, searching..." << std::endl;
        book_elem.value = ai(root_board, level, true, 0, true, false).value;
    }

    bool stop = false;
    book.reset_seen();
    std::unordered_set<Book_deviate_todo_elem, Book_deviate_hash> book_recalculate_leaf_todo;
    get_book_recalculate_leaf_todo(root_elem, book_depth, level, book_recalculate_leaf_todo, all_strt, book_learning, board_copy, player, only_illegal);
    std::cerr << "book recalculate leaf todo " << book_recalculate_leaf_todo.size() << " calculated time " << ms_to_time_short(tim() - all_strt) << std::endl;
    if (book_recalculate_leaf_todo.size()) {
        uint64_t strt = tim();
        book_recalculate_leaves(level, book_recalculate_leaf_todo, all_strt, strt, book_learning, board_copy, player);
    }
    book.reset_seen();
    root_board.copy(board_copy);
    *player = before_player;
    std::cerr << "recalculate leaf finished " << book_recalculate_leaf_todo.size() << " boards time " << ms_to_time_short(tim() - all_strt) << std::endl;
    *book_learning = false;
}




void get_book_deviate_todo(Book_deviate_todo_elem todo_elem, int best_move_only_player, int book_depth, std::unordered_set<Book_deviate_todo_elem, Book_deviate_hash> &book_deviate_todo, uint64_t all_strt, bool *book_learning, Board *board_copy, int *player, int n_loop) {
    if (!global_searching || !(*book_learning)) {
        return;
    }
    
    if (todo_elem.board.get_legal() == 0) {
        todo_elem.pass();
        if (todo_elem.board.get_legal() == 0) {
            return; 
        }
    }
    
    if (todo_elem.board.n_discs() >= book_depth + 4) {
        return;
    }
    
    if (book_deviate_todo.find(todo_elem) != book_deviate_todo.end()) {
        return;
    }
    todo_elem.board = representative_board(todo_elem.board);
    *board_copy = todo_elem.board;
    *player = todo_elem.player;
    Book_elem book_elem = book.get(todo_elem.board);
    
    if (book_elem.value == SCORE_UNDEFINED) {
        return;
    }
    
    if (book_elem.seen) {
        return;
    }
    book.flag_book_elem(todo_elem.board);
    if (todo_elem.player == best_move_only_player) {
        std::vector<Book_value> links = book.get_all_moves_with_value(&todo_elem.board);
        int best_score = -SCORE_MAX;
        for (Book_value &link: links) {
            best_score = std::max(best_score, link.value);
        }
        if (-SCORE_MAX <= book_elem.leaf.value && book_elem.leaf.value <= SCORE_MAX && is_valid_policy(book_elem.leaf.move)) {
            best_score = std::max(best_score, (int)book_elem.leaf.value);
        }
        
        if (book_elem.leaf.value >= best_score) {
            int leaf_error = book_elem.value - book_elem.leaf.value;
            if (leaf_error <= todo_elem.max_leaf_error && is_valid_policy(book_elem.leaf.move)) {
                if (todo_elem.board.get_legal() & (1ULL << book_elem.leaf.move)) { 
                    bool leaf_in_link = false;
                    for (Book_value &link: links) {
                        leaf_in_link |= link.policy == book_elem.leaf.move;
                    }
                    if (!leaf_in_link) {
                        book_deviate_todo.emplace(todo_elem);
                        if (book_deviate_todo.size() % 100 == 0) {
                            std::cerr << "loop " << n_loop << " book deviate todo " << book_deviate_todo.size() << " calculating... time " << ms_to_time_short(tim() - all_strt) << std::endl;
                        }
                    }
                }
            }
        }
        
        if (todo_elem.board.n_discs() + 1 < book_depth + 4) {
            Flip flip;
            for (Book_value &link: links) {
                if (link.value == best_score) {
                    int link_error = book_elem.value - link.value;
                    if (link_error <= todo_elem.max_error_per_move && link_error <= todo_elem.remaining_error) {
                        calc_flip(&flip, &todo_elem.board, link.policy);
                        todo_elem.move(&flip, link_error);
                            get_book_deviate_todo(todo_elem, best_move_only_player, book_depth, book_deviate_todo, all_strt, book_learning, board_copy, player, n_loop);
                        todo_elem.undo(&flip, link_error);
                    }
                }
            }
        }
    } else{
        
        std::vector<Book_value> links = book.get_all_moves_with_value(&todo_elem.board);
        int leaf_error = book_elem.value - book_elem.leaf.value;
        if (leaf_error <= todo_elem.max_leaf_error && is_valid_policy(book_elem.leaf.move)) {
            if (todo_elem.board.get_legal() & (1ULL << book_elem.leaf.move)) { 
                bool leaf_in_link = false;
                for (Book_value &link: links) {
                    leaf_in_link |= link.policy == book_elem.leaf.move;
                }
                if (!leaf_in_link) {
                    book_deviate_todo.emplace(todo_elem);
                    if (book_deviate_todo.size() % 100 == 0) {
                        std::cerr << "loop " << n_loop << " book deviate todo " << book_deviate_todo.size() << " calculating... time " << ms_to_time_short(tim() - all_strt) << std::endl;
                    }
                }
            }
        }
        
        if (todo_elem.board.n_discs() + 1 < book_depth + 4) {
            Flip flip;
            for (Book_value &link: links) {
                int link_error = book_elem.value - link.value;
                if (link_error <= todo_elem.max_error_per_move && link_error <= todo_elem.remaining_error) {
                    calc_flip(&flip, &todo_elem.board, link.policy);
                    todo_elem.move(&flip, link_error);
                        get_book_deviate_todo(todo_elem, best_move_only_player, book_depth, book_deviate_todo, all_strt, book_learning, board_copy, player, n_loop);
                    todo_elem.undo(&flip, link_error);
                }
            }
        }
    }
}

uint64_t expand_leaf(Book_deviate_todo_elem todo_elem, int book_depth, int level, bool use_multi_thread, bool *book_learning) {
    Book_elem book_elem = book.get(todo_elem.board);
    Flip flip;
    calc_flip(&flip, &todo_elem.board, book_elem.leaf.move);
    todo_elem.move(&flip, 0);
    if (todo_elem.board.get_legal() == 0) { 
        todo_elem.board.pass();
        if (todo_elem.board.get_legal() == 0) {
            todo_elem.board.pass();
            book.change(todo_elem.board, todo_elem.board.score_player(), 60);
            return 1;
        }
    }
    uint64_t n_add = 0;
    int prev_value = book_elem.value;
    while (todo_elem.board.n_discs() <= book_depth + 4 && !book.contain(&todo_elem.board) && (*book_learning) && todo_elem.remaining_error >= 0) {
        Search_result search_result = ai(todo_elem.board, level, true, 0, use_multi_thread, false);
        if (-HW2 <= search_result.value && search_result.value <= HW2) {
            book.change(todo_elem.board, search_result.value, level);
            ++n_add;
            if (is_valid_policy(search_result.policy) && (todo_elem.board.get_legal() & (1ULL << search_result.policy))) {
                int error = 0;
                if (prev_value != SCORE_UNDEFINED) {
                    error = -prev_value - search_result.value;
                }
                prev_value = search_result.value;
                if (
                    todo_elem.board.n_discs() < book_depth + 4 && 
                    error <= todo_elem.max_error_per_move && 
                    error <= todo_elem.remaining_error
                ) {
                    calc_flip(&flip, &todo_elem.board, search_result.policy);
                    todo_elem.board.move_board(&flip);
                    if (todo_elem.board.get_legal() == 0) { 
                        todo_elem.board.pass();
                        prev_value *= -1;
                        if (todo_elem.board.get_legal() == 0) { 
                            todo_elem.board.pass();
                            book.change(todo_elem.board, todo_elem.board.score_player(), 60);
                            ++n_add;
                            break;
                        }
                    }
                } else{
                    book.add_leaf(&todo_elem.board, search_result.value, search_result.policy, level);
                    break;
                }
            } else
                break;
        }
    }
    return n_add;
}

uint64_t expand_leaves(int book_depth, int level, int max_error_per_move, std::unordered_set<Book_deviate_todo_elem, Book_deviate_hash> &book_deviate_todo, uint64_t all_strt, uint64_t strt, bool *book_learning, Board *board_copy, int *player, int n_loop, std::string file, std::string bak_file) {
    int n_all = book_deviate_todo.size();
    if (n_all == 0) {
        return 0;
    }
    int n_done = 0;
    int n_doing = 0;
    std::vector<std::future<uint64_t>> tasks;
    uint64_t s = tim();
    uint64_t n_add = 0;
    for (Book_deviate_todo_elem elem: book_deviate_todo) {
        if (tim() - s >= AUTO_BOOK_SAVE_TIME) {
            book.save_egbk3(file, bak_file);
            s = tim();
        }
        if (!global_searching || !(*book_learning)) {
            break;
        }
        *board_copy = elem.board;
        *player = elem.player;
        bool use_multi_thread = (n_all - n_doing) < thread_pool.size() * 2;
        bool pushed;
        ++n_doing;
        if (use_multi_thread) { 
            n_add += expand_leaf(elem, book_depth, level, true, book_learning);
            ++n_done;
            int percent = 100ULL * n_done / n_all;
            uint64_t eta = (tim() - strt) * ((double)n_all / n_done - 1.0);
            std::string time_short = ms_to_time_short(tim() - all_strt);
            std::string eta_short = ms_to_time_short(eta);
            std::cerr << "loop " << n_loop << " book deviating " << percent << "% " <<  n_done << "/" << n_all << " registered " << n_add << " time " << time_short << " ETA " << eta_short << std::endl;
        } else{ 
            tasks.emplace_back(thread_pool.push(&pushed, std::bind(&expand_leaf, elem, book_depth, level, false, book_learning)));
            if (!pushed) {
                tasks.pop_back();
                n_add += expand_leaf(elem, book_depth, level, true, book_learning);
                ++n_done;
                int percent = 100ULL * n_done / n_all;
                uint64_t eta = (tim() - strt) * ((double)n_all / n_done - 1.0);
                std::string time_short = ms_to_time_short(tim() - all_strt);
                std::string eta_short = ms_to_time_short(eta);
                std::cerr << "loop " << n_loop << " book deviating " << percent << "% " <<  n_done << "/" << n_all << " registered " << n_add << " time " << time_short << " ETA " << eta_short << std::endl;
            }
        }
        int tasks_size = tasks.size();
        for (int i = 0; i < tasks_size; ++i) {
            if (tasks[i].valid()) {
                if (tasks[i].wait_for(std::chrono::seconds(0)) == std::future_status::ready) {
                    n_add += tasks[i].get();
                    ++n_done;
                    int percent = 100ULL * n_done / n_all;
                    uint64_t eta = (tim() - strt) * ((double)n_all / n_done - 1.0);
                    std::string time_short = ms_to_time_short(tim() - all_strt);
                    std::string eta_short = ms_to_time_short(eta);
                    std::cerr << "loop " << n_loop << " book deviating " << percent << "% " <<  n_done << "/" << n_all << " registered " << n_add << " time " << time_short << " ETA " << eta_short << std::endl;
                }
            }
        }
        for (int i = 0; i < tasks_size; ++i) {
            if (i >= tasks.size()) {
                break;
            }
            if (!tasks[i].valid()) {
                tasks.erase(tasks.begin() + i);
                --i;
            }
        }
    }
    int tasks_size = tasks.size();
    for (int i = 0; i < tasks_size; ++i) {
        if (tasks[i].valid()) {
            n_add += tasks[i].get();
            ++n_done;
            int percent = 100ULL * n_done / n_all;
            uint64_t eta = (tim() - strt) * ((double)n_all / n_done - 1.0);
            std::string time_short = ms_to_time_short(tim() - all_strt);
            std::string eta_short = ms_to_time_short(eta);
            std::cerr << "loop " << n_loop << " book deviating " << percent << "% " <<  n_done << "/" << n_all << " registered " << n_add << " time " << time_short << " ETA " << eta_short << std::endl;
        }
    }
    return n_add;
}


inline void book_deviate(Board root_board, int level, int book_depth, int max_error_per_move, int max_error_sum, int max_leaf_error, int max_n_loops, Board *board_copy, int *player, std::string book_file, std::string book_bak, bool *book_learning) {
    uint64_t all_strt = tim();
    uint64_t s = all_strt;
    std::cerr << "book deviate started" << std::endl;
    int before_player = *player;
    Book_deviate_todo_elem root_elem;
    root_elem.board = root_board;
    root_elem.player = *player;
    root_elem.max_error_per_move = max_error_per_move;
    root_elem.remaining_error = max_error_sum;
    root_elem.max_leaf_error = max_leaf_error;
    int n_loop = 0;
    uint64_t n_registered = 0;
    while (n_loop < max_n_loops) {
        ++n_loop;
        if (tim() - s > AUTO_BOOK_SAVE_TIME && *book_learning) {
            book.save_egbk3(book_file, book_bak);
            s = tim();
        }
        Book_elem book_elem = book.get(root_board);
        if (book_elem.value == SCORE_UNDEFINED) {
            std::cerr << "board not registered, searching..." << std::endl;
            book_elem.value = ai(root_board, level, true, 0, true, false).value;
            book.change(&root_board, book_elem.value, level);
        }
        bool book_recalculating = true;
        book_recalculate_leaf(root_board, std::min(20 + (level & 1), std::max(1, level - 2)), std::max(1, book_depth - 1), max_error_per_move, max_error_sum, board_copy, player, &book_recalculating, true, all_strt);
        std::unordered_set<Book_deviate_todo_elem, Book_deviate_hash> book_deviate_todo;
        book.reset_seen();
        get_book_deviate_todo(root_elem, BLACK, book_depth, book_deviate_todo, all_strt, book_learning, board_copy, player, n_loop);
        book.reset_seen();
        get_book_deviate_todo(root_elem, WHITE, book_depth, book_deviate_todo, all_strt, book_learning, board_copy, player, n_loop);
        book.reset_seen();
        std::cerr << "loop " << n_loop << " book deviate todo " << book_deviate_todo.size() << " calculated time " << ms_to_time_short(tim() - all_strt) << std::endl;
        uint64_t strt = tim();
        uint64_t n_add = expand_leaves(book_depth, level, max_error_per_move, book_deviate_todo, all_strt, strt, book_learning, board_copy, player, n_loop, book_file, book_bak);
        if (n_add == 0) {
            break;
        }
        n_registered += n_add;
        std::cerr << "loop " << n_loop << " book deviated registered " << n_registered << " board size " << book.size() << std::endl;
    }
    *player = before_player;
    root_board.copy(board_copy);
    
    
    std::cerr << "book deviate finished registered " << n_registered << " time " << ms_to_time_short(tim() - all_strt) << std::endl;
    *book_learning = false;
}


inline void book_store(std::vector<std::pair<Board, int>> tasks, int level, int book_depth, Board *board_copy, int *player, std::string book_file, std::string book_bak, bool *book_learning) {
    uint64_t all_strt = tim();
    uint64_t s = all_strt;
    Board before_board = board_copy->copy();
    int before_player = *player;
    std::cerr << "book store started" << std::endl;
    Flip flip;
    *player = BLACK;
    int n_registered = 0;
    for (std::pair<Board, int> task: tasks) {
        if (!(*book_learning)) {
            break;
        }
        Board board = task.first;
        if (board.n_discs() > 4 + book_depth) {
            continue;
        }
        board.copy(board_copy);
        *player = task.second;
        Search_result search_result = ai_searching(board, level, true, 0, true, false, book_learning);
        if (is_valid_policy(search_result.policy) && (board.get_legal() & (1ULL << search_result.policy)) && is_valid_score(search_result.value)) {
            std::cerr << idx_to_coord(search_result.policy) << " " << search_result.value << std::endl;
            board.print();
            std::cerr << std::endl;
            book.change(board, search_result.value, level);
            calc_flip(&flip, &board, search_result.policy);
            board.move_board(&flip);
                bool passed = board.get_legal() == 0;
                if (passed) {
                    board.pass();
                }
                Search_result child_search_result = ai_searching(board, level, true, 0, true, false, book_learning);
                std::cerr << "child " << child_search_result.value << std::endl;
                board.print();
                std::cerr << std::endl;
                book.change(board, child_search_result.value, level);
                if (passed) {
                    board.pass();
                }
            board.undo_board(&flip);
            n_registered += 2;
        }
    }
    *player = before_player;
    before_board.copy(board_copy);
    
    
    std::cerr << "book store finished registered " << n_registered << " time " << ms_to_time_short(tim() - all_strt) << std::endl;
    *book_learning = false;
}

// ===== FILE: Egaroucid/src/engine/book.hpp =====

ï»¿

#pragma once
#include <iostream>
#include <fstream>
#include <unordered_map>
#include <unordered_set>
#include "evaluate.hpp"
#include "board.hpp"
#include "search.hpp"
#include "ai.hpp"

inline Search_result tree_search(Board board, int depth, uint_fast8_t mpc_level, bool show_log, bool use_multi_thread);
Search_result ai(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log);
Search_result ai_legal(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log, uint64_t use_legal);
void search_new_leaf(Board board, int level, int book_elem_value, bool use_multi_thread);

#define FORCE_BOOK_DEPTH false

constexpr int BOOK_N_ACCEPT_LEVEL = 11;
constexpr int BOOK_ACCURACY_LEVEL_INF = 10;
constexpr int BOOK_LEAF_LEVEL = 5;

constexpr int LEVEL_UNDEFINED = -1;
constexpr int LEVEL_HUMAN = 70;
constexpr int BOOK_LOSS_IGNORE_THRESHOLD = 8;
constexpr int LEAF_CALCULATE_LEVEL = 5;

#define BOOK_EXTENSION ".egbk3"
#define BOOK_EXTENSION_NODOT "egbk3"

constexpr int ADD_LEAF_SPECIAL_LEVEL = -1;

constexpr uint64_t MAX_N_LINES = 4000000000; 


struct Book_value {
    int policy;
    int value;

    Search_result to_search_result() {
        Search_result res;
        res.policy = policy;
        res.value = value;
        res.depth = SEARCH_BOOK;
        res.time = 0;
        res.nodes = 0;
        res.clog_time = 0;
        res.clog_nodes = 0;
        res.nps = 0;
        res.is_end_search = false;
        res.probability = -1;
        return res;
    }
};

struct Leaf {
    int8_t value;
    int8_t move;
    int8_t level;

    Leaf()
        : value(SCORE_UNDEFINED), move(MOVE_UNDEFINED), level(LEVEL_UNDEFINED) {}
};


struct Book_elem {
    int8_t value;
    int8_t level;
    Leaf leaf;
    uint32_t n_lines;
    bool seen; 

    Book_elem()
        : value(SCORE_UNDEFINED), level(LEVEL_UNDEFINED), n_lines(0), seen(false) {}
};

struct Book_info {
    uint64_t n_boards;
    uint64_t n_boards_in_level[LEVEL_HUMAN + 1];
    uint64_t n_boards_in_ply[HW2 - 4 + 1];
    uint64_t n_leaves_in_level[LEVEL_HUMAN + 1];
    uint64_t n_leaves_in_ply[HW2 - 4 + 1];

    Book_info() 
        : n_boards(0) {
        for (int i = 0; i < LEVEL_HUMAN + 1; ++i) {
            n_boards_in_level[i] = 0;
            n_leaves_in_level[i] = 0;
        }
        for (int i = 0; i < HW2 - 4 + 1; ++i) {
            n_boards_in_ply[i] = 0;
            n_leaves_in_ply[i] = 0;
        }
    }
};


size_t hash_rand_player_book[4][65536];
size_t hash_rand_opponent_book[4][65536];


void book_hash_init_rand() {
    int i, j;
    for (i = 0; i < 4; ++i) {
        for (j = 0; j < 65536; ++j) {
            hash_rand_player_book[i][j] = 0;
            while (pop_count_uint(hash_rand_player_book[i][j]) < 9) {
                hash_rand_player_book[i][j] = myrand_ull();
            }
            hash_rand_opponent_book[i][j] = 0;
            while (pop_count_uint(hash_rand_opponent_book[i][j]) < 9) {
                hash_rand_opponent_book[i][j] = myrand_ull();
            }
        }
    }
}


void book_hash_init(bool show_log) {
    FILE* fp;
    if (!file_open(&fp, "resources/hash_book.eghs", "rb")) {
        std::cerr << "[ERROR] can't open hash_book.eghs" << std::endl;
        book_hash_init_rand();
        return;
    }
    for (int i = 0; i < 4; ++i) {
        if (fread(hash_rand_player_book[i], 8, 65536, fp) < 65536) {
            std::cerr << "[ERROR] hash_book.eghs broken" << std::endl;
            book_hash_init_rand();
            return;
        }
    }
    for (int i = 0; i < 4; ++i) {
        if (fread(hash_rand_opponent_book[i], 8, 65536, fp) < 65536) {
            std::cerr << "[ERROR] hash_book.eghs broken" << std::endl;
            book_hash_init_rand();
            return;
        }
    }
    if (show_log) {
        std::cerr << "hash for book initialized" << std::endl;
    }
    return;
}


struct Book_hash {
    size_t operator()(Board board) const{
        const uint16_t *p = (uint16_t*)&board.player;
        const uint16_t *o = (uint16_t*)&board.opponent;
        return 
            hash_rand_player_book[0][p[0]] ^ 
            hash_rand_player_book[1][p[1]] ^ 
            hash_rand_player_book[2][p[2]] ^ 
            hash_rand_player_book[3][p[3]] ^ 
            hash_rand_opponent_book[0][o[0]] ^ 
            hash_rand_opponent_book[1][o[1]] ^ 
            hash_rand_opponent_book[2][o[2]] ^ 
            hash_rand_opponent_book[3][o[3]];
    }
};







class Book {
    private:
        std::mutex mtx;
        std::unordered_map<Board, Book_elem, Book_hash> book;

    public:
        
        bool init(std::string file, bool show_log, bool *stop_loading) {
            delete_all();
            if (!import_file_egbk3(file, show_log, stop_loading)) { 
                std::cerr << "failed egbk3 formatted book. trying egbk2 format." << std::endl;
                if (!import_file_egbk2(file, show_log, stop_loading)) { 
                    std::cerr << "failed egbk2 formatted book. trying egbk format." << std::endl;
                    return import_file_egbk(file, 1, show_log, stop_loading); 
                }
            }
            return true;
        }

        inline bool import_book_extension_determination(std::string file, int level, bool *stop) {
            bool result = false;
            std::vector<std::string> lst;
            auto offset = std::string::size_type(0);
            while (1) {
                auto pos = file.find(".", offset);
                if (pos == std::string::npos) {
                    lst.push_back(file.substr(offset));
                    break;
                }
                lst.push_back(file.substr(offset, pos - offset));
                offset = pos + 1;
            }
            if (lst[lst.size() - 1] == "egbk3") {
                std::cerr << "importing Egaroucid book (.egbk3)" << std::endl;
                result = import_file_egbk3(file, true, stop);
            }
            if (lst[lst.size() - 1] == "egbk2") {
                std::cerr << "importing Egaroucid legacy book (.egbk2)" << std::endl;
                result = import_file_egbk2(file, true, stop);
            } else if (lst[lst.size() - 1] == "egbk") {
                std::cerr << "importing Egaroucid legacy book (.egbk)" << std::endl;
                result = import_file_egbk(file, level, true, stop);
            } else if (lst[lst.size() - 1] == "dat") {
                std::cerr << "importing Edax book" << std::endl;
                result = import_file_edax(file, true, stop);
            } else {
                std::cerr << "this is not a book" << std::endl;
            }
            return result;
        }

        inline bool import_book_extension_determination(std::string file, int level) {
            bool stop = false;
            return import_book_extension_determination(file, level, &stop);
        }

        inline bool import_book_extension_determination(std::string file) {
            bool stop = false;
            return import_book_extension_determination(file, LEVEL_UNDEFINED, &stop);
        }

        
        inline bool import_file_egbk3(std::string file, bool show_log, bool *stop_loading) {
            if (show_log)
                std::cerr << "importing " << file << std::endl;
            FILE* fp;
            if (!file_open(&fp, file.c_str(), "rb")) {
                std::cerr << "[ERROR] can't open Egaroucid book " << file << std::endl;
                return false;
            }
            Board board;
            Book_elem book_elem;
            int n_boards;
            char value, level, leaf_value, leaf_move, leaf_level;
            uint32_t n_lines;
            uint64_t p, o;
            char egaroucid_str[10];
            char egaroucid_str_ans[] = "DICUORAGE";
            char elem_char;
            char book_version;
            
            if (fread(egaroucid_str, 1, 9, fp) < 9) {
                std::cerr << "[ERROR] file broken" << std::endl;
                fclose(fp);
                return false;
            }
            for (int i = 0; i < 9; ++i) {
                if (egaroucid_str[i] != egaroucid_str_ans[i]) {
                    std::cerr << "[ERROR] This is not Egarocuid book, found " << egaroucid_str[i] << ", " << (int)egaroucid_str[i] << " at char " << i << ", expected " << egaroucid_str_ans[i] << " , " << (int)egaroucid_str_ans[i] << std::endl;
                    fclose(fp);
                    return false;
                }
            }
            if (fread(&book_version, 1, 1, fp) < 1) {
                std::cerr << "[ERROR] file broken" << std::endl;
                fclose(fp);
                return false;
            }
            if (book_version != 3) {
                std::cerr << "[ERROR] This is not Egarocuid book version 3, found version " << (int)book_version << std::endl;
                fclose(fp);
                return false;
            }
            
            if (fread(&n_boards, 4, 1, fp) < 1) {
                std::cerr << "[ERROR] book broken at n_book data" << std::endl;
                fclose(fp);
                return false;
            }
            if (show_log) {
                std::cerr << n_boards << " boards to read" << std::endl;
            }
            
            int percent = -1;
            char datum[25];
            for (int i = 0; i < n_boards; ++i) {
                if (*stop_loading) {
                    break;
                }
                int n_percent = (double)i / n_boards * 100;
                if (n_percent > percent && show_log) {
                    percent = n_percent;
                    std::cerr << "loading book " << percent << "%" << std::endl;
                }
                
                if (fread(datum, 1, 25, fp) < 25) {
                    std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                    fclose(fp);
                    return false;
                }
                p = ((uint64_t*)datum)[0];
                o = ((uint64_t*)datum)[1];
                value = datum[16];
                level = datum[17];
                n_lines = ((uint32_t*)(datum + 18))[0];
                leaf_value = datum[22];
                leaf_move = datum[23];
                leaf_level = datum[24];
                
                
                if (-HW2 <= value && value <= HW2 && (p & o) == 0) {
                    board.player = p;
                    board.opponent = o;
#if FORCE_BOOK_DEPTH
                    if (board.n_discs() <= 4 + 30) {
#endif
                        book_elem.value = value;
                        book_elem.level = level;
                        
                        
                        
                        
                        book_elem.n_lines = n_lines;
                        book_elem.leaf.value = leaf_value;
                        book_elem.leaf.move = leaf_move;
                        book_elem.leaf.level = leaf_level;
                        merge(board, book_elem);
#if FORCE_BOOK_DEPTH
                    }
#endif
                }
            }
            if (*stop_loading) {
                std::cerr << "stop loading book" << std::endl;
                fclose(fp);
                return false;
            }
            if (show_log) {
                std::cerr << "imported " << book.size() << " boards to book" << std::endl;
            }
            fclose(fp);
            return true;
        }

        inline bool import_file_egbk3(std::string file, bool show_log) {
            bool stop_loading = false;
            return import_file_egbk3(file, show_log, &stop_loading);
        }

        
        inline bool import_file_egbk2(std::string file, bool show_log, bool *stop_loading) {
            if (show_log) {
                std::cerr << "importing " << file << std::endl;
            }
            FILE* fp;
            if (!file_open(&fp, file.c_str(), "rb")) {
                std::cerr << "[ERROR] can't open Egaroucid book " << file << std::endl;
                return false;
            }
            Board board;
            Book_elem book_elem;
            int n_boards;
            char value;
            uint64_t p, o;
            char level, n_moves, val, mov;
            char egaroucid_str[10];
            char egaroucid_str_ans[] = "DICUORAGE";
            char book_version;
            
            if (fread(egaroucid_str, 1, 9, fp) < 9) {
                std::cerr << "[ERROR] file broken" << std::endl;
                fclose(fp);
                return false;
            }
            for (int i = 0; i < 9; ++i) {
                if (egaroucid_str[i] != egaroucid_str_ans[i]) {
                    std::cerr << "[ERROR] This is not Egarocuid book version 2, found " << egaroucid_str[i] << ", " << (int)egaroucid_str[i] << " at char " << i << ", expected " << egaroucid_str_ans[i] << " , " << (int)egaroucid_str_ans[i] << std::endl;
                    fclose(fp);
                    return false;
                }
            }
            if (fread(&book_version, 1, 1, fp) < 1) {
                std::cerr << "[ERROR] file broken" << std::endl;
                fclose(fp);
                return false;
            }
            if (book_version != 2) {
                std::cerr << "[ERROR] This is not Egarocuid book version 2, found version " << (int)book_version << std::endl;
                fclose(fp);
                return false;
            }
            
            if (fread(&n_boards, 4, 1, fp) < 1) {
                std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                fclose(fp);
                return false;
            }
            if (show_log) {
                std::cerr << n_boards << " boards to read" << std::endl;
            }
            
            int percent = -1;
            for (int i = 0; i < n_boards; ++i) {
                if (*stop_loading) {
                    break;
                }
                int n_percent = (double)i / n_boards * 100;
                if (n_percent > percent && show_log) {
                    percent = n_percent;
                    std::cerr << "loading book " << percent << "%" << std::endl;
                }
                
                if (fread(&p, 8, 1, fp) < 1) {
                    std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                if (fread(&o, 8, 1, fp) < 1) {
                    std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                if (fread(&value, 1, 1, fp) < 1) {
                    std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                    fclose(fp);
                    return false;
                }
                if (value < -HW2 || HW2 < value) {
                    std::cerr << "[ERROR] book NOT FULLY imported got value " << (int)value << " " << book.size() << " boards" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                if (fread(&level, 1, 1, fp) < 1) {
                    std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                if (fread(&n_moves, 1, 1, fp) < 1) {
                    std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                for (uint8_t i = 0; i < n_moves; ++i) {
                    
                    if (fread(&val, 1, 1, fp) < 1) {
                        std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                        fclose(fp);
                        return false;
                    }
                    
                    if (fread(&mov, 1, 1, fp) < 1) {
                        std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                        fclose(fp);
                        return false;
                    }
                    
                }
                board.player = p;
                board.opponent = o;
#if FORCE_BOOK_DEPTH
                if (b.n_discs() <= 4 + 30) {
#endif
                    book_elem.value = value;
                    book_elem.level = level;
                    book_elem.leaf.value = SCORE_UNDEFINED;
                    book_elem.leaf.move = MOVE_UNDEFINED;
                    merge(board, book_elem);
#if FORCE_BOOK_DEPTH
                }
#endif
            }
            
            
            
            
            
            
            
            
            if (show_log)
                std::cerr << "imported " << book.size() << " boards to book" << std::endl;
            fclose(fp);
            return true;
        }

        inline bool import_file_egbk2(std::string file, bool show_log) {
            bool stop_loading = false;
            return import_file_egbk2(file, show_log, &stop_loading);
        }



        
        inline bool import_file_egbk(std::string file, int level, bool show_log, bool *stop_loading) {
            if (show_log)
                std::cerr << "importing " << file << std::endl;
            FILE* fp;
            if (!file_open(&fp, file.c_str(), "rb")) {
                std::cerr << "[ERROR] can't open Egaroucid book " << file << std::endl;
                return false;
            }
            Board board;
            Book_elem book_elem;
            int n_boards;
            char value;
            uint64_t p, o;
            uint8_t value_raw;
            
            if (fread(&n_boards, 4, 1, fp) < 1) {
                std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                fclose(fp);
                return false;
            }
            if (show_log) {
                std::cerr << n_boards << " boards to read" << std::endl;
            }
            
            int percent = -1;
            for (int i = 0; i < n_boards; ++i) {
                if (*stop_loading) {
                    break;
                }
                int n_percent = (double)i / n_boards * 100;
                if (n_percent > percent && show_log) {
                    percent = n_percent;
                    std::cerr << "loading book " << percent << "%" << std::endl;
                }
                
                if (fread(&p, 8, 1, fp) < 1) {
                    std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                if (fread(&o, 8, 1, fp) < 1) {
                    std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                if (fread(&value_raw, 1, 1, fp) < 1) {
                    std::cerr << "[ERROR] book NOT FULLY imported " << book.size() << " boards" << std::endl;
                    fclose(fp);
                    return false;
                }
                value = -((int8_t)value_raw - HW2);
                if (value < -HW2 || HW2 < value) {
                    std::cerr << "[ERROR] book NOT FULLY imported got value " << (int)value << " " << book.size() << " boards" << std::endl;
                    fclose(fp);
                    return false;
                }
                board.player = p;
                board.opponent = o;
#if FORCE_BOOK_DEPTH
                if (b.n_discs() <= 4 + 30) {
#endif
                    book_elem.value = value;
                    if (level != LEVEL_UNDEFINED) {
                        book_elem.level = level;
                    } else {
                        book_elem.level = 1;
                    }
                    book_elem.leaf.value = SCORE_UNDEFINED;
                    book_elem.leaf.move = MOVE_UNDEFINED;
                    merge(board, book_elem);
#if FORCE_BOOK_DEPTH
                }
#endif
            }
            
            
            
            
            
            
            
            
            if (show_log) {
                std::cerr << "imported " << book.size() << " boards to book" << std::endl;
            }
            fclose(fp);
            return true;
        }

        inline bool import_file_egbk(std::string file, int level, bool show_log) {
            bool stop_loading = false;
            return import_file_egbk(file, level, show_log, &stop_loading);
        }

        
        inline bool import_file_edax(std::string file, bool show_log, bool *stop) {
            if (show_log) {
                std::cerr << "importing " << file << std::endl;
            }
            FILE* fp;
            if (!file_open(&fp, file.c_str(), "rb")) {
                std::cerr << "[ERROR] can't open Edax book " << file << std::endl;
                return false;
            }
            char elem_char;
            int elem_int;
            int16_t elem_short;
            
            for (int i = 0; i < 38; ++i) {
                if (fread(&elem_char, 1, 1, fp) < 1) {
                    std::cerr << "[ERROR] file broken" << std::endl;
                    fclose(fp);
                    return false;
                }
            }
            
            if (fread(&elem_int, 4, 1, fp) < 1) {
                std::cerr << "[ERROR] file broken" << std::endl;
                fclose(fp);
                return false;
            }
            int n_boards = elem_int;
            std::cerr << n_boards << " boards found" << std::endl;
            uint64_t player, opponent;
            int16_t value;
            uint32_t n_lines;
            char link = 0, link_value, link_move, level, leaf_value, leaf_move;
            Board board;
            Flip flip;
            Book_elem book_elem;
            int percent = -1;
            for (int i = 0; i < n_boards; ++i) {
                if (*stop) {
                    return false;
                }
                int n_percent = (double)i / n_boards * 100;
                if (n_percent > percent && show_log) {
                    percent = n_percent;
                    std::cerr << "loading book " << percent << "%" << std::endl;
                }
                
                if (fread(&player, 8, 1, fp) < 1) {
                    std::cerr << "[ERROR] file broken" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                if (fread(&opponent, 8, 1, fp) < 1) {
                    std::cerr << "[ERROR] file broken" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                for (int j = 0; j < 3; ++j) {
                    if (fread(&elem_int, 4, 1, fp) < 1) {
                        std::cerr << "[ERROR] file broken" << std::endl;
                        fclose(fp);
                        return false;
                    }
                }
                
                if (fread(&n_lines, 4, 1, fp) < 1) {
                    std::cerr << "[ERROR] file broken" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                if (fread(&value, 2, 1, fp) < 1) {
                    std::cerr << "[ERROR] file broken" << std::endl;
                    fclose(fp);
                    return false;
                }
                if (value < -HW2 || HW2 < value) {
                    
                    
                    
                    
                    value = SCORE_UNDEFINED;
                }
                
                for (int j = 0; j < 2; ++j) {
                    if (fread(&elem_short, 2, 1, fp) < 1) {
                        std::cerr << "[ERROR] file broken" << std::endl;
                        fclose(fp);
                        return false;
                    }
                }
                
                if (fread(&link, 1, 1, fp) < 1) {
                    std::cerr << "[ERROR] file broken" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                if (fread(&level, 1, 1, fp) < 1) {
                    std::cerr << "[ERROR] file broken" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                for (int j = 0; j < (int)link; ++j) {
                    if (fread(&link_value, 1, 1, fp) < 1) {
                        std::cerr << "[ERROR] file broken" << std::endl;
                        fclose(fp);
                        return false;
                    }
                    if (fread(&link_move, 1, 1, fp) < 1) {
                        std::cerr << "[ERROR] file broken" << std::endl;
                        fclose(fp);
                        return false;
                    }
                }
                
                if (fread(&leaf_value, 1, 1, fp) < 1) {
                    std::cerr << "[ERROR] file broken" << std::endl;
                    fclose(fp);
                    return false;
                }
                
                if (fread(&leaf_move, 1, 1, fp) < 1) {
                    std::cerr << "[ERROR] file broken" << std::endl;
                    fclose(fp);
                    return false;
                }
                if (leaf_value < -HW2 || HW2 < leaf_value || leaf_move < 0 || HW2 <= leaf_move) {
                    leaf_value = SCORE_UNDEFINED;
                    leaf_move = MOVE_UNDEFINED;
                }
                if (value != SCORE_UNDEFINED && (player & opponent) == 0ULL && calc_legal(player, opponent)) {
                    board.player = player;
                    board.opponent = opponent;
                    book_elem.value = value;
                    book_elem.level = level;
                    book_elem.leaf.value = leaf_value;
                    book_elem.leaf.move = leaf_move;
                    book_elem.leaf.level = level;
                    book_elem.n_lines = n_lines;
                    merge(board, book_elem);
                }
            }
            if (show_log) {
                std::cerr << "imported " << book.size() << " boards to book" << std::endl;
            }
            return true;
        }

        
        inline void save_egbk3(std::string file, std::string bak_file, bool use_backup, int level) {
            if (use_backup) {
                if (remove(bak_file.c_str()) == -1) {
                    std::cerr << "cannot delete backup. you can ignore this error." << std::endl;
                }
                rename(file.c_str(), bak_file.c_str());
            }
            std::ofstream fout;
            fout.open(file.c_str(), std::ios::out|std::ios::binary|std::ios::trunc);
            if (!fout) {
                std::cerr << "can't open " << file << std::endl;
                return;
            }
            char elem;
            std::cerr << "saving book..." << std::endl;
            char egaroucid_str[] = "DICUORAGE";
            fout.write((char*)&egaroucid_str, 9);
            char book_version = 3;
            fout.write((char*)&book_version, 1);
            int n_book = (int)book.size();
            fout.write((char*)&n_book, 4);
            int t = 0, percent = -1, n_boards = (int)book.size();
            for (auto itr = book.begin(); itr != book.end(); ++itr) {
                ++t;
                int n_percent = (double)t / n_boards * 100;
                if (n_percent > percent) {
                    percent = n_percent;
                    std::cerr << "saving book " << percent << "%" << std::endl;
                }
                char char_level = itr->second.level, char_leaf_level = itr->second.leaf.level;
                if (level != LEVEL_UNDEFINED) {
                    char_level = level;
                    char_leaf_level = level;
                }
                fout.write((char*)&itr->first.player, 8);
                fout.write((char*)&itr->first.opponent, 8);
                fout.write((char*)&itr->second.value, 1);
                fout.write((char*)&char_level, 1);
                fout.write((char*)&itr->second.n_lines, 4);
                fout.write((char*)&itr->second.leaf.value, 1);
                fout.write((char*)&itr->second.leaf.move, 1);
                fout.write((char*)&char_leaf_level, 1);
            }
            fout.close();
            int book_size = (int)book.size();
            std::cerr << "saved " << t << " boards , book_size " << book_size << std::endl;
        }

        inline void save_egbk3(std::string file, std::string bak_file) {
            save_egbk3(file, bak_file, true, LEVEL_UNDEFINED);
        }

        inline void save_egbk3(std::string file, int level) {
            save_egbk3(file, "", false, level);
        }

        void get_pass_boards(Board board, std::unordered_set<Board, Book_hash> &pass_boards) {
            board = representative_board(board);
            if (contain_representative(board)) {
                if (book[board].seen) {
                    return;
                }
                book[board].seen = true;
            }
            uint64_t legal = board.get_legal();
            if (legal == 0ULL) {
                if (pass_boards.find(board) != pass_boards.end()) {
                    return;
                }
                Board passed_board = board.copy();
                passed_board.pass();
                if (!contain_representative(board) && contain(passed_board)) {
                    pass_boards.emplace(board);
                    get_pass_boards(passed_board, pass_boards);
                }
            } else {
                std::vector<Book_value> links = get_all_moves_with_value(&board);
                Flip flip;
                for (Book_value &link: links) {
                    calc_flip(&flip, &board, link.policy);
                    board.move_board(&flip);
                        get_pass_boards(board, pass_boards);
                    board.undo_board(&flip);
                }
            }
        }

        
        inline void save_bin_edax(std::string file, int level) {
            bool stop = false;
            check_add_leaf_all_search(ADD_LEAF_SPECIAL_LEVEL, &stop);
            std::unordered_set<Board, Book_hash> pass_boards;
            Board root_board;
            root_board.reset();
            std::cerr << "pass board calculating..." << std::endl;
            reset_seen();
            get_pass_boards(root_board, pass_boards);
            reset_seen();
            std::cerr << "pass board calculated " << pass_boards.size() << std::endl;
            std::ofstream fout;
            fout.open(file.c_str(), std::ios::out|std::ios::binary|std::ios::trunc);
            if (!fout) {
                std::cerr << "can't open " << file << std::endl;
                return;
            }
            std::cerr << "saving book..." << std::endl;
            char header[] = "XADEKOOB";
            for (int i = 0; i < 8; ++i) {
                fout.write((char*)&header[i], 1);
            }
            char ver = 4;
            fout.write((char*)&ver, 1);
            char rel = 4;
            fout.write((char*)&rel, 1);
            int year, month, day, hour, minute, second;
            calc_date(&year, &month, &day, &hour, &minute, &second);
            fout.write((char*)&year, 2);
            fout.write((char*)&month, 1);
            fout.write((char*)&day, 1);
            fout.write((char*)&hour, 1);
            fout.write((char*)&minute, 1);
            fout.write((char*)&second, 1);
            char dummy = 0;
            fout.write((char*)&dummy, 1);
            fout.write((char*)&level, 4);
            int n_empties = HW2;
            for (auto itr = book.begin(); itr != book.end(); ++itr) {
                n_empties = std::min(n_empties, HW2 + 1 - itr->first.n_discs());
            }
            fout.write((char*)&n_empties, 4);
            int err_mid = 0;
            fout.write((char*)&err_mid, 4);
            int err_end = 0;
            fout.write((char*)&err_end, 4);
            int verb = 0;
            fout.write((char*)&verb, 4);
            int n_position = book.size() + pass_boards.size();
            fout.write((char*)&n_position, 4);
            int n_win = 0, n_draw = 0, n_lose = 0;
            uint32_t n_lines;
            short short_val, short_val_min = -HW2, short_val_max = HW2;
            char char_level = (char)level;
            Book_elem book_elem;
            char link_value, link_move;
            int max_link_value, min_link_value;
            char leaf_val, leaf_move;
            char n_link;
            Flip flip;
            Board b;
            bool searching = true;
            int percent = -1;
            int n_boards = (int)book.size();
            int t = 0;
            for (Board pass_board: pass_boards) {
                Board passed_board = pass_board.copy();
                passed_board.pass();
                Book_elem passed_elem = get(passed_board);
                n_lines = passed_elem.n_lines;
                short_val = (short)passed_elem.value;
                if (level == LEVEL_UNDEFINED) {
                    Board b = pass_board.copy();
                    b.pass();
                    if (contain(b)) {
                        char_level = get(b).level;
                    } else {
                        char_level = 1;
                    }
                }
                if (char_level > 60) {
                    char_level = 60;
                }
                n_link = 1;
                link_value = (char)passed_elem.value;
                link_move = MOVE_PASS;
                leaf_val = SCORE_UNDEFINED;
                leaf_move = MOVE_NOMOVE;
                fout.write((char*)&pass_board.player, 8);
                fout.write((char*)&pass_board.opponent, 8);
                fout.write((char*)&n_win, 4);
                fout.write((char*)&n_draw, 4);
                fout.write((char*)&n_lose, 4);
                fout.write((char*)&n_lines, 4);
                fout.write((char*)&short_val, 2);
                fout.write((char*)&short_val_min, 2);
                fout.write((char*)&short_val_max, 2);
                fout.write((char*)&n_link, 1);
                fout.write((char*)&char_level, 1);
                fout.write((char*)&link_value, 1);
                fout.write((char*)&link_move, 1);
                fout.write((char*)&leaf_val, 1);
                fout.write((char*)&leaf_move, 1);
            }
            for (auto itr = book.begin(); itr != book.end(); ++itr) {
                book_elem = itr->second;
                int n_percent = (double)t / n_boards * 100;
                if (n_percent > percent) {
                    percent = n_percent;
                    std::cerr << "converting book " << percent << "%" << std::endl;
                }
                ++t;
                short_val = book_elem.value;
                
                
                b = itr->first;
                std::vector<Book_value> links = get_all_moves_with_value(&b);
                n_link = (char)links.size();
                leaf_val = itr->second.leaf.value;
                leaf_move = itr->second.leaf.move;
                if (leaf_val < -HW2 || HW2 < leaf_val || leaf_move < 0 || HW2 <= leaf_move) {
                    leaf_val = SCORE_UNDEFINED;
                    leaf_move = MOVE_NOMOVE;
                }
                n_lines = itr->second.n_lines;
                if (level == LEVEL_UNDEFINED) {
                    char_level = itr->second.level;
                }
                if (char_level > 60) {
                    char_level = 60;
                }
                fout.write((char*)&itr->first.player, 8);
                fout.write((char*)&itr->first.opponent, 8);
                fout.write((char*)&n_win, 4);
                fout.write((char*)&n_draw, 4);
                fout.write((char*)&n_lose, 4);
                fout.write((char*)&n_lines, 4);
                fout.write((char*)&short_val, 2);
                fout.write((char*)&short_val_min, 2);
                fout.write((char*)&short_val_max, 2);
                fout.write((char*)&n_link, 1);
                fout.write((char*)&char_level, 1);
                for (Book_value &book_value: links) {
                    link_value = (char)book_value.value;
                    link_move = (char)book_value.policy;
                    fout.write((char*)&link_value, 1);
                    fout.write((char*)&link_move, 1);
                }
                fout.write((char*)&leaf_val, 1);
                fout.write((char*)&leaf_move, 1);
            }
            fout.close();
            std::cerr << "saved " << t << " boards as a edax-formatted book " << n_position << " " << book.size() << std::endl;
        }

        
        inline void reg(Board b, Book_elem elem) {
            register_symmetric_book(b, elem);
        }

        
        inline void reg(Board *b, Book_elem elem) {
            register_symmetric_book(b->copy(), elem);
        }

        
        inline bool contain_representative(Board b) {
            return book.find(b) != book.end();
        }

        
        inline bool contain_representative(Board *b) {
            return contain_representative(b->copy());
        }

        inline bool contain(Board b) {
            return contain_representative(representative_board(b));
        }

        inline bool contain(Board *b) {
            return contain_representative(representative_board(b));
        }

        
        inline Book_elem get_representative(Board b, int idx) {
            Book_elem res;
            if (!contain_representative(b)) {
                return res;
            }
            res = book[b];
            if (is_valid_policy(res.leaf.move)) {
                res.leaf.move = convert_coord_from_representative_board(res.leaf.move, idx);
            }
            return res;
        }

        
        inline Book_elem get(Board *b) {
            int rotate_idx;
            Board representive_board = representative_board(b, &rotate_idx);
            return get_representative(representive_board, rotate_idx);
        }

        
        inline Book_elem get(Board b) {
            int rotate_idx;
            Board representive_board = representative_board(b, &rotate_idx);
            return get_representative(representive_board, rotate_idx);
        }

        
        inline std::vector<int> get_all_best_moves(Board *b) {
            std::vector<int> policies;
            uint64_t legal = b->get_legal();
            int max_value = -INF;
            Flip flip;
            for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
                calc_flip(&flip, b, cell);
                b->move_board(&flip);
                    int sgn = -1;
                    if (b->get_legal() == 0ULL) {
                        sgn = 1;
                        b->pass();
                    }
                    if (contain(b)) {
                        Book_elem elem = get(b);
                        if (sgn * elem.value > max_value) {
                            max_value = sgn * elem.value;
                            policies.clear();
                        }
                        if (sgn * elem.value == max_value) {
                            policies.emplace_back(cell);
                        }
                    }
                    if (sgn == 1) {
                        b->pass();
                    }
                b->undo_board(&flip);
            }
            return policies;
        }

        
        inline std::vector<Book_value> get_all_moves_with_value(Board *b) {
            std::lock_guard<std::mutex> lock(mtx);
            std::vector<Book_value> policies;
            uint64_t legal = b->get_legal();
            Flip flip;
            for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
                calc_flip(&flip, b, cell);
                b->move_board(&flip);
                    if (b->is_end()) {
                        if (contain(b)) {
                            Book_value book_value;
                            book_value.policy = cell;
                            book_value.value = -get(b).value;
                            policies.emplace_back(book_value);
                        } else {
                            b->pass();
                                if (contain(b)) {
                                    Book_value book_value;
                                    book_value.policy = cell;
                                    book_value.value = get(b).value;
                                    policies.emplace_back(book_value);
                                }
                            b->pass();
                        }
                    } else if (b->get_legal() == 0) {
                        b->pass();
                            if (contain(b)) {
                                Book_value book_value;
                                book_value.policy = cell;
                                book_value.value = get(b).value;
                                policies.emplace_back(book_value);
                            }
                        b->pass();
                    } else {
                        if (contain(b)) {
                            Book_value book_value;
                            book_value.policy = cell;
                            book_value.value = -get(b).value;
                            policies.emplace_back(book_value);
                        }
                    }
                b->undo_board(&flip);
            }
            return policies;
        }

        inline Book_value get_random(Board *b, int acc_level, uint64_t use_legal) {
            std::vector<std::pair<double, int>> value_policies;
            std::vector<std::pair<int, int>> value_policies_memo;
            uint64_t legal = b->get_legal();
            double best_score = -INF;
            Flip flip;
            for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
                if ((1ULL << cell) & use_legal) {
                    calc_flip(&flip, b, cell);
                    b->move_board(&flip);
                        int sgn = -1;
                        if (b->get_legal() == 0ULL) {
                            sgn = 1;
                            b->pass();
                        }
                        if (contain(b)) {
                            Book_value book_value;
                            book_value.policy = cell;
                            book_value.value = sgn * get(b).value;
                            if (book_value.value > best_score) {
                                best_score = (double)book_value.value;
                            }
                            value_policies.emplace_back(std::make_pair((double)book_value.value, cell));
                            value_policies_memo.emplace_back(std::make_pair(book_value.value, cell));
                        }
                        if (sgn == 1) {
                            b->pass();
                        }
                    b->undo_board(&flip);
                }
            }
            Book_elem board_elem = get(b);
            Book_value res;
            if (value_policies.size() == 0 || best_score < board_elem.value - BOOK_LOSS_IGNORE_THRESHOLD) {
                res.policy = -1;
                res.value = -INF;
                return res;
            }
            double acceptable_min_value = best_score - 2.0 * acc_level - 0.5; 
            double sum_exp_values = 0.0;
            for (std::pair<double, int> &elem: value_policies) {
                if (elem.first < acceptable_min_value) {
                    elem.first = 0.0;
                } else {
                    double exp_val = (exp(elem.first - best_score) + 1.5) / 3.0;
                    elem.first = pow(exp_val, BOOK_ACCURACY_LEVEL_INF - acc_level);
                }
                sum_exp_values += elem.first;
            }
            for (std::pair<double, int> &elem: value_policies)
                elem.first /= sum_exp_values;
            double rnd = myrandom();
            double s = 0.0;
            bool res_got = false;
            for (std::pair<double, int> &elem: value_policies) {
                s += elem.first;
                if (s >= rnd) {
                    res.policy = elem.second;
                    for (std::pair<int, int> elem: value_policies_memo) {
                        if (elem.second == res.policy) {
                            res.value = elem.first;
                        }
                    }
                    res_got = true;
                    break;
                }
            }
            if (!res_got) {
                res.policy = value_policies.back().second;
                for (std::pair<int, int> elem: value_policies_memo) {
                    if (elem.second == res.policy) {
                        res.value = elem.first;
                    }
                }
            }
            return res;
        }

        
        inline Book_value get_random(Board *b, int acc_level) {
            return get_random(b, acc_level, b->get_legal());
        }

        inline Book_value get_specified_best_move(Board *b, uint64_t use_legal) {
            Book_value res;
            res.policy = MOVE_UNDEFINED;
            res.value = -INF;
            Flip flip;
            for (uint_fast8_t cell = first_bit(&use_legal); use_legal; cell = next_bit(&use_legal)) {
                calc_flip(&flip, b, cell);
                b->move_board(&flip);
                    int sgn = -1;
                    if (b->get_legal() == 0ULL) {
                        sgn = 1;
                        b->pass();
                    }
                    if (contain(b)) {
                        Book_value book_value;
                        book_value.policy = cell;
                        book_value.value = sgn * get(b).value;
                        if (book_value.value > res.value) {
                            res = book_value;
                        }
                    }
                    if (sgn == 1) {
                        b->pass();
                    }
                b->undo_board(&flip);
            }
            return res;
        }

        
        inline int get_n_book() {
            return (int)book.size();
        }

        
        inline void change(Board b, int value, int level) {
            std::lock_guard<std::mutex> lock(mtx);
            if (-HW2 <= value && value <= HW2) {
                if (b.is_end()) { 
                    if (contain(b)) {
                        Board bb = representative_board(b);
                        book[bb].value = value;
                        book[bb].level = level;
                    } else {
                        b.pass();
                        if (contain(b)) {
                            Board bb = representative_board(b);
                            book[bb].value = -value;
                            book[bb].level = level;
                        } else {
                            b.pass();
                            Book_elem elem;
                            elem.value = value;
                            elem.level = level;
                            elem.leaf.move = MOVE_UNDEFINED;
                            elem.leaf.value = SCORE_UNDEFINED;
                            elem.leaf.level = LEVEL_UNDEFINED;
                            register_symmetric_book(b, elem);
                        }
                    }
                } else {
                    if (b.get_legal() == 0) { 
                        b.pass();
                        value *= -1;
                    }
                    if (contain(b)) {
                        Board bb = representative_board(b);
                        book[bb].value = value;
                        book[bb].level = level;
                    } else {
                        Book_elem elem;
                        elem.value = value;
                        elem.level = level;
                        elem.leaf.move = MOVE_UNDEFINED;
                        elem.leaf.value = SCORE_UNDEFINED;
                        elem.leaf.level = LEVEL_UNDEFINED;
                        register_symmetric_book(b, elem);
                    }
                }
            }
        }

        
        inline void change(Board *b, int value, int level) {
            Board nb = b->copy();
            change(nb, value, level);
        }

        inline void change(Board b, int value, int level, int leaf_move, int leaf_value, int leaf_level) {
            std::lock_guard<std::mutex> lock(mtx);
            if (-HW2 <= value && value <= HW2) {
                if (b.is_end()) { 
                    if (contain(b)) {
                        Board bb = representative_board(b);
                        book[bb].value = value;
                        book[bb].level = level;
                    } else {
                        b.pass();
                        if (contain(b)) {
                            Board bb = representative_board(b);
                            book[bb].value = -value;
                            book[bb].level = level;
                        } else {
                            b.pass();
                            Book_elem elem;
                            elem.value = value;
                            elem.level = level;
                            elem.leaf.move = MOVE_UNDEFINED;
                            elem.leaf.value = SCORE_UNDEFINED;
                            elem.leaf.level = LEVEL_UNDEFINED;
                            register_symmetric_book(b, elem);
                        }
                    }
                } else {
                    if (b.get_legal() == 0) { 
                        b.pass();
                        value *= -1;
                    }
                    if (contain(b)) {
                        int idx;
                        Board bb = representative_board(b, &idx);
                        book[bb].value = value;
                        book[bb].level = level;
                        book[bb].leaf.move = convert_coord_from_representative_board(leaf_move, idx);
                        book[bb].leaf.value = leaf_value;
                        book[bb].leaf.level = leaf_level;
                    } else {
                        Book_elem elem;
                        elem.value = value;
                        elem.level = level;
                        elem.leaf.move = leaf_move;
                        elem.leaf.value = leaf_value;
                        elem.leaf.level = leaf_level;
                        register_symmetric_book(b, elem);
                    }
                }
            }
        }

        
        inline void delete_elem(Board b) {
            delete_symmetric_book(b);
            
            
            
            
        }

        
        inline void delete_all() {
            
            book.clear();
            reg_first_board();
        }

        
        inline void fix(bool edax_compliant, bool *stop) {
            negamax_book(edax_compliant, stop);
            check_add_leaf_all_undefined();
        }

        
        inline void fix(bool edax_compliant) {
            bool stop = false;
            fix(edax_compliant, &stop);
        }

        Book_elem negamax_book_p(Board board, int64_t *n_seen, int64_t *n_fix, int *percent, bool edax_compliant, bool *stop) {
            if (*stop) {
                Book_elem stop_res;
                stop_res.value = SCORE_UNDEFINED;
                stop_res.n_lines = 0;
                return stop_res;
            }
            if (board.get_legal() == 0) {
                board.pass();
                if (board.get_legal() == 0) { 
                    if (contain(&board)) {
                        return get(board);
                    } else {
                        board.pass();
                        if (contain(&board)) {
                            return get(board);
                        } else {
                            Book_elem stop_res;
                            stop_res.value = SCORE_UNDEFINED;
                            stop_res.n_lines = 0;
                            return stop_res;
                        }
                    }
                } else { 
                    Book_elem res = negamax_book_p(board, n_seen, n_fix, percent, edax_compliant, stop);
                    if (res.value != SCORE_UNDEFINED) {
                        res.value *= -1;
                    }
                    return res;
                }
            }
            board = representative_board(&board);
            Book_elem res = book[board];
            if (res.seen) {
                return res;
            }
            res.seen = true;
            book[board].seen = true;
            if (res.value < -HW2 || HW2 < res.value) {
                
                
                Book_elem stop_res;
                stop_res.value = SCORE_UNDEFINED;
                stop_res.n_lines = 0;
                return stop_res;
            }
            ++(*n_seen);
            int n_percent = (double)(*n_seen) / book.size() * 100;
            if (n_percent > (*percent)) {
                *percent = n_percent;
                std::cerr << "negamaxing book... " << (*percent) << "%" << " fixed " << (*n_fix) << std::endl;
            }
            std::vector<Book_value> links = get_all_moves_with_value(&board);
            uint64_t n_lines = 1;
            Flip flip;
            
            int v = -INF;
            if (edax_compliant) {
                v = res.leaf.value;
            }
            
            
            
            
            Book_elem child_res;
            for (Book_value &link: links) {
                calc_flip(&flip, &board, link.policy);
                board.move_board(&flip);
                    child_res = negamax_book_p(board, n_seen, n_fix, percent, edax_compliant, stop);
                    if (child_res.value != SCORE_UNDEFINED) {
                        if (v < -child_res.value ) { 
                            v = -child_res.value;
                            
                        }
                        n_lines += child_res.n_lines;
                    }
                board.undo_board(&flip);
            }
            if (v != -INF ) {
                
                if (v != res.value) {
                    res.value = v;
                    ++(*n_fix);
                }
            }
            res.n_lines = (uint32_t)std::min((uint64_t)MAX_N_LINES, n_lines);
            book[board] = res;
            return res;
        }

        void negamax_book(bool edax_compliant, bool *stop) {
            Board root_board;
            root_board.reset();
            int64_t n_seen = 0, n_fix = 0;
            int percent = -1;
            reset_seen();
            negamax_book_p(root_board, &n_seen, &n_fix, &percent, edax_compliant, stop);
            reset_seen();
            std::cerr << "negamaxed book fixed " << n_fix << " boards seen " << n_seen << " boards size " << book.size() << std::endl;
        }

        
        void reduce_book_flag_moves(Board board, int max_depth, int max_error_per_move, int remaining_error, uint64_t *n_flags, std::unordered_set<Board, Book_hash> &keep_list, bool *doing) {
            if (!*(doing)) {
                return;
            }
            
            if (board.n_discs() > 4 + max_depth) {
                return;
            }
            
            if (board.get_legal() == 0) { 
                board.pass();
                if (board.get_legal() == 0) { 
                    if (keep_list.find(representative_board(board)) != keep_list.end()) {
                        return;
                    }
                    if (contain(&board)) {
                        Book_elem book_elem = get(board);
                        if (book_elem.seen) {
                            return;
                        }
                    } else {
                        board.pass();
                        if (keep_list.find(representative_board(board)) != keep_list.end()) {
                            return;
                        }
                        Book_elem book_elem = get(board);
                        if (book_elem.seen) {
                            return;
                        }
                    }
                    flag_book_elem(board);
                    keep_list.emplace(representative_board(board));
                    ++(*n_flags);
                    return;
                }
            }
            Board unique_board = representative_board(board);
            
            if (keep_list.find(unique_board) != keep_list.end()) {
                return;
            }
            
            if (!contain(&board)) {
                return;
            }
            Book_elem book_elem = get(board);
            
            if (book_elem.seen) {
                return;
            }
            flag_book_elem(board);
            keep_list.emplace(unique_board);
            ++(*n_flags);
            if ((*n_flags) % 100 == 0) {
                std::cerr << "keep " << (*n_flags) << " boards of " << book.size() << std::endl;
            }
            std::vector<Book_value> links = get_all_moves_with_value(&board);
            Flip flip;
            for (Book_value &link: links) {
                int link_error = book_elem.value - link.value;
                if (link_error <= max_error_per_move && link_error <= remaining_error) {
                    calc_flip(&flip, &board, link.policy);
                    board.move_board(&flip);
                        reduce_book_flag_moves(board, max_depth, max_error_per_move, remaining_error - std::max(0, link_error), n_flags, keep_list, doing);
                    board.undo_board(&flip);
                }
            }
        }

        void update_flagged_leaves(Board board, std::unordered_set<Board, Book_hash> &keep_list, bool *doing) {
            if (!(*doing)) {
                return;
            }
            if (!contain(board)) {
                return;
            }
            if (board.get_legal() == 0) {
                board.pass();
                if (board.get_legal() == 0) {
                    return;
                }
            }
            Book_elem book_elem = get(board);
            
            if (book_elem.seen) {
                return;
            }
            flag_book_elem(board);
            std::vector<Book_value> links = get_all_moves_with_value(&board);
            Flip flip;
            if (keep_list.find(representative_board(board)) != keep_list.end()) {
                bool leaf_updated = false;
                for (Book_value &link: links) {
                    calc_flip(&flip, &board, link.policy);
                    board.move_board(&flip);
                        bool is_end = board.is_end();
                        bool passed = board.get_legal() == 0;
                        bool will_be_deleted = keep_list.find(representative_board(board)) == keep_list.end();
                        if (is_end) {
                            will_be_deleted = keep_list.find(representative_board(board)) == keep_list.end();
                            board.pass();
                                will_be_deleted |= keep_list.find(representative_board(board)) == keep_list.end();
                            board.pass();
                        } else if (passed) {
                            board.pass();
                                will_be_deleted = keep_list.find(representative_board(board)) == keep_list.end();
                            board.pass();
                        }
                        if (will_be_deleted) {
                            if (book_elem.leaf.value < link.value) {
                                book_elem.leaf.value = link.value;
                                book_elem.leaf.move = link.policy;
                                if (is_end) {
                                    book_elem.leaf.level = get(board).level;
                                    if (book_elem.leaf.level == LEVEL_UNDEFINED) {
                                        board.pass();
                                            book_elem.leaf.level = get(board).level;
                                        board.pass();
                                    }
                                } else if (passed) {
                                    board.pass();
                                        book_elem.leaf.level = get(board).level;
                                    board.pass();
                                } else {
                                    book_elem.leaf.level = get(board).level;
                                }
                                leaf_updated = true;
                            }
                        } else {
                            update_flagged_leaves(board, keep_list, doing);
                        }
                    board.undo_board(&flip);
                }
                if (leaf_updated) {
                    reg(&board, book_elem);
                }
            }
        }

        void delete_unflagged_moves(Board board, uint64_t *n_delete, std::unordered_set<Board, Book_hash> &keep_list, bool *doing) {
            if (!(*doing)) {
                return;
            }
            if (board.get_legal() == 0) {
                board.pass();
                if (board.get_legal() == 0) { 
                    bool keep_board = keep_list.find(representative_board(board)) != keep_list.end();
                    board.pass();
                    keep_board |= keep_list.find(representative_board(board)) != keep_list.end();
                    if (!keep_board) {
                        delete_elem(board);
                        board.pass();
                        delete_elem(board);
                        ++(*n_delete);
                    }
                    return;
                }
            }
            if (!contain(board)) {
                return;
            }
            Book_elem book_elem = get(board);
            
            if (book_elem.seen) {
                return;
            }
            flag_book_elem(board);
            std::vector<Book_value> links = get_all_moves_with_value(&board);
            Flip flip;
            for (Book_value &link: links) {
                calc_flip(&flip, &board, link.policy);
                board.move_board(&flip);
                    delete_unflagged_moves(board, n_delete, keep_list, doing);
                board.undo_board(&flip);
            }
            if (keep_list.find(representative_board(board)) == keep_list.end()) {
                delete_elem(board);
                ++(*n_delete);
                if ((*n_delete) % 100 == 0) {
                    std::cerr << "deleting " << (*n_delete) << " boards" << std::endl;
                }
            }
        }

        void reduce_book(Board root_board, int max_depth, int max_error_per_move, int max_line_error, bool *doing) {
            Book_elem book_elem = get(root_board);
            if (book_elem.value == SCORE_UNDEFINED) {
                *doing = false;
                return;
            }
            uint64_t n_flags = 0, n_delete = 0;
            uint64_t book_size = book.size();
            std::unordered_set<Board, Book_hash> keep_list;
            reset_seen();
            reduce_book_flag_moves(root_board, max_depth, max_error_per_move, max_line_error, &n_flags, keep_list, doing);
            reset_seen();
            std::cerr << "updating leaves" << std::endl;
            update_flagged_leaves(root_board, keep_list, doing);
            reset_seen();
            delete_unflagged_moves(root_board, &n_delete, keep_list, doing);
            reset_seen();
            std::cerr << "book reduced size before " << book_size << " n_keep " << n_flags << " n_delete " << n_delete << std::endl;
            *doing = false;
        }

        void delete_terminal_midsearch_rec(Board board, bool *doing) {
            if (!(*doing)) {
                return;
            }
            if (!contain(board)) {
                return;
            }
            if (board.get_legal() == 0) {
                board.pass();
                if (board.get_legal() == 0) {
                    return;
                }
            }
            Book_elem book_elem = get(board);
            
            if (book_elem.seen) {
                return;
            }
            flag_book_elem(board);
            std::vector<Book_value> links = get_all_moves_with_value(&board);
            if (links.size() == 0) {
                int end_depth = get_level_endsearch_depth(book_elem.level);
                if (HW2 - board.n_discs() > end_depth) {
                    delete_elem(board);
                }
            } else{
                Flip flip;
                for (Book_value &link: links) {
                    calc_flip(&flip, &board, link.policy);
                    board.move_board(&flip);
                        delete_terminal_midsearch_rec(board, doing);
                    board.undo_board(&flip);
                }
            }
        }

        void delete_terminal_midsearch(Board root_board, bool *doing) {
            reset_seen();
            delete_terminal_midsearch_rec(root_board, doing);
            reset_seen();
        }

        uint32_t recalculate_n_lines_rec(Board board, bool *stop) {
            if (*stop) {
                return 0;
            }
            if (board.get_legal() == 0) {
                board.pass();
                if (board.get_legal() == 0) {
                    return 1;
                }
            }
            board = representative_board(&board);
            Book_elem book_elem = get(board);
            
            if (book_elem.seen) {
                return book_elem.n_lines;
            }
            flag_book_elem(board);
            std::vector<Book_value> links = get_all_moves_with_value(&board);
            uint64_t n_lines = 1;
            Flip flip;
            for (Book_value &link: links) {
                calc_flip(&flip, &board, link.policy);
                board.move_board(&flip);
                    n_lines += recalculate_n_lines_rec(board, stop);
                board.undo_board(&flip);
            }
            n_lines = (uint32_t)std::min((uint64_t)MAX_N_LINES, n_lines);
            book[board].n_lines = (uint32_t)n_lines;
            return (uint32_t)n_lines;
        }

        uint64_t upgrade_better_leaves_rec(Board board, bool *stop) {
            if (*stop) {
                return 0;
            }
            if (board.get_legal() == 0) {
                board.pass();
                if (board.get_legal() == 0) {
                    return 0;
                }
            }
            uint64_t res = 0;
            board = representative_board(&board);
            Book_elem book_elem = get(board);
            
            if (book_elem.seen) {
                return 0;
            }
            flag_book_elem(board);
            std::vector<Book_value> links = get_all_moves_with_value(&board);
            Flip flip;
            if (links.size() && (board.get_legal() & (1ULL << book_elem.leaf.move))) {
                int link_max = -SCORE_INF;
                for (Book_value &link: links) {
                    link_max = std::max(link_max, link.value);
                }
                if (book_elem.leaf.value > link_max) { 
                    
                    
                    calc_flip(&flip, &board, book_elem.leaf.move);
                    board.move_board(&flip);
                        Book_elem new_elem;
                        new_elem.level = book_elem.leaf.level;
                        new_elem.seen = false;
                        new_elem.value = -book_elem.leaf.value;
                        reg(&board, new_elem);
                        ++res;
                        res += upgrade_better_leaves_rec(board, stop);
                    board.undo_board(&flip);
                }
            }
            for (Book_value &link: links) {
                calc_flip(&flip, &board, link.policy);
                board.move_board(&flip);
                    res += upgrade_better_leaves_rec(board, stop);
                board.undo_board(&flip);
            }
            return res;
        }

        void recalculate_n_lines(Board root_board, bool *stop) {
            std::cerr << "recalculating n_lines..." << std::endl;
            reset_seen();
            recalculate_n_lines_rec(root_board, stop);
            reset_seen();
            std::cerr << "n_lines recalculated" << std::endl;
        }

        void upgrade_better_leaves(Board root_board, bool *stop) {
            std::cerr << "upgrading better leaves..." << std::endl;
            reset_seen();
            uint64_t n = upgrade_better_leaves_rec(root_board, stop);
            reset_seen();
            std::cerr << "upgraded " << n << " leaves" << std::endl;
        }

        uint64_t size() {
            return book.size();
        }

        void reset_seen() {
            std::vector<Board> boards;
            for (auto itr = book.begin(); itr != book.end(); ++itr) {
                boards.emplace_back(itr->first);
            }
            Flip flip;
            for (Board &board: boards) {
                book[board].seen = false;
            }
        }

        void flag_book_elem(Board board) {
            book[representative_board(board)].seen = true;
        }

        void add_leaf(Board *board, int8_t value, int8_t policy, int8_t level) {
            std::lock_guard<std::mutex> lock(mtx);
            int rotate_idx;
            Board representive_board = representative_board(board, &rotate_idx);
            int8_t rotated_policy = policy;
            if (is_valid_policy(policy)) {
                rotated_policy = convert_coord_from_representative_board((int)policy, rotate_idx);
            }
            Leaf leaf;
            leaf.value = value;
            leaf.move = rotated_policy;
            leaf.level = level;
            book[representive_board].leaf = leaf;
        }

        void search_leaf(Board board, int level, bool use_multi_thread) {
            mtx.lock();
                Book_elem book_elem = book[board];
            mtx.unlock();
            int8_t new_leaf_value = SCORE_UNDEFINED, new_leaf_move = MOVE_UNDEFINED;
            std::vector<Book_value> links = get_all_moves_with_value(&board);
            uint64_t remaining_legal = board.get_legal();
            for (Book_value &link: links)
                remaining_legal &= ~(1ULL << link.policy);
            if (remaining_legal) {
                Search_result ai_result = ai_legal(board, level, false, 0, use_multi_thread, false, remaining_legal);
                if (ai_result.value != SCORE_UNDEFINED) {
                    new_leaf_value = ai_result.value;
                    if (level == ADD_LEAF_SPECIAL_LEVEL)
                        new_leaf_value = book_elem.value;
                    new_leaf_move = ai_result.policy;
                }
            } else { 
                new_leaf_move = MOVE_NOMOVE;
            }
            
            add_leaf(&board, new_leaf_value, new_leaf_move, level);
        }

        void search_leaf(Board board, int level) {
            search_leaf(board, level, true);
        }

        void check_add_leaf_all_undefined() {
            std::vector<Board> boards;
            for (auto itr = book.begin(); itr != book.end(); ++itr) {
                boards.emplace_back(itr->first);
            }
            Flip flip;
            for (Board &board: boards) {
                int leaf_move = book[board].leaf.move;
                bool need_to_rewrite_leaf = leaf_move < 0 || MOVE_UNDEFINED <= leaf_move;
                if (!need_to_rewrite_leaf) {
                    calc_flip(&flip, &board, leaf_move);
                    board.move_board(&flip);
                        need_to_rewrite_leaf = contain(&board);
                    board.undo_board(&flip);
                }
                if (need_to_rewrite_leaf) {
                    int8_t new_leaf_value = SCORE_UNDEFINED, new_leaf_move = MOVE_UNDEFINED;
                    add_leaf(&board, new_leaf_value, new_leaf_move, LEVEL_UNDEFINED);
                }
            }
        }

        void check_add_leaf_all_search(int level, bool *stop) {
            std::vector<Board> boards;
            for (auto itr = book.begin(); itr != book.end(); ++itr) {
                boards.emplace_back(itr->first);
            }
            Flip flip;
            std::cerr << "add leaf to book" << std::endl;
            int percent = -1, t = 0, n_boards = (int)boards.size();
            Book_elem book_elem;
            std::vector<std::future<void>> tasks;
            int n_doing = 0, n_done = 0;
            for (Board &board: boards) {
                if (!global_searching || *stop) {
                    break;
                }
                int n_percent = (double)t++ / n_boards * 100;
                if (n_percent > percent) {
                    percent = n_percent;
                    std::cerr << "adding leaf " << percent << "%" << " n_recalculated " << n_done << std::endl;
                }
                book_elem = get(board);
                int leaf_move = book_elem.leaf.move;
                bool need_to_rewrite_leaf = leaf_move < 0 || MOVE_UNDEFINED <= leaf_move || (board.get_legal() & (1ULL << leaf_move)) == 0;
                if (!need_to_rewrite_leaf) {
                    calc_flip(&flip, &board, leaf_move);
                    board.move_board(&flip);
                        if (board.get_legal() == 0) {
                            board.pass();
                                need_to_rewrite_leaf = contain(&board);
                            board.pass();
                        } else {
                            need_to_rewrite_leaf = contain(&board);
                        }
                    board.undo_board(&flip);
                }
                if (need_to_rewrite_leaf) {
                    bool use_multi_thread = (n_boards - n_doing) < thread_pool.get_n_idle();
                    bool pushed;
                    ++n_doing;
                    tasks.emplace_back(thread_pool.push(&pushed, std::bind(&search_new_leaf, board, level, book_elem.value, use_multi_thread)));
                    if (!pushed) {
                        tasks.pop_back();
                        search_new_leaf(board, level, book_elem.value, true);
                        ++n_done;
                    }
                }
                int tasks_size = tasks.size();
                for (int i = 0; i < tasks_size; ++i) {
                    if (tasks[i].valid()) {
                        if (tasks[i].wait_for(std::chrono::seconds(0)) == std::future_status::ready) {
                            tasks[i].get();
                            ++n_done;
                        }
                    }
                }
                for (int i = 0; i < tasks_size; ++i) {
                    if (i >= tasks.size()) {
                        break;
                    }
                    if (!tasks[i].valid()) {
                        tasks.erase(tasks.begin() + i);
                        --i;
                    }
                }
            }
            int tasks_size = tasks.size();
            for (int i = 0; i < tasks_size; ++i) {
                if (tasks[i].valid()) {
                    tasks[i].get();
                    ++n_done;
                }
            }
            std::cerr << "leaf search finished" << std::endl;
        }

        void recalculate_leaf_all(int level, bool *stop) {
            std::vector<Board> boards;
            for (auto itr = book.begin(); itr != book.end(); ++itr) {
                boards.emplace_back(itr->first);
            }
            Flip flip;
            std::cerr << "add leaf to book" << std::endl;
            int percent = -1, t = 0, n_boards = (int)boards.size();
            for (Board &board: boards) {
                if (!global_searching || *stop) {
                    break;
                }
                int n_percent = (double)t / n_boards * 100;
                if (n_percent > percent) {
                    percent = n_percent;
                    std::cerr << "adding leaf " << percent << "%" << std::endl;
                }
                ++t;
                search_leaf(board, level);
            }
        }

        Book_info calculate_book_info(bool *calculating) {
            Book_info res;
            for (auto itr = book.begin(); itr != book.end() && *calculating; ++itr) {
                int level = itr->second.level;
                int ply = itr->first.n_discs() - 4;
                int leaf_level = itr->second.leaf.level;
                int leaf_ply = ply + 1;
                ++res.n_boards;
                if (0 <= level && level <= LEVEL_HUMAN) {
                    ++res.n_boards_in_level[level];
                }
                ++res.n_boards_in_ply[ply];
                if (0 <= leaf_level && leaf_level <= LEVEL_HUMAN) {
                    ++res.n_leaves_in_level[leaf_level];
                    ++res.n_leaves_in_ply[leaf_ply];
                }
            }
            return res;
        }

    private:
        void reg_first_board() {
            Board board;
            board.reset();
            Book_elem elem;
            elem.value = 0;
            elem.leaf.value = 0;
            elem.leaf.move = 19;
            book[board] = elem;
        }

        
        inline bool register_representative(Board b, Book_elem elem) {
            
            int f_size = book.size();
            book[b] = elem;
            return book.size() - f_size > 0;
        }

        
        inline bool delete_representative_board(Board b) {
            if (book.find(b) != book.end()) {
                book.erase(b);
                return true;
            }
            return false;
        }

        
        inline int register_symmetric_book(Board b, Book_elem elem) {
            int idx;
            Board representive_board = representative_board(b, &idx);
            if (elem.leaf.move != MOVE_UNDEFINED) {
                elem.leaf.move = convert_coord_to_representative_board(elem.leaf.move, idx);
            }
            return register_representative(representive_board, elem);
        }

        
        inline int delete_symmetric_book(Board b) {
            Board representive_board = representative_board(b);
            return delete_representative_board(representive_board);
        }

        inline int merge(Board b, Book_elem elem) {
            if (!contain(b)) {
                return register_symmetric_book(b, elem);
            }
            Book_elem book_elem = get(b);
            if (elem.value != SCORE_UNDEFINED && book_elem.level <= elem.level) {
                book_elem.value = elem.value;
                book_elem.level = elem.level;
            }
            if (elem.leaf.value != SCORE_UNDEFINED && book_elem.leaf.level <= elem.leaf.level) {
                book_elem.leaf.value = elem.leaf.value;
                book_elem.leaf.move = elem.leaf.move;
                book_elem.leaf.level = elem.leaf.level;
            }
            return register_symmetric_book(b, book_elem);
        }
};








Book book;

bool book_init(std::string file, bool show_log) {
    
    book_hash_init_rand();
    bool stop_loading = false;
    return book.init(file, show_log, &stop_loading);
}

bool book_init(std::string file, bool show_log, bool *stop_loading) {
    
    book_hash_init_rand();
    return book.init(file, show_log, stop_loading);
}

void book_save_as_egaroucid(std::string file, int level) {
    book.save_egbk3(file, level);
}

void book_save_as_edax(std::string file, int level) {
    book.save_bin_edax(file, level);
}

void book_fix(bool *stop) {
    book.fix(false, stop);
}

void book_fix_edax(bool *stop) {
    book.fix(true, stop);
}

void book_reduce(Board board, int depth, int max_error_per_move, int max_error_sum, bool *doing) {
    book.reduce_book(board, depth, max_error_per_move, max_error_sum, doing);
}

void book_recalculate_leaf_all(int level, bool *stop) {
    book.recalculate_leaf_all(level, stop);
}

void book_recalculate_n_lines_all(bool *stop) {
    Board root_board;
    root_board.reset();
    book.recalculate_n_lines(root_board, stop);
}

void book_upgrade_better_leaves_all(bool *stop) {
    Board root_board;
    root_board.reset();
    book.upgrade_better_leaves(root_board, stop);
}

void search_new_leaf(Board board, int level, int book_elem_value, bool use_multi_thread) {
    int8_t new_leaf_value = SCORE_UNDEFINED, new_leaf_move = MOVE_UNDEFINED;
    std::vector<Book_value> links = book.get_all_moves_with_value(&board);
    uint64_t legal = board.get_legal();
    for (Book_value &link: links) {
        legal &= ~(1ULL << link.policy);
    }
    if (legal) {
        int use_level = level;
        if (level == ADD_LEAF_SPECIAL_LEVEL) {
            use_level = 1;
        }
        Search_result ai_result = ai_legal(board, use_level, false, 0, use_multi_thread, false, legal);
        if (ai_result.value != SCORE_UNDEFINED) {
            new_leaf_value = ai_result.value;
            if (level == ADD_LEAF_SPECIAL_LEVEL) {
                new_leaf_value = book_elem_value;
            }
            new_leaf_move = ai_result.policy;
            
            
            
            
        }
    } else {
        new_leaf_move = MOVE_NOMOVE;
    }
    book.add_leaf(&board, new_leaf_value, new_leaf_move, level);
}

Book_info calculate_book_info(bool *calculating) {
    Book_info res = book.calculate_book_info(calculating);
    return res;
}

// ===== FILE: Egaroucid/src/engine/clogsearch.hpp =====



#pragma once
#include <iostream>
#include <algorithm>
#include <vector>
#include <future>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "search.hpp"
#include "thread_pool.hpp"
#include "util.hpp"
#include "stability.hpp"
#include "evaluate.hpp"
#include "level.hpp"
#include "transposition_table.hpp"
#include "move_ordering.hpp"

constexpr int CLOG_NOT_FOUND = -127;

constexpr int CLOG_SEARCH_MAX_DEPTH = 5;

#if USE_PARALLEL_CLOG_SEARCH

constexpr int CLOG_SEARCH_SPLIT_DEPTH = 2;


struct Parallel_clog_task {
    uint64_t n_nodes;
    int val;
};

int clog_search(Search *search, int depth, bool *searching);


Parallel_clog_task clog_do_task(uint64_t player, uint64_t opponent, int depth, bool *searching) {
    Search search(player, opponent, MPC_100_LEVEL, true, false);
    Parallel_clog_task task;
    task.val = clog_search(&search, depth, searching);
    task.n_nodes = search.n_nodes;
    return task;
}


inline bool clog_split(const Search *search, const int canput, const int pv_idx, int depth, bool *searching, std::vector<std::future<Parallel_clog_task>> &parallel_tasks) {
    if (thread_pool.get_n_idle() &&
        pv_idx < canput - 1 && 
        depth >= CLOG_SEARCH_SPLIT_DEPTH) {
            bool pushed;
            parallel_tasks.emplace_back(thread_pool.push(&pushed, std::bind(&clog_do_task, search->board.player, search->board.opponent, depth, searching)));
            if (!pushed) {
                parallel_tasks.pop_back();
            }
            return pushed;
    }
    return false;
}
#endif


int clog_search(Search *search, int depth, bool *searching) {
    if (!global_searching) {
        return CLOG_NOT_FOUND;
    }
    ++search->n_nodes;
    if (depth == 0) {
        if (search->board.is_end()) {
            return search->board.score_player();
        }
        return CLOG_NOT_FOUND;
    }
    int res = CLOG_NOT_FOUND;
    uint64_t legal = search->board.get_legal();
    if (legal == 0ULL) {
        search->pass();
            if (search->board.get_legal() == 0ULL) {
                res = search->board.score_player();
            } else{
                res = clog_search(search, depth, searching);
            }
        search->pass();
        if (res != CLOG_NOT_FOUND) {
            return -res;
        }
        return CLOG_NOT_FOUND;
    }
    const int canput = pop_count_ull(legal);
    std::vector<Flip_value> move_list(canput);
    int idx = 0;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&move_list[idx].flip, &search->board, cell);
        if (move_list[idx].flip.flip == search->board.opponent) {
            return SCORE_MAX;
        }
        ++idx;
    }
    uint_fast8_t moves[N_TRANSPOSITION_MOVES] = {MOVE_UNDEFINED, MOVE_UNDEFINED};
    transposition_table.get_moves_any_level(&search->board, search->board.hash(), moves);
    move_list_evaluate(search, move_list, moves, depth, -SCORE_MAX, SCORE_MAX, searching);
    int g;
    bool uncertain_value_found = false;
    int beta = HW2 - 2 * pop_count_ull(calc_stability(search->board.opponent, search->board.player));
#if USE_PARALLEL_CLOG_SEARCH
    std::vector<std::future<Parallel_clog_task>> parallel_tasks;
    bool n_searching = true;
    for (int move_idx = 0; move_idx < canput && res < beta && *searching; ++move_idx) {
        swap_next_best_move(move_list, move_idx, canput);
        search->move(&move_list[move_idx].flip);
            if (!clog_split(search, canput, move_idx, depth - 1, &n_searching, parallel_tasks)) {
                g = clog_search(search, depth - 1, searching);
                if (g != CLOG_NOT_FOUND) {
                    res = std::max(res, -g);
                } else {
                    uncertain_value_found = true;
                }
            }
        search->undo(&move_list[move_idx].flip);
    }
    if (res < beta && *searching) {
        Parallel_clog_task got_task;
        for (std::future<Parallel_clog_task> &task: parallel_tasks) {
            got_task = task.get();
            if (got_task.val != CLOG_NOT_FOUND) {
                res = std::max(res, -got_task.val);
            } else {
                uncertain_value_found = true;
            }
            search->n_nodes += got_task.n_nodes;
        }
    } else {
        n_searching = false;
        for (std::future<Parallel_clog_task> &task: parallel_tasks) {
            search->n_nodes += task.get().n_nodes;
        }
    }
#else
    for (int move_idx = 0; move_idx < canput && res < beta && *searching && global_searching; ++move_idx) {
        swap_next_best_move(move_list, move_idx, canput);
        search->move(&move_list[move_idx].flip);
            g = clog_search(search, depth - 1, searching);
        search->undo(&move_list[move_idx].flip);
        if (g != CLOG_NOT_FOUND) {
            res = std::max(res, -g);
        } else {
            uncertain_value_found = true;
        }
    }
#endif
    if (uncertain_value_found && res < beta) {
        res = CLOG_NOT_FOUND;
    }
    return res;
}


std::vector<Clog_result> first_clog_search(Board board, uint64_t *n_nodes, int depth, uint64_t legal, bool *searching) {
    Search search(&board, MPC_100_LEVEL, true, false);
    std::vector<Clog_result> res;
    Flip flip;
    int g;
    for (uint_fast8_t cell = first_bit(&legal); legal && *searching && global_searching; cell = next_bit(&legal)) {
        calc_flip(&flip, &search.board, cell);
        search.move(&flip);
            g = clog_search(&search, depth - 1, searching);
            if (g != CLOG_NOT_FOUND) {
                Clog_result result;
                result.pos = cell;
                result.val = -g;
                res.emplace_back(result);
            }
        search.undo(&flip);
    }
    *n_nodes = search.n_nodes;
    return res;
}

// ===== FILE: Egaroucid/src/engine/common_b1.hpp =====

#pragma once
#include <iostream>
#include <sstream>
#include <iomanip>
#include <fstream>
#include <time.h>
#include <chrono>
#include <random>
#include <string>
#include "setting.hpp"


constexpr int HW_B1 = 8;
constexpr int HW_M1_B1 = 7;
constexpr int HW_P1_B1 = 9;
constexpr int HW2_B1 = 64;
constexpr int HW2_M1_B1 = 63;
constexpr int HW2_P1_B1 = 65;
constexpr int N_INVALID_B1 = 16;
constexpr int N_ACTIVE_SQUARES_B1 = HW2_B1 - N_INVALID_B1; 

constexpr int BLACK_B1 = 0;
constexpr int WHITE_B1 = 1;
constexpr int VACANT_B1 = 2;


constexpr int N_8BIT_B1 = 256;
constexpr int N_16BIT_B1 = 65536;
constexpr int INF_B1 = 100000000;
constexpr int SCORE_INF_B1 = 127;
constexpr int SCORE_MAX_B1 = 48;


constexpr uint64_t LEGAL_UNDEFINED_B1 = 0x0000001818000000ULL;


constexpr uint64_t INVALID_MASK_B1 = 0xC3C300000000C3C3ULL;


constexpr int N_CELL_TYPE_B1 = 10;
constexpr uint64_t cell_type_mask_b1[N_CELL_TYPE_B1] = {
    0x2400810000810024ULL & ~INVALID_MASK_B1,
    0x4281000000008142ULL & ~INVALID_MASK_B1,
    0x2400810000810024ULL & ~INVALID_MASK_B1,
    0x1800008181000018ULL & ~INVALID_MASK_B1,
    0x0042000000004200ULL & ~INVALID_MASK_B1,
    0x0024420000422400ULL & ~INVALID_MASK_B1,
    0x0018004242001800ULL & ~INVALID_MASK_B1,
    0x0000240000240000ULL & ~INVALID_MASK_B1,
    0x0000182424180000ULL & ~INVALID_MASK_B1,
    0x0000001818000000ULL & ~INVALID_MASK_B1
};

constexpr int cell_type_b1[HW2_B1] = {
    0, 1, 2, 3, 3, 2, 1, 0,
    1, 4, 5, 6, 6, 5, 4, 1,
    2, 5, 7, 8, 8, 7, 5, 2,
    3, 6, 8, 9, 9, 8, 6, 3,
    3, 6, 8, 9, 9, 8, 6, 3,
    2, 5, 7, 8, 8, 7, 5, 2,
    1, 4, 5, 6, 6, 5, 4, 1,
    0, 1, 2, 3, 3, 2, 1, 0
};


constexpr uint64_t bit_around_b1[HW2_B1] = {
    0x0000000000000302ULL, 0x0000000000000604ULL, 0x0000000000000e0aULL, 0x0000000000001c14ULL, 0x0000000000003828ULL, 0x0000000000007050ULL, 0x0000000000006020ULL, 0x000000000000c040ULL,
    0x0000000000030200ULL, 0x0000000000060400ULL, 0x00000000000e0a00ULL, 0x00000000001c1400ULL, 0x0000000000382800ULL, 0x0000000000705000ULL, 0x0000000000602000ULL, 0x0000000000c04000ULL,
    0x0000000003020300ULL, 0x0000000006040600ULL, 0x000000000e0a0e00ULL, 0x000000001c141c00ULL, 0x0000000038283800ULL, 0x0000000070507000ULL, 0x0000000060206000ULL, 0x00000000c040c000ULL,
    0x0000000302030000ULL, 0x0000000604060000ULL, 0x0000000e0a0e0000ULL, 0x0000001c141c0000ULL, 0x0000003828380000ULL, 0x0000007050700000ULL, 0x0000006020600000ULL, 0x000000c040c00000ULL,
    0x0000030203000000ULL, 0x0000060406000000ULL, 0x00000e0a0e000000ULL, 0x00001c141c000000ULL, 0x0000382838000000ULL, 0x0000705070000000ULL, 0x0000602060000000ULL, 0x0000c040c0000000ULL,
    0x0003020300000000ULL, 0x0006040600000000ULL, 0x000e0a0e00000000ULL, 0x001c141c00000000ULL, 0x0038283800000000ULL, 0x0070507000000000ULL, 0x0060206000000000ULL, 0x00c040c000000000ULL,
    0x0002030000000000ULL, 0x0004060000000000ULL, 0x000a0e0000000000ULL, 0x00141c0000000000ULL, 0x0028380000000000ULL, 0x0050700000000000ULL, 0x0020600000000000ULL, 0x0040c00000000000ULL,
    0x0203000000000000ULL, 0x0406000000000000ULL, 0x0a0e000000000000ULL, 0x141c000000000000ULL, 0x2838000000000000ULL, 0x5070000000000000ULL, 0x2060000000000000ULL, 0x40c0000000000000ULL
};


constexpr uint64_t bit_radiation_b1[HW2_B1] = {
    0x81412111090503FEULL, 0x02824222120A07FDULL, 0x0404844424150EFBULL, 0x08080888492A1CF7ULL, 0x10101011925438EFULL, 0x2020212224A870DFULL, 0x404142444850E0BFULL, 0x8182848890A0C07FULL, 
    0x412111090503FE03ULL, 0x824222120A07FD07ULL, 0x04844424150EFB0EULL, 0x080888492A1CF71CULL, 0x101011925438EF38ULL, 0x20212224A870DF70ULL, 0x4142444850E0BFE0ULL, 0x82848890A0C07FC0ULL, 
    0x2111090503FE0305ULL, 0x4222120A07FD070AULL, 0x844424150EFB0E15ULL, 0x0888492A1CF71C2AULL, 0x1011925438EF3854ULL, 0x212224A870DF70A8ULL, 0x42444850E0BFE050ULL, 0x848890A0C07FC0A0ULL,
    0x11090503FE030509ULL, 0x22120A07FD070A12ULL, 0x4424150EFB0E1524ULL, 0x88492A1CF71C2A49ULL, 0x11925438EF385492ULL, 0x2224A870DF70A824ULL, 0x444850E0BFE05048ULL, 0x8890A0C07FC0A090ULL,
    0x090503FE03050911ULL, 0x120A07FD070A1222ULL, 0x24150EFB0E152444ULL, 0x492A1CF71C2A4988ULL, 0x925438EF38549211ULL, 0x24A870DF70A82422ULL, 0x4850E0BFE0504844ULL, 0x90A0C07FC0A09088ULL,
    0x0503FE0305091121ULL, 0x0A07FD070A122242ULL, 0x150EFB0E15244484ULL, 0x2A1CF71C2A498808ULL, 0x5438EF3854921110ULL, 0xA870DF70A8242221ULL, 0x50E0BFE050484442ULL, 0xA0C07FC0A0908884ULL,
    0x03FE030509112141ULL, 0x07FD070A12224282ULL, 0x0EFB0E1524448404ULL, 0x1CF71C2A49880808ULL, 0x38EF385492111010ULL, 0x70DF70A824222120ULL, 0xE0BFE05048444241ULL, 0xC07FC0A090888482ULL,
    0xFE03050911214181ULL, 0xFD070A1222428202ULL, 0xFB0E152444840404ULL, 0xF71C2A4988080808ULL, 0xEF38549211101010ULL, 0xDF70A82422212020ULL, 0xBFE0504844424140ULL, 0x7FC0A09088848281ULL
};

constexpr uint64_t bit_up_b1[HW2_B1] = {
    0x0101010101010100ULL, 0x0202020202020200ULL, 0x0404040404040400ULL, 0x0808080808080800ULL, 0x1010101010101000ULL, 0x2020202020202000ULL, 0x4040404040404000ULL, 0x8080808080808000ULL,
    0x0101010101010000ULL, 0x0202020202020000ULL, 0x0404040404040000ULL, 0x0808080808080000ULL, 0x1010101010100000ULL, 0x2020202020200000ULL, 0x4040404040400000ULL, 0x8080808080800000ULL,
    0x0101010101000000ULL, 0x0202020202000000ULL, 0x0404040404000000ULL, 0x0808080808000000ULL, 0x1010101010000000ULL, 0x2020202020000000ULL, 0x4040404040000000ULL, 0x8080808080000000ULL,
    0x0101010100000000ULL, 0x0202020200000000ULL, 0x0404040400000000ULL, 0x0808080800000000ULL, 0x1010101000000000ULL, 0x2020202000000000ULL, 0x4040404000000000ULL, 0x8080808000000000ULL,
    0x0101010000000000ULL, 0x0202020000000000ULL, 0x0404040000000000ULL, 0x0808080000000000ULL, 0x1010100000000000ULL, 0x2020200000000000ULL, 0x4040400000000000ULL, 0x8080800000000000ULL,
    0x0101000000000000ULL, 0x0202000000000000ULL, 0x0404000000000000ULL, 0x0808000000000000ULL, 0x1010000000000000ULL, 0x2020000000000000ULL, 0x4040000000000000ULL, 0x8080000000000000ULL,
    0x0100000000000000ULL, 0x0200000000000000ULL, 0x0400000000000000ULL, 0x0800000000000000ULL, 0x1000000000000000ULL, 0x2000000000000000ULL, 0x4000000000000000ULL, 0x8000000000000000ULL,
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_down_b1[HW2_B1] = {
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0000000000000001ULL, 0x0000000000000002ULL, 0x0000000000000004ULL, 0x0000000000000008ULL, 0x0000000000000010ULL, 0x0000000000000020ULL, 0x0000000000000040ULL, 0x0000000000000080ULL,
    0x0000000000000101ULL, 0x0000000000000202ULL, 0x0000000000000404ULL, 0x0000000000000808ULL, 0x0000000000001010ULL, 0x0000000000002020ULL, 0x0000000000004040ULL, 0x0000000000008080ULL,
    0x0000000000010101ULL, 0x0000000000020202ULL, 0x0000000000040404ULL, 0x0000000000080808ULL, 0x0000000000101010ULL, 0x0000000000202020ULL, 0x0000000000404040ULL, 0x0000000000808080ULL,
    0x0000000001010101ULL, 0x0000000002020202ULL, 0x0000000004040404ULL, 0x0000000008080808ULL, 0x0000000010101010ULL, 0x0000000020202020ULL, 0x0000000040404040ULL, 0x0000000080808080ULL,
    0x0000000101010101ULL, 0x0000000202020202ULL, 0x0000000404040404ULL, 0x0000000808080808ULL, 0x0000001010101010ULL, 0x0000002020202020ULL, 0x0000004040404040ULL, 0x0000008080808080ULL,
    0x0000010101010101ULL, 0x0000020202020202ULL, 0x0000040404040404ULL, 0x0000080808080808ULL, 0x0000101010101010ULL, 0x0000202020202020ULL, 0x0000404040404040ULL, 0x0000808080808080ULL,
    0x0001010101010101ULL, 0x0002020202020202ULL, 0x0004040404040404ULL, 0x0008080808080808ULL, 0x0010101010101010ULL, 0x0020202020202020ULL, 0x0040404040404040ULL, 0x0080808080808080ULL
};

constexpr uint64_t bit_d7up_b1[HW2_B1] = {
    0x0000000000000000ULL, 0x0000000000000100ULL, 0x0000000000010200ULL, 0x0000000001020400ULL, 0x0000000102040800ULL, 0x0000010204081000ULL, 0x0001020408102000ULL, 0x0102040810204000ULL,
    0x0000000000000000ULL, 0x0000000000010000ULL, 0x0000000001020000ULL, 0x0000000102040000ULL, 0x0000010204080000ULL, 0x0001020408100000ULL, 0x0102040810200000ULL, 0x0204081020400000ULL,
    0x0000000000000000ULL, 0x0000000001000000ULL, 0x0000000102000000ULL, 0x0000010204000000ULL, 0x0001020408000000ULL, 0x0102040810000000ULL, 0x0204081020000000ULL, 0x0408102040000000ULL,
    0x0000000000000000ULL, 0x0000000100000000ULL, 0x0000010200000000ULL, 0x0001020400000000ULL, 0x0102040800000000ULL, 0x0204081000000000ULL, 0x0408102000000000ULL, 0x0810204000000000ULL,
    0x0000000000000000ULL, 0x0000010000000000ULL, 0x0001020000000000ULL, 0x0102040000000000ULL, 0x0204080000000000ULL, 0x0408100000000000ULL, 0x0810200000000000ULL, 0x1020400000000000ULL,
    0x0000000000000000ULL, 0x0001000000000000ULL, 0x0102000000000000ULL, 0x0204000000000000ULL, 0x0408000000000000ULL, 0x0810000000000000ULL, 0x1020000000000000ULL, 0x2040000000000000ULL,
    0x0000000000000000ULL, 0x0100000000000000ULL, 0x0200000000000000ULL, 0x0400000000000000ULL, 0x0800000000000000ULL, 0x1000000000000000ULL, 0x2000000000000000ULL, 0x4000000000000000ULL,
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_d7down_b1[HW2_B1] = {
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0000000000000002ULL, 0x0000000000000004ULL, 0x0000000000000008ULL, 0x0000000000000010ULL, 0x0000000000000020ULL, 0x0000000000000040ULL, 0x0000000000000080ULL, 0x0000000000000000ULL,
    0x0000000000000204ULL, 0x0000000000000408ULL, 0x0000000000000810ULL, 0x0000000000001020ULL, 0x0000000000002040ULL, 0x0000000000004080ULL, 0x0000000000008000ULL, 0x0000000000000000ULL,
    0x0000000000020408ULL, 0x0000000000040810ULL, 0x0000000000081020ULL, 0x0000000000102040ULL, 0x0000000000204080ULL, 0x0000000000408000ULL, 0x0000000000800000ULL, 0x0000000000000000ULL,
    0x0000000002040810ULL, 0x0000000004081020ULL, 0x0000000008102040ULL, 0x0000000010204080ULL, 0x0000000020408000ULL, 0x0000000040800000ULL, 0x0000000080000000ULL, 0x0000000000000000ULL,
    0x0000000204081020ULL, 0x0000000408102040ULL, 0x0000000810204080ULL, 0x0000001020408000ULL, 0x0000002040800000ULL, 0x0000004080000000ULL, 0x0000008000000000ULL, 0x0000000000000000ULL,
    0x0000020408102040ULL, 0x0000040810204080ULL, 0x0000081020408000ULL, 0x0000102040800000ULL, 0x0000204080000000ULL, 0x0000408000000000ULL, 0x0000800000000000ULL, 0x0000000000000000ULL,
    0x0002040810204080ULL, 0x0004081020408000ULL, 0x0008102040800000ULL, 0x0010204080000000ULL, 0x0020408000000000ULL, 0x0040800000000000ULL, 0x0080000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_d9up_b1[HW2_B1] = {
    0x8040201008040200ULL, 0x0080402010080400ULL, 0x0000804020100800ULL, 0x0000008040201000ULL, 0x0000000080402000ULL, 0x0000000000804000ULL, 0x0000000000008000ULL, 0x0000000000000000ULL,
    0x4020100804020000ULL, 0x8040201008040000ULL, 0x0080402010080000ULL, 0x0000804020100000ULL, 0x0000008040200000ULL, 0x0000000080400000ULL, 0x0000000000800000ULL, 0x0000000000000000ULL,
    0x2010080402000000ULL, 0x4020100804000000ULL, 0x8040201008000000ULL, 0x0080402010000000ULL, 0x0000804020000000ULL, 0x0000008040000000ULL, 0x0000000080000000ULL, 0x0000000000000000ULL,
    0x1008040200000000ULL, 0x2010080400000000ULL, 0x4020100800000000ULL, 0x8040201000000000ULL, 0x0080402000000000ULL, 0x0000804000000000ULL, 0x0000008000000000ULL, 0x0000000000000000ULL,
    0x0804020000000000ULL, 0x1008040000000000ULL, 0x2010080000000000ULL, 0x4020100000000000ULL, 0x8040200000000000ULL, 0x0080400000000000ULL, 0x0000800000000000ULL, 0x0000000000000000ULL,
    0x0402000000000000ULL, 0x0804000000000000ULL, 0x1008000000000000ULL, 0x2010000000000000ULL, 0x4020000000000000ULL, 0x8040000000000000ULL, 0x0080000000000000ULL, 0x0000000000000000ULL,
    0x0200000000000000ULL, 0x0400000000000000ULL, 0x0800000000000000ULL, 0x1000000000000000ULL, 0x2000000000000000ULL, 0x4000000000000000ULL, 0x8000000000000000ULL, 0x0000000000000000ULL,
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_left_b1[HW2_B1] = {
    0x00000000000000FEULL, 0x00000000000000FCULL, 0x00000000000000F8ULL, 0x00000000000000F0ULL, 0x00000000000000E0ULL, 0x00000000000000C0ULL, 0x0000000000000080ULL, 0x0000000000000000ULL, 
    0x000000000000FE00ULL, 0x000000000000FC00ULL, 0x000000000000F800ULL, 0x000000000000F000ULL, 0x000000000000E000ULL, 0x000000000000C000ULL, 0x0000000000008000ULL, 0x0000000000000000ULL, 
    0x0000000000FE0000ULL, 0x0000000000FC0000ULL, 0x0000000000F80000ULL, 0x0000000000F00000ULL, 0x0000000000E00000ULL, 0x0000000000C00000ULL, 0x0000000000800000ULL, 0x0000000000000000ULL,
    0x00000000FE000000ULL, 0x00000000FC000000ULL, 0x00000000F8000000ULL, 0x00000000F0000000ULL, 0x00000000E0000000ULL, 0x00000000C0000000ULL, 0x0000000080000000ULL, 0x0000000000000000ULL,
    0x000000FE00000000ULL, 0x000000FC00000000ULL, 0x000000F800000000ULL, 0x000000F000000000ULL, 0x000000E000000000ULL, 0x000000C000000000ULL, 0x0000008000000000ULL, 0x0000000000000000ULL,
    0x0000FE0000000000ULL, 0x0000FC0000000000ULL, 0x0000F80000000000ULL, 0x0000F00000000000ULL, 0x0000E00000000000ULL, 0x0000C00000000000ULL, 0x0000800000000000ULL, 0x0000000000000000ULL,
    0x00FE000000000000ULL, 0x00FC000000000000ULL, 0x00F8000000000000ULL, 0x00F0000000000000ULL, 0x00E0000000000000ULL, 0x00C0000000000000ULL, 0x0080000000000000ULL, 0x0000000000000000ULL,
    0xFE00000000000000ULL, 0xFC00000000000000ULL, 0xF800000000000000ULL, 0xF000000000000000ULL, 0xE000000000000000ULL, 0xC000000000000000ULL, 0x8000000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_right_b1[HW2_B1] = {
    0x0000000000000000ULL, 0x0000000000000001ULL, 0x0000000000000003ULL, 0x0000000000000007ULL, 0x000000000000000FULL, 0x000000000000001FULL, 0x000000000000003FULL, 0x000000000000007FULL,
    0x0000000000000000ULL, 0x0000000000000100ULL, 0x0000000000000300ULL, 0x0000000000000700ULL, 0x0000000000000F00ULL, 0x0000000000001F00ULL, 0x0000000000003F00ULL, 0x0000000000007F00ULL,
    0x0000000000000000ULL, 0x0000000000010000ULL, 0x0000000000030000ULL, 0x0000000000070000ULL, 0x00000000000F0000ULL, 0x00000000001F0000ULL, 0x00000000003F0000ULL, 0x00000000007F0000ULL,
    0x0000000000000000ULL, 0x0000000001000000ULL, 0x0000000003000000ULL, 0x0000000007000000ULL, 0x000000000F000000ULL, 0x000000001F000000ULL, 0x000000003F000000ULL, 0x000000007F000000ULL,
    0x0000000000000000ULL, 0x0000000100000000ULL, 0x0000000300000000ULL, 0x0000000700000000ULL, 0x0000000F00000000ULL, 0x0000001F00000000ULL, 0x0000003F00000000ULL, 0x0000007F00000000ULL,
    0x0000000000000000ULL, 0x0000010000000000ULL, 0x0000030000000000ULL, 0x0000070000000000ULL, 0x00000F0000000000ULL, 0x00001F0000000000ULL, 0x00003F0000000000ULL, 0x00007F0000000000ULL,
    0x0000000000000000ULL, 0x0001000000000000ULL, 0x0003000000000000ULL, 0x0007000000000000ULL, 0x000F000000000000ULL, 0x001F000000000000ULL, 0x003F000000000000ULL, 0x007F000000000000ULL,
    0x0000000000000000ULL, 0x0100000000000000ULL, 0x0300000000000000ULL, 0x0700000000000000ULL, 0x0F00000000000000ULL, 0x1F00000000000000ULL, 0x3F00000000000000ULL, 0x7F00000000000000ULL
};


bool global_searching_b1 = true;


inline uint64_t tim_b1() {
    return std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::high_resolution_clock::now().time_since_epoch()
    ).count();
}

std::mt19937 raw_myrandom_b1(tim_b1());

inline double myrandom_b1() {
    return (double)raw_myrandom_b1() / std::mt19937::max();
}

inline int32_t myrandrange_b1(int32_t s, int32_t e) {
    return s + (int)((e - s) * myrandom_b1());
}

inline uint32_t myrand_uint_b1() {
    return (uint32_t)raw_myrandom_b1();
}

inline uint32_t myrand_uint_rev_b1() {
    uint32_t x = raw_myrandom_b1();
    x = ((x & 0x55555555U) << 1) | ((x & 0xAAAAAAAAU) >> 1);
    x = ((x & 0x33333333U) << 2) | ((x & 0xCCCCCCCCU) >> 2);
    x = ((x & 0x0F0F0F0FU) << 4) | ((x & 0xF0F0F0F0U) >> 4);
    x = ((x & 0x00FF00FFU) << 8) | ((x & 0xFF00FF00U) >> 8);
    return ((x & 0x0000FFFFU) << 16) | ((x & 0xFFFF0000U) >> 16);
}

inline uint64_t myrand_ull_b1() {
    return ((uint64_t)raw_myrandom_b1() << 32) | (uint64_t)raw_myrandom_b1();
}

inline bool file_open_b1(FILE **fp, const char *file, const char *mode) {
#ifdef _WIN64
    return fopen_s(fp, file, mode) == 0;
#elif _WIN32
    return fopen_s(fp, file, mode) == 0;
#else
    *fp = fopen(file, mode);
    return *fp != NULL;
#endif
}

inline uint64_t calc_nps_b1(uint64_t n_nodes, uint64_t elapsed) {
    if (elapsed == 0ULL) elapsed = 1ULL;
    return n_nodes * 1000ULL / elapsed;
}

int get_localtime_b1(tm* a, time_t* b) {
#if _WIN64 || _WIN32
    return localtime_s(a, b);
#else
    a = localtime(b);
    return 0;
#endif
}

inline std::string calc_date_b1() {
    time_t now;
    tm newtime;
    time(&now);
    get_localtime_b1(&newtime, &now);
    std::stringstream sout;
    std::string year = std::to_string(newtime.tm_year + 1900);
    sout << std::setfill('0') << std::setw(2) << newtime.tm_mon + 1;
    std::string month = sout.str(); sout.str(""); sout.clear();
    sout << std::setfill('0') << std::setw(2) << newtime.tm_mday;
    std::string day = sout.str(); sout.str(""); sout.clear();
    sout << std::setfill('0') << std::setw(2) << newtime.tm_hour;
    std::string hour = sout.str(); sout.str(""); sout.clear();
    sout << std::setfill('0') << std::setw(2) << newtime.tm_min;
    std::string minute = sout.str(); sout.str(""); sout.clear();
    sout << std::setfill('0') << std::setw(2) << newtime.tm_sec;
    std::string second = sout.str();
    return year + "_" + month + "_" + day + "_" + hour + "_" + minute + "_" + second;
}

inline void calc_date_b1(int *year, int *month, int *day, int *hour, int *minute, int *second) {
    time_t now;
    tm newtime;
    time(&now);
    get_localtime_b1(&newtime, &now);
    *year = newtime.tm_year + 1900;
    *month = newtime.tm_mon + 1;
    *day = newtime.tm_mday;
    *hour = newtime.tm_hour;
    *minute = newtime.tm_min;
    *second = newtime.tm_sec;
}

inline bool is_valid_policy_b1(int policy) {
    return 0 <= policy && policy < HW2;
}

inline bool is_valid_score_b1(int score) {
    return -SCORE_MAX <= score && score <= SCORE_MAX;
}

inline bool is_black_like_char_b1(char c) {
    return c == 'B' || c == 'b' || c == 'X' || c == 'x' || c == '0' || c == '*';
}

inline bool is_white_like_char_b1(char c) {
    return c == 'W' || c == 'w' || c == 'O' || c == 'o' || c == '1';
}
inline bool is_vacant_like_char_b1(char c) {
    return c == '-' || c == '.';
}

inline bool is_pass_like_str_b1(std::string s) {
    return s == "PA" || s == "pa" || s == "PS" || s == "ps";
}

inline int get_coord_from_chars_b1(char c1, char c2) {
    c1 = c1 | 0x20;
    int y = c2 - '1';
    int x = c1 - 'a';
    return HW2_M1_B1 - (y * HW_B1 + x);
}

inline std::string idx_to_coord_b1(int idx) {
    if (idx < 0 || HW2_B1 <= idx)
        return "??";
    int y = HW_M1_B1 - idx / HW_B1;
    int x = HW_M1_B1 - idx % HW_B1;
    const std::string x_coord = "abcdefgh";
    return x_coord[x] + std::to_string(y + 1);
}

inline std::string ms_to_time_b1(uint64_t t) {
    std::string res;
    uint64_t hour = t / (1000 * 60 * 60);
    t %= 1000 * 60 * 60;
    uint64_t minute = t / (1000 * 60);
    t %= 1000 * 60;
    uint64_t second = t / 1000;
    uint64_t msecond = t % 1000;
    std::ostringstream hour_s;
    hour_s << std::right << std::setw(3) << std::setfill('0') << hour;
    res += hour_s.str();
    res += ":";
    std::ostringstream minute_s;
    minute_s << std::right << std::setw(2) << std::setfill('0') << minute;
    res += minute_s.str();
    res += ":";
    std::ostringstream second_s;
    second_s << std::right << std::setw(2) << std::setfill('0') << second;
    res += second_s.str();
    res += ".";
    std::ostringstream msecond_s;
    msecond_s << std::right << std::setw(3) << std::setfill('0') << msecond;
    res += msecond_s.str();
    return res;
}

inline std::string ms_to_time_short_b1(uint64_t t) {
    std::string res;
    uint64_t hour = t / (1000 * 60 * 60);
    t -= hour * 1000 * 60 * 60;
    uint64_t minute = t / (1000 * 60);
    t -= minute * 1000 * 60;
    uint64_t second = t / 1000;
    t -= second * 1000;
    std::ostringstream hour_s;
    hour_s << std::right << std::setw(3) << std::setfill('0') << hour;
    res += hour_s.str();
    res += ":";
    std::ostringstream minute_s;
    minute_s << std::right << std::setw(2) << std::setfill('0') << minute;
    res += minute_s.str();
    res += ":";
    std::ostringstream second_s;
    second_s << std::right << std::setw(2) << std::setfill('0') << second;
    res += second_s.str();
    return res;
}

// ===== FILE: Egaroucid/src/engine/common_b2.hpp =====

#pragma once
#include <iostream>
#include <sstream>
#include <iomanip>
#include <fstream>
#include <time.h>
#include <chrono>
#include <random>
#include <string>
#include "setting.hpp"


constexpr int HW_B2 = 8;
constexpr int HW_M1_B2 = 7;
constexpr int HW_P1_B2 = 9;
constexpr int HW2_B2 = 64;
constexpr int HW2_M1_B2 = 63;
constexpr int HW2_P1_B2 = 65;
constexpr int N_INVALID_B2 = 4;
constexpr int N_ACTIVE_SQUARES_B2 = HW2_B2 - N_INVALID_B2; 

constexpr int BLACK_B2 = 0;
constexpr int WHITE_B2 = 1;
constexpr int VACANT_B2 = 2;


constexpr int N_8BIT_B2 = 256;
constexpr int N_16BIT_B2 = 65536;
constexpr int INF_B2 = 100000000;
constexpr int SCORE_INF_B2 = 127;
constexpr int SCORE_MAX_B2 = 60;


constexpr uint64_t LEGAL_UNDEFINED_B2 = 0x0000001818000000ULL;


constexpr uint64_t INVALID_MASK_B2 = 0x0042000000004200ULL;


constexpr int N_CELL_TYPE_B2 = 10;
constexpr uint64_t cell_type_mask_b2[N_CELL_TYPE_B2] = {
    0x8100000000000081ULL & ~INVALID_MASK_B2,
    0x4281000000008142ULL & ~INVALID_MASK_B2,
    0x2400810000810024ULL & ~INVALID_MASK_B2,
    0x1800008181000018ULL & ~INVALID_MASK_B2,
    0x0042000000004200ULL & ~INVALID_MASK_B2,
    0x0024420000422400ULL & ~INVALID_MASK_B2,
    0x0018004242001800ULL & ~INVALID_MASK_B2,
    0x0000240000240000ULL & ~INVALID_MASK_B2,
    0x0000182424180000ULL & ~INVALID_MASK_B2,
    0x0000001818000000ULL & ~INVALID_MASK_B2
};

constexpr int cell_type_b2[HW2_B2] = {
    0, 1, 2, 3, 3, 2, 1, 0,
    1, 4, 5, 6, 6, 5, 4, 1,
    2, 5, 7, 8, 8, 7, 5, 2,
    3, 6, 8, 9, 9, 8, 6, 3,
    3, 6, 8, 9, 9, 8, 6, 3,
    2, 5, 7, 8, 8, 7, 5, 2,
    1, 4, 5, 6, 6, 5, 4, 1,
    0, 1, 2, 3, 3, 2, 1, 0
};
constexpr uint64_t bit_around_b2[64] = {
    0x0000000000000302ULL, 0x0000000000000604ULL, 0x0000000000000e0aULL, 0x0000000000001c14ULL, 0x0000000000003828ULL, 0x0000000000007050ULL, 0x0000000000006020ULL, 0x000000000000c040ULL,
    0x0000000000030200ULL, 0x0000000000060400ULL, 0x00000000000e0a00ULL, 0x00000000001c1400ULL, 0x0000000000382800ULL, 0x0000000000705000ULL, 0x0000000000602000ULL, 0x0000000000c04000ULL,
    0x0000000003020300ULL, 0x0000000006040600ULL, 0x000000000e0a0e00ULL, 0x000000001c141c00ULL, 0x0000000038283800ULL, 0x0000000070507000ULL, 0x0000000060206000ULL, 0x00000000c040c000ULL,
    0x0000000302030000ULL, 0x0000000604060000ULL, 0x0000000e0a0e0000ULL, 0x0000001c141c0000ULL, 0x0000003828380000ULL, 0x0000007050700000ULL, 0x0000006020600000ULL, 0x000000c040c00000ULL,
    0x0000030203000000ULL, 0x0000060406000000ULL, 0x00000e0a0e000000ULL, 0x00001c141c000000ULL, 0x0000382838000000ULL, 0x0000705070000000ULL, 0x0000602060000000ULL, 0x0000c040c0000000ULL,
    0x0003020300000000ULL, 0x0006040600000000ULL, 0x000e0a0e00000000ULL, 0x001c141c00000000ULL, 0x0038283800000000ULL, 0x0070507000000000ULL, 0x0060206000000000ULL, 0x00c040c000000000ULL,
    0x0002030000000000ULL, 0x0004060000000000ULL, 0x000a0e0000000000ULL, 0x00141c0000000000ULL, 0x0028380000000000ULL, 0x0050700000000000ULL, 0x0020600000000000ULL, 0x0040c00000000000ULL,
    0x0203000000000000ULL, 0x0406000000000000ULL, 0x0a0e000000000000ULL, 0x141c000000000000ULL, 0x2838000000000000ULL, 0x5070000000000000ULL, 0x2060000000000000ULL, 0x40c0000000000000ULL
};

constexpr uint64_t bit_radiation_b2[64] = {
    0x81412111090503FEULL, 0x02824222120A07FDULL, 0x0404844424150EFBULL, 0x08080888492A1CF7ULL, 0x10101011925438EFULL, 0x2020212224A870DFULL, 0x404142444850E0BFULL, 0x8182848890A0C07FULL,
    0x412111090503FE03ULL, 0x824222120A07FD07ULL, 0x04844424150EFB0EULL, 0x080888492A1CF71CULL, 0x101011925438EF38ULL, 0x20212224A870DF70ULL, 0x4142444850E0BFE0ULL, 0x82848890A0C07FC0ULL,
    0x2111090503FE0305ULL, 0x4222120A07FD070AULL, 0x844424150EFB0E15ULL, 0x0888492A1CF71C2AULL, 0x1011925438EF3854ULL, 0x212224A870DF70A8ULL, 0x42444850E0BFE050ULL, 0x848890A0C07FC0A0ULL,
    0x11090503FE030509ULL, 0x22120A07FD070A12ULL, 0x4424150EFB0E1524ULL, 0x88492A1CF71C2A49ULL, 0x11925438EF385492ULL, 0x2224A870DF70A824ULL, 0x444850E0BFE05048ULL, 0x8890A0C07FC0A090ULL,
    0x090503FE03050911ULL, 0x120A07FD070A1222ULL, 0x24150EFB0E152444ULL, 0x492A1CF71C2A4988ULL, 0x925438EF38549211ULL, 0x24A870DF70A82422ULL, 0x4850E0BFE0504844ULL, 0x90A0C07FC0A09088ULL,
    0x0503FE0305091121ULL, 0x0A07FD070A122242ULL, 0x150EFB0E15244484ULL, 0x2A1CF71C2A498808ULL, 0x5438EF3854921110ULL, 0xA870DF70A8242221ULL, 0x50E0BFE050484442ULL, 0xA0C07FC0A0908884ULL,
    0x03FE030509112141ULL, 0x07FD070A12224282ULL, 0x0EFB0E1524448404ULL, 0x1CF71C2A49880808ULL, 0x38EF385492111010ULL, 0x70DF70A824222120ULL, 0xE0BFE05048444241ULL, 0xC07FC0A090888482ULL,
    0xFE03050911214181ULL, 0xFD070A1222428202ULL, 0xFB0E152444840404ULL, 0xF71C2A4988080808ULL, 0xEF38549211101010ULL, 0xDF70A82422212020ULL, 0xBFE0504844424140ULL, 0x7FC0A09088848281ULL
};

constexpr uint64_t bit_left_b2[64] = {

    0x00000000000000FEULL, 0x00000000000000FCULL, 0x00000000000000F8ULL, 0x00000000000000F0ULL, 0x00000000000000E0ULL, 0x00000000000000C0ULL, 0x0000000000000080ULL, 0x0000000000000000ULL,
    0x000000000000FE00ULL, 0x000000000000FC00ULL, 0x000000000000F800ULL, 0x000000000000F000ULL, 0x000000000000E000ULL, 0x000000000000C000ULL, 0x0000000000008000ULL, 0x0000000000000000ULL,
    0x0000000000FE0000ULL, 0x0000000000FC0000ULL, 0x0000000000F80000ULL, 0x0000000000F00000ULL, 0x0000000000E00000ULL, 0x0000000000C00000ULL, 0x0000000000800000ULL, 0x0000000000000000ULL,
    0x00000000FE000000ULL, 0x00000000FC000000ULL, 0x00000000F8000000ULL, 0x00000000F0000000ULL, 0x00000000E0000000ULL, 0x00000000C0000000ULL, 0x0000000080000000ULL, 0x0000000000000000ULL,
    0x000000FE00000000ULL, 0x000000FC00000000ULL, 0x000000F800000000ULL, 0x000000F000000000ULL, 0x000000E000000000ULL, 0x000000C000000000ULL, 0x0000008000000000ULL, 0x0000000000000000ULL,
    0x0000FE0000000000ULL, 0x0000FC0000000000ULL, 0x0000F80000000000ULL, 0x0000F00000000000ULL, 0x0000E00000000000ULL, 0x0000C00000000000ULL, 0x0000800000000000ULL, 0x0000000000000000ULL,
    0x00FE000000000000ULL, 0x00FC000000000000ULL, 0x00F8000000000000ULL, 0x00F0000000000000ULL, 0x00E0000000000000ULL, 0x00C0000000000000ULL, 0x0080000000000000ULL, 0x0000000000000000ULL,
    0xFE00000000000000ULL, 0xFC00000000000000ULL, 0xF800000000000000ULL, 0xF000000000000000ULL, 0xE000000000000000ULL, 0xC000000000000000ULL, 0x8000000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_right_b2[64] = {
    0x0000000000000000ULL, 0x0000000000000001ULL, 0x0000000000000003ULL, 0x0000000000000007ULL, 0x000000000000000FULL, 0x000000000000001FULL, 0x000000000000003FULL, 0x000000000000007FULL,
    0x0000000000000000ULL, 0x0000000000000100ULL, 0x0000000000000300ULL, 0x0000000000000700ULL, 0x0000000000000F00ULL, 0x0000000000001F00ULL, 0x0000000000003F00ULL, 0x0000000000007F00ULL,
    0x0000000000000000ULL, 0x0000000000010000ULL, 0x0000000000030000ULL, 0x0000000000070000ULL, 0x00000000000F0000ULL, 0x00000000001F0000ULL, 0x00000000003F0000ULL, 0x00000000007F0000ULL,
    0x0000000000000000ULL, 0x0000000001000000ULL, 0x0000000003000000ULL, 0x0000000007000000ULL, 0x000000000F000000ULL, 0x000000001F000000ULL, 0x000000003F000000ULL, 0x000000007F000000ULL,
    0x0000000000000000ULL, 0x0000000100000000ULL, 0x0000000300000000ULL, 0x0000000700000000ULL, 0x0000000F00000000ULL, 0x0000001F00000000ULL, 0x0000003F00000000ULL, 0x0000007F00000000ULL,
    0x0000000000000000ULL, 0x0000010000000000ULL, 0x0000030000000000ULL, 0x0000070000000000ULL, 0x00000F0000000000ULL, 0x00001F0000000000ULL, 0x00003F0000000000ULL, 0x00007F0000000000ULL,
    0x0000000000000000ULL, 0x0001000000000000ULL, 0x0003000000000000ULL, 0x0007000000000000ULL, 0x000F000000000000ULL, 0x001F000000000000ULL, 0x003F000000000000ULL, 0x007F000000000000ULL,
    0x0000000000000000ULL, 0x0100000000000000ULL, 0x0300000000000000ULL, 0x0700000000000000ULL, 0x0F00000000000000ULL, 0x1F00000000000000ULL, 0x3F00000000000000ULL, 0x7F00000000000000ULL
};

constexpr uint64_t bit_d7up_b2[64] = {

    0x0000000000000000ULL, 0x0000000000000100ULL, 0x0000000000010200ULL, 0x0000000001020400ULL, 0x0000000102040800ULL, 0x0000010204081000ULL, 0x0001020408102000ULL, 0x0102040810204000ULL,
    0x0000000000000000ULL, 0x0000000000010000ULL, 0x0000000001020000ULL, 0x0000000102040000ULL, 0x0000010204080000ULL, 0x0001020408100000ULL, 0x0102040810200000ULL, 0x0204081020400000ULL,
    0x0000000000000000ULL, 0x0000000001000000ULL, 0x0000000102000000ULL, 0x0000010204000000ULL, 0x0001020408000000ULL, 0x0102040810000000ULL, 0x0204081020000000ULL, 0x0408102040000000ULL,
    0x0000000000000000ULL, 0x0000000100000000ULL, 0x0000010200000000ULL, 0x0001020400000000ULL, 0x0102040800000000ULL, 0x0204081000000000ULL, 0x0408102000000000ULL, 0x0810204000000000ULL,
    0x0000000000000000ULL, 0x0000010000000000ULL, 0x0001020000000000ULL, 0x0102040000000000ULL, 0x0204080000000000ULL, 0x0408100000000000ULL, 0x0810200000000000ULL, 0x1020400000000000ULL,
    0x0000000000000000ULL, 0x0001000000000000ULL, 0x0102000000000000ULL, 0x0204000000000000ULL, 0x0408000000000000ULL, 0x0810000000000000ULL, 0x1020000000000000ULL, 0x2040000000000000ULL,
    0x0000000000000000ULL, 0x0100000000000000ULL, 0x0200000000000000ULL, 0x0400000000000000ULL, 0x0800000000000000ULL, 0x1000000000000000ULL, 0x2000000000000000ULL, 0x4000000000000000ULL,
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_d7down_b2[HW2_B2] = {
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0000000000000002ULL, 0x0000000000000004ULL, 0x0000000000000008ULL, 0x0000000000000010ULL, 0x0000000000000020ULL, 0x0000000000000040ULL, 0x0000000000000080ULL, 0x0000000000000000ULL,
    0x0000000000000204ULL, 0x0000000000000408ULL, 0x0000000000000810ULL, 0x0000000000001020ULL, 0x0000000000002040ULL, 0x0000000000004080ULL, 0x0000000000008000ULL, 0x0000000000000000ULL,
    0x0000000000020408ULL, 0x0000000000040810ULL, 0x0000000000081020ULL, 0x0000000000102040ULL, 0x0000000000204080ULL, 0x0000000000408000ULL, 0x0000000000800000ULL, 0x0000000000000000ULL,
    0x0000000002040810ULL, 0x0000000004081020ULL, 0x0000000008102040ULL, 0x0000000010204080ULL, 0x0000000020408000ULL, 0x0000000040800000ULL, 0x0000000080000000ULL, 0x0000000000000000ULL,
    0x0000000204081020ULL, 0x0000000408102040ULL, 0x0000000810204080ULL, 0x0000001020408000ULL, 0x0000002040800000ULL, 0x0000004080000000ULL, 0x0000008000000000ULL, 0x0000000000000000ULL,
    0x0000020408102040ULL, 0x0000040810204080ULL, 0x0000081020408000ULL, 0x0000102040800000ULL, 0x0000204080000000ULL, 0x0000408000000000ULL, 0x0000800000000000ULL, 0x0000000000000000ULL,
    0x0002040810204080ULL, 0x0004081020408000ULL, 0x0008102040800000ULL, 0x0010204080000000ULL, 0x0020408000000000ULL, 0x0040800000000000ULL, 0x0080000000000000ULL, 0x0000000000000000ULL
};
constexpr uint64_t bit_d9up_b2[64] = {

    0x8040201008040200ULL, 0x0080402010080400ULL, 0x0000804020100800ULL, 0x0000008040201000ULL, 0x0000000080402000ULL, 0x0000000000804000ULL, 0x0000000000008000ULL, 0x0000000000000000ULL,
    0x4020100804020000ULL, 0x8040201008040000ULL, 0x0080402010080000ULL, 0x0000804020100000ULL, 0x0000008040200000ULL, 0x0000000080400000ULL, 0x0000000000800000ULL, 0x0000000000000000ULL,
    0x2010080402000000ULL, 0x4020100804000000ULL, 0x8040201008000000ULL, 0x0080402010000000ULL, 0x0000804020000000ULL, 0x0000008040000000ULL, 0x0000000080000000ULL, 0x0000000000000000ULL,
    0x1008040200000000ULL, 0x2010080400000000ULL, 0x4020100800000000ULL, 0x8040201000000000ULL, 0x0080402000000000ULL, 0x0000804000000000ULL, 0x0000008000000000ULL, 0x0000000000000000ULL,
    0x0804020000000000ULL, 0x1008040000000000ULL, 0x2010080000000000ULL, 0x4020100000000000ULL, 0x8040200000000000ULL, 0x0080400000000000ULL, 0x0000800000000000ULL, 0x0000000000000000ULL,
    0x0402000000000000ULL, 0x0804000000000000ULL, 0x1008000000000000ULL, 0x2010000000000000ULL, 0x4020000000000000ULL, 0x8040000000000000ULL, 0x0080000000000000ULL, 0x0000000000000000ULL,
    0x0200000000000000ULL, 0x0400000000000000ULL, 0x0800000000000000ULL, 0x1000000000000000ULL, 0x2000000000000000ULL, 0x4000000000000000ULL, 0x8000000000000000ULL, 0x0000000000000000ULL,
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_d9down_b2[64] = {
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0000000000000000ULL, 0x0000000000000001ULL, 0x0000000000000002ULL, 0x0000000000000004ULL, 0x0000000000000008ULL, 0x0000000000000010ULL, 0x0000000000000020ULL, 0x0000000000000040ULL,
    0x0000000000000000ULL, 0x0000000000000100ULL, 0x0000000000000201ULL, 0x0000000000000402ULL, 0x0000000000000804ULL, 0x0000000000001008ULL, 0x0000000000002010ULL, 0x0000000000004020ULL,
    0x0000000000000000ULL, 0x0000000000010000ULL, 0x0000000000020100ULL, 0x0000000000040201ULL, 0x0000000000080402ULL, 0x0000000000100804ULL, 0x0000000000201008ULL, 0x0000000000402010ULL,
    0x0000000000000000ULL, 0x0000000001000000ULL, 0x0000000002010000ULL, 0x0000000004020100ULL, 0x0000000008040201ULL, 0x0000000010080402ULL, 0x0000000020100804ULL, 0x0000000040201008ULL,
    0x0000000000000000ULL, 0x0000000100000000ULL, 0x0000000201000000ULL, 0x0000000402010000ULL, 0x0000000804020100ULL, 0x0000001008040201ULL, 0x0000002010080402ULL, 0x0000004020100804ULL,
    0x0000000000000000ULL, 0x0000010000000000ULL, 0x0000020100000000ULL, 0x0000040201000000ULL, 0x0000080402010000ULL, 0x0000100804020100ULL, 0x0000201008040201ULL, 0x0000402010080402ULL,
    0x0000000000000000ULL, 0x0001000000000000ULL, 0x0002010000000000ULL, 0x0004020100000000ULL, 0x0008040201000000ULL, 0x0010080402010000ULL, 0x0020100804020100ULL, 0x0040201008040201ULL
};



bool global_searching_b2 = true;


inline uint64_t tim_b2() {
    return std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::high_resolution_clock::now().time_since_epoch()
    ).count();
}

std::mt19937 raw_myrandom_b2(tim_b2());

inline double myrandom_b2() {
    return (double)raw_myrandom_b2() / std::mt19937::max();
}

inline int32_t myrandrange_b2(int32_t s, int32_t e) {
    return s + (int)((e - s) * myrandom_b2());
}

inline uint32_t myrand_uint_b2() {
    return (uint32_t)raw_myrandom_b2();
}

inline uint32_t myrand_uint_rev_b2() {
    uint32_t x = raw_myrandom_b2();
    x = ((x & 0x55555555U) << 1) | ((x & 0xAAAAAAAAU) >> 1);
    x = ((x & 0x33333333U) << 2) | ((x & 0xCCCCCCCCU) >> 2);
    x = ((x & 0x0F0F0F0FU) << 4) | ((x & 0xF0F0F0F0U) >> 4);
    x = ((x & 0x00FF00FFU) << 8) | ((x & 0xFF00FF00U) >> 8);
    return ((x & 0x0000FFFFU) << 16) | ((x & 0xFFFF0000U) >> 16);
}

inline uint64_t myrand_ull_b2() {
    return ((uint64_t)raw_myrandom_b2() << 32) | (uint64_t)raw_myrandom_b2();
}

inline bool file_open_b2(FILE **fp, const char *file, const char *mode) {
#ifdef _WIN64
    return fopen_s(fp, file, mode) == 0;
#elif _WIN32
    return fopen_s(fp, file, mode) == 0;
#else
    *fp = fopen(file, mode);
    return *fp != NULL;
#endif
}

inline uint64_t calc_nps_b2(uint64_t n_nodes, uint64_t elapsed) {
    if (elapsed == 0ULL) elapsed = 1ULL;
    return n_nodes * 1000ULL / elapsed;
}

int get_localtime_b2(tm* a, time_t* b) {
#if _WIN64 || _WIN32
    return localtime_s(a, b);
#else
    a = localtime(b);
    return 0;
#endif
}

inline std::string calc_date_b2() {
    time_t now;
    tm newtime;
    time(&now);
    get_localtime_b2(&newtime, &now);
    std::stringstream sout;
    sout << std::setfill('0') << std::setw(2) << newtime.tm_mon + 1;
    std::string month = sout.str(); sout.str(""); sout.clear();
    sout << std::setfill('0') << std::setw(2) << newtime.tm_mday;
    std::string day = sout.str(); sout.str(""); sout.clear();
    sout << std::setfill('0') << std::setw(2) << newtime.tm_hour;
    std::string hour = sout.str(); sout.str(""); sout.clear();
    sout << std::setfill('0') << std::setw(2) << newtime.tm_min;
    std::string minute = sout.str(); sout.str(""); sout.clear();
    sout << std::setfill('0') << std::setw(2) << newtime.tm_sec;
    std::string second = sout.str();
    return std::to_string(newtime.tm_year + 1900) + "_" + month + "_" + day + "_" + hour + "_" + minute + "_" + second;
}

inline void calc_date_b2(int *year, int *month, int *day, int *hour, int *minute, int *second) {
    time_t now;
    tm newtime;
    time(&now);
    get_localtime_b2(&newtime, &now);
    *year = newtime.tm_year + 1900;
    *month = newtime.tm_mon + 1;
    *day = newtime.tm_mday;
    *hour = newtime.tm_hour;
    *minute = newtime.tm_min;
    *second = newtime.tm_sec;
}

inline bool is_valid_policy_b2(int policy) {
    return 0 <= policy && policy < HW2_B2;
}

inline bool is_valid_score_b2(int score) {
    return -SCORE_MAX_B2 <= score && score <= SCORE_MAX_B2;
}

inline bool is_black_like_char_b2(char c) {
    return c == 'B' || c == 'b' || c == 'X' || c == 'x' || c == '0' || c == '*';
}

inline bool is_white_like_char_b2(char c) {
    return c == 'W' || c == 'w' || c == 'O' || c == 'o' || c == '1';
}

inline bool is_vacant_like_char_b2(char c) {
    return c == '-' || c == '.';
}

inline bool is_pass_like_str_b2(std::string s) {
    return s == "PA" || s == "pa" || s == "PS" || s == "ps";
}

inline bool is_coord_like_chars_b2(char c1, char c2) {
    c1 = c1 | 0x20;
    return 'a' <= c1 && c1 <= 'h' && '1' <= c2 && c2 <= '8';
}

inline int get_coord_from_chars_b2(char c1, char c2) {
    c1 = c1 | 0x20;
    int y = c2 - '1';
    int x = c1 - 'a';
    return HW2_M1_B2 - (y * HW_B2 + x);
}
inline std::string idx_to_coord_b2(int idx) {
    if (idx < 0 || HW2_B2 <= idx)
        return "??";
    int y = HW_M1_B2 - idx / HW_B2;
    int x = HW_M1_B2 - idx % HW_B2;
    const std::string x_coord = "abcdefgh";
    return x_coord[x] + std::to_string(y + 1);
}

inline std::string ms_to_time_b2(uint64_t t) {
    std::string res;
    uint64_t hour = t / (1000 * 60 * 60);
    t %= 1000 * 60 * 60;
    uint64_t minute = t / (1000 * 60);
    t %= 1000 * 60;
    uint64_t second = t / 1000;
    uint64_t msecond = t % 1000;
    std::ostringstream hour_s;
    hour_s << std::right << std::setw(3) << std::setfill('0') << hour;
    res += hour_s.str();
    res += ":";
    std::ostringstream minute_s;
    minute_s << std::right << std::setw(2) << std::setfill('0') << minute;
    res += minute_s.str();
    res += ":";
    std::ostringstream second_s;
    second_s << std::right << std::setw(2) << std::setfill('0') << second;
    res += second_s.str();
    res += ".";
    std::ostringstream msecond_s;
    msecond_s << std::right << std::setw(3) << std::setfill('0') << msecond;
    res += msecond_s.str();
    return res;
}

inline std::string ms_to_time_short_b2(uint64_t t) {
    std::string res;
    uint64_t hour = t / (1000 * 60 * 60);
    t -= hour * 1000 * 60 * 60;
    uint64_t minute = t / (1000 * 60);
    t -= minute * 1000 * 60;
    uint64_t second = t / 1000;
    t -= second * 1000;
    std::ostringstream hour_s;
    hour_s << std::right << std::setw(3) << std::setfill('0') << hour;
    res += hour_s.str();
    res += ":";
    std::ostringstream minute_s;
    minute_s << std::right << std::setw(2) << std::setfill('0') << minute;
    res += minute_s.str();
    res += ":";
    std::ostringstream second_s;
    second_s << std::right << std::setw(2) << std::setfill('0') << second;
    res += second_s.str();
    return res;
}

// ===== FILE: Egaroucid/src/engine/common_b3.hpp =====



#pragma once
#include <iostream>
#include <sstream>
#include <iomanip>
#include <fstream>
#include <time.h>
#include <chrono>
#include <random>
#include <string>
#include "setting.hpp"


constexpr int HW_B3 = 8;
constexpr int HW_M1_B3 = 7;
constexpr int HW_P1_B3 = 9;
constexpr int HW2_B3 = 64;
constexpr int HW2_M1_B3 = 63;
constexpr int HW2_P1_B3 = 65;
constexpr int N_INVALID_B3 = 12;
constexpr int N_ACTIVE_SQUARES_B3 = HW2_B3 - N_INVALID_B3; 


constexpr int BLACK_B3 = 0;
constexpr int WHITE_B3 = 1;
constexpr int VACANT_B3 = 2;


constexpr int N_8BIT_B3 = 256; 
constexpr int N_16BIT_B3 = 65536; 
constexpr int INF_B3 = 100000000;
constexpr int SCORE_INF_B3 = 127;
constexpr int SCORE_MAX_B3 = 52;


constexpr uint64_t LEGAL_UNDEFINED_B3 = 0x0000001818000000ULL;


constexpr uint64_t INVALID_MASK_B3 = 0xC3810000000081C3ULL;


constexpr int N_CELL_TYPE_B3 = 6;
constexpr uint64_t cell_type_mask_b3[N_CELL_TYPE_B3] = {
    0x2400810000810024ULL & ~INVALID_MASK_B3, 
    0x1842008181004218ULL & ~INVALID_MASK_B3, 
    0x003C424242423C00ULL & ~INVALID_MASK_B3, 
    0x0000240000240000ULL & ~INVALID_MASK_B3, 
    0x0000182424180000ULL & ~INVALID_MASK_B3, 
    0x0000001818000000ULL                     
};


constexpr int cell_type_b3[HW2_B3] = {
    -1, -1, 0, 1, 1, 0, -1, -1,
    -1, 1, 2, 2, 2, 2, 1, -1,
     0, 2, 3, 4, 4, 3, 2, 0,
     1, 2, 4, 5, 5, 4, 2, 1,
     1, 2, 4, 5, 5, 4, 2, 1,
     0, 2, 3, 4, 4, 3, 2, 0,
    -1, 1, 2, 2, 2, 2, 1, -1,
    -1, -1, 0, 1, 1, 0, -1, -1
};

constexpr uint64_t bit_around_b3[HW2_B3] = {
    0x0000000000000302ULL & ~INVALID_MASK_B3, 0x0000000000000604ULL & ~INVALID_MASK_B3, 0x0000000000000e0aULL & ~INVALID_MASK_B3, 0x0000000000001c14ULL & ~INVALID_MASK_B3,
    0x0000000000003828ULL & ~INVALID_MASK_B3, 0x0000000000007050ULL & ~INVALID_MASK_B3, 0x0000000000006020ULL & ~INVALID_MASK_B3, 0x000000000000c040ULL & ~INVALID_MASK_B3,
    0x0000000000030200ULL & ~INVALID_MASK_B3, 0x0000000000060400ULL & ~INVALID_MASK_B3, 0x00000000000e0a00ULL & ~INVALID_MASK_B3, 0x00000000001c1400ULL & ~INVALID_MASK_B3,
    0x0000000000382800ULL & ~INVALID_MASK_B3, 0x0000000000705000ULL & ~INVALID_MASK_B3, 0x0000000000602000ULL & ~INVALID_MASK_B3, 0x0000000000c04000ULL & ~INVALID_MASK_B3,
    0x0000000003020300ULL & ~INVALID_MASK_B3, 0x0000000006040600ULL & ~INVALID_MASK_B3, 0x000000000e0a0e00ULL & ~INVALID_MASK_B3, 0x000000001c141c00ULL & ~INVALID_MASK_B3,
    0x0000000038283800ULL & ~INVALID_MASK_B3, 0x0000000070507000ULL & ~INVALID_MASK_B3, 0x0000000060206000ULL & ~INVALID_MASK_B3, 0x00000000c040c000ULL & ~INVALID_MASK_B3,
    0x0000000302030000ULL & ~INVALID_MASK_B3, 0x0000000604060000ULL & ~INVALID_MASK_B3, 0x0000000e0a0e0000ULL & ~INVALID_MASK_B3, 0x0000001c141c0000ULL & ~INVALID_MASK_B3,
    0x0000003828380000ULL & ~INVALID_MASK_B3, 0x0000007050700000ULL & ~INVALID_MASK_B3, 0x0000006020600000ULL & ~INVALID_MASK_B3, 0x000000c040c00000ULL & ~INVALID_MASK_B3,
    0x0000030203000000ULL & ~INVALID_MASK_B3, 0x0000060406000000ULL & ~INVALID_MASK_B3, 0x00000e0a0e000000ULL & ~INVALID_MASK_B3, 0x00001c141c000000ULL & ~INVALID_MASK_B3,
    0x0000382838000000ULL & ~INVALID_MASK_B3, 0x0000705070000000ULL & ~INVALID_MASK_B3, 0x0000602060000000ULL & ~INVALID_MASK_B3, 0x0000c040c0000000ULL & ~INVALID_MASK_B3,
    0x0003020300000000ULL & ~INVALID_MASK_B3, 0x0006040600000000ULL & ~INVALID_MASK_B3, 0x000e0a0e00000000ULL & ~INVALID_MASK_B3, 0x001c141c00000000ULL & ~INVALID_MASK_B3,
    0x0038283800000000ULL & ~INVALID_MASK_B3, 0x0070507000000000ULL & ~INVALID_MASK_B3, 0x0060206000000000ULL & ~INVALID_MASK_B3, 0x00c040c000000000ULL & ~INVALID_MASK_B3,
    0x0002030000000000ULL & ~INVALID_MASK_B3, 0x0004060000000000ULL & ~INVALID_MASK_B3, 0x000a0e0000000000ULL & ~INVALID_MASK_B3, 0x00141c0000000000ULL & ~INVALID_MASK_B3,
    0x0028380000000000ULL & ~INVALID_MASK_B3, 0x0050700000000000ULL & ~INVALID_MASK_B3, 0x0020600000000000ULL & ~INVALID_MASK_B3, 0x0040c00000000000ULL & ~INVALID_MASK_B3,
    0x0203000000000000ULL & ~INVALID_MASK_B3, 0x0406000000000000ULL & ~INVALID_MASK_B3, 0x0a0e000000000000ULL & ~INVALID_MASK_B3, 0x141c000000000000ULL & ~INVALID_MASK_B3,
    0x2838000000000000ULL & ~INVALID_MASK_B3, 0x5070000000000000ULL & ~INVALID_MASK_B3, 0x2060000000000000ULL & ~INVALID_MASK_B3, 0x40c0000000000000ULL & ~INVALID_MASK_B3
};

constexpr uint64_t bit_radiation_b3[HW2_B3] = {
    0x81412111090503FEULL & ~INVALID_MASK_B3, 0x02824222120A07FDULL & ~INVALID_MASK_B3, 0x0404844424150EFBULL & ~INVALID_MASK_B3, 0x08080888492A1CF7ULL & ~INVALID_MASK_B3,
    0x10101011925438EFULL & ~INVALID_MASK_B3, 0x2020212224A870DFULL & ~INVALID_MASK_B3, 0x404142444850E0BFULL & ~INVALID_MASK_B3, 0x8182848890A0C07FULL & ~INVALID_MASK_B3,
    0x412111090503FE03ULL & ~INVALID_MASK_B3, 0x824222120A07FD07ULL & ~INVALID_MASK_B3, 0x04844424150EFB0EULL & ~INVALID_MASK_B3, 0x080888492A1CF71CULL & ~INVALID_MASK_B3,
    0x101011925438EF38ULL & ~INVALID_MASK_B3, 0x20212224A870DF70ULL & ~INVALID_MASK_B3, 0x4142444850E0BFE0ULL & ~INVALID_MASK_B3, 0x82848890A0C07FC0ULL & ~INVALID_MASK_B3,
    0x2111090503FE0305ULL & ~INVALID_MASK_B3, 0x4222120A07FD070AULL & ~INVALID_MASK_B3, 0x844424150EFB0E15ULL & ~INVALID_MASK_B3, 0x0888492A1CF71C2AULL & ~INVALID_MASK_B3,
    0x1011925438EF3854ULL & ~INVALID_MASK_B3, 0x212224A870DF70A8ULL & ~INVALID_MASK_B3, 0x42444850E0BFE050ULL & ~INVALID_MASK_B3, 0x848890A0C07FC0A0ULL & ~INVALID_MASK_B3,
    0x11090503FE030509ULL & ~INVALID_MASK_B3, 0x22120A07FD070A12ULL & ~INVALID_MASK_B3, 0x4424150EFB0E1524ULL & ~INVALID_MASK_B3, 0x88492A1CF71C2A49ULL & ~INVALID_MASK_B3,
    0x11925438EF385492ULL & ~INVALID_MASK_B3, 0x2224A870DF70A824ULL & ~INVALID_MASK_B3, 0x444850E0BFE05048ULL & ~INVALID_MASK_B3, 0x8890A0C07FC0A090ULL & ~INVALID_MASK_B3,
    0x090503FE03050911ULL & ~INVALID_MASK_B3, 0x120A07FD070A1222ULL & ~INVALID_MASK_B3, 0x24150EFB0E152444ULL & ~INVALID_MASK_B3, 0x492A1CF71C2A4988ULL & ~INVALID_MASK_B3,
    0x925438EF38549211ULL & ~INVALID_MASK_B3, 0x24A870DF70A82422ULL & ~INVALID_MASK_B3, 0x4850E0BFE0504844ULL & ~INVALID_MASK_B3, 0x90A0C07FC0A09088ULL & ~INVALID_MASK_B3,
    0x0503FE0305091121ULL & ~INVALID_MASK_B3, 0x0A07FD070A122242ULL & ~INVALID_MASK_B3, 0x150EFB0E15244484ULL & ~INVALID_MASK_B3, 0x2A1CF71C2A498808ULL & ~INVALID_MASK_B3,
    0x5438EF3854921110ULL & ~INVALID_MASK_B3, 0xA870DF70A8242221ULL & ~INVALID_MASK_B3, 0x50E0BFE050484442ULL & ~INVALID_MASK_B3, 0xA0C07FC0A0908884ULL & ~INVALID_MASK_B3,
    0x03FE030509112141ULL & ~INVALID_MASK_B3, 0x07FD070A12224282ULL & ~INVALID_MASK_B3, 0x0EFB0E1524448404ULL & ~INVALID_MASK_B3, 0x1CF71C2A49880808ULL & ~INVALID_MASK_B3,
    0x38EF385492111010ULL & ~INVALID_MASK_B3, 0x70DF70A824222120ULL & ~INVALID_MASK_B3, 0xE0BFE05048444241ULL & ~INVALID_MASK_B3, 0xC07FC0A090888482ULL & ~INVALID_MASK_B3,
    0xFE03050911214181ULL & ~INVALID_MASK_B3, 0xFD070A1222428202ULL & ~INVALID_MASK_B3, 0xFB0E152444840404ULL & ~INVALID_MASK_B3, 0xF71C2A4988080808ULL & ~INVALID_MASK_B3,
    0xEF38549211101010ULL & ~INVALID_MASK_B3, 0xDF70A82422212020ULL & ~INVALID_MASK_B3, 0xBFE0504844424140ULL & ~INVALID_MASK_B3, 0x7FC0A09088848281ULL & ~INVALID_MASK_B3
};

bool global_searching_b3 = true;


inline uint64_t tim_b3() {
    return std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::high_resolution_clock::now().time_since_epoch()
    ).count();
}

std::mt19937 raw_myrandom_b3(tim_b3());


inline double myrandom_b3() {
    return (double)raw_myrandom_b3() / std::mt19937::max();
}


inline int32_t myrandrange_b3(int32_t s, int32_t e) {
    return s + (int)((e - s) * myrandom_b3());
}


inline uint32_t myrand_uint_b3() {
    return (uint32_t)raw_myrandom_b3();
}


inline uint32_t myrand_uint_rev_b3() {
    uint32_t x = raw_myrandom_b3();
    x = ((x & 0x55555555U) << 1) | ((x & 0xAAAAAAAAU) >> 1);
    x = ((x & 0x33333333U) << 2) | ((x & 0xCCCCCCCCU) >> 2);
    x = ((x & 0x0F0F0F0FU) << 4) | ((x & 0xF0F0F0F0U) >> 4);
    x = ((x & 0x00FF00FFU) << 8) | ((x & 0xFF00FF00U) >> 8);
    return ((x & 0x0000FFFFU) << 16) | ((x & 0xFFFF0000U) >> 16);
}


inline uint64_t myrand_ull_b3() {
    return ((uint64_t)raw_myrandom_b3() << 32) | (uint64_t)raw_myrandom_b3();
}


inline bool file_open_b3(FILE **fp, const char *file, const char *mode) {
#ifdef _WIN64
    return fopen_s(fp, file, mode) == 0;
#elif _WIN32
    return fopen_s(fp, file, mode) == 0;
#else
    *fp = fopen(file, mode);
    return *fp != NULL;
#endif
}


inline uint64_t calc_nps_b3(uint64_t n_nodes, uint64_t elapsed) {
    if (elapsed == 0ULL) elapsed = 1ULL;
    return n_nodes * 1000ULL / elapsed;
}

int get_localtime_b3(tm* a, time_t* b) {
#if _WIN64 || _WIN32
    return localtime_s(a, b);
#else
    a = localtime(b);
    return 0;
#endif
}

inline std::string calc_date_b3() {
    time_t now;
    tm newtime;
    time(&now);
    get_localtime_b3(&newtime, &now);
    std::stringstream sout;
    std::string year = std::to_string(newtime.tm_year + 1900);
    sout << std::setfill('0') << std::setw(2) << newtime.tm_mon + 1;
    std::string month = sout.str(); sout.str(""); sout.clear();
    sout << std::setfill('0') << std::setw(2) << newtime.tm_mday;
    std::string day = sout.str(); sout.str(""); sout.clear();
    sout << std::setfill('0') << std::setw(2) << newtime.tm_hour;
    std::string hour = sout.str(); sout.str(""); sout.clear();
    sout << std::setfill('0') << std::setw(2) << newtime.tm_min;
    std::string minute = sout.str(); sout.str(""); sout.clear();
    sout << std::setfill('0') << std::setw(2) << newtime.tm_sec;
    std::string second = sout.str();
    return year + "_" + month + "_" + day + "_" + hour + "_" + minute + "_" + second;
}

inline void calc_date_b3(int *year, int *month, int *day, int *hour, int *minute, int *second) {
    time_t now;
    tm newtime;
    time(&now);
    get_localtime_b3(&newtime, &now);
    *year = newtime.tm_year + 1900;
    *month = newtime.tm_mon + 1;
    *day = newtime.tm_mday;
    *hour = newtime.tm_hour;
    *minute = newtime.tm_min;
    *second = newtime.tm_sec;
}
inline bool is_valid_policy_b3(int policy) {
    return 0 <= policy && policy < HW2_B3 && !(INVALID_MASK_B3 & (1ULL << policy));
}

inline bool is_valid_score_b3(int score) {
    return -SCORE_MAX_B3 <= score && score <= SCORE_MAX_B3;
}

inline bool is_black_like_char_b3(char c) {
    return c == 'B' || c == 'b' || c == 'X' || c == 'x' || c == '0' || c == '*';
}

inline bool is_white_like_char_b3(char c) {
    return c == 'W' || c == 'w' || c == 'O' || c == 'o' || c == '1';
}

inline bool is_vacant_like_char_b3(char c) {
    return c == '-' || c == '.';
}

inline bool is_pass_like_str_b3(std::string s) {
    return s == "PA" || s == "pa" || s == "PS" || s == "ps";
}

inline bool is_coord_like_chars_b3(char c1, char c2) {
    c1 = c1 | 0x20;
    return 'a' <= c1 && c1 <= 'h' && '1' <= c2 && c2 <= '8';
}

inline int get_coord_from_chars_b3(char c1, char c2) {
    c1 = c1 | 0x20;
    int y = c2 - '1';
    int x = c1 - 'a';
    int idx = HW2_M1_B3 - (y * HW_B3 + x);
    return (INVALID_MASK_B3 & (1ULL << idx)) ? -1 : idx;
}


std::string idx_to_coord_b3(int idx) {
    if (idx < 0 || HW2_B3 <= idx || (INVALID_MASK_B3 & (1ULL << idx)))
        return "??";
    int y = HW_M1_B3 - idx / HW_B3;
    int x = HW_M1_B3 - idx % HW_B3;
    const std::string x_coord = "abcdefgh";
    return x_coord[x] + std::to_string(y + 1);
}


std::string ms_to_time_b3(uint64_t t) {
    std::string res;
    uint64_t hour = t / (1000 * 60 * 60);
    t %= 1000 * 60 * 60;
    uint64_t minute = t / (1000 * 60);
    t %= 1000 * 60;
    uint64_t second = t / 1000;
    uint64_t msecond = t % 1000;
    std::ostringstream hour_s;
    hour_s << std::right << std::setw(3) << std::setfill('0') << hour;
    res += hour_s.str();
    res += ":";
    std::ostringstream minute_s;
    minute_s << std::right << std::setw(2) << std::setfill('0') << minute;
    res += minute_s.str();
    res += ":";
    std::ostringstream second_s;
    second_s << std::right << std::setw(2) << std::setfill('0') << second;
    res += second_s.str();
    res += ".";
    std::ostringstream msecond_s;
    msecond_s << std::right << std::setw(3) << std::setfill('0') << msecond;
    res += msecond_s.str();
    return res;
}


std::string ms_to_time_short_b3(uint64_t t) {
    std::string res;
    uint64_t hour = t / (1000 * 60 * 60);
    t -= hour * 1000 * 60 * 60;
    uint64_t minute = t / (1000 * 60);
    t -= minute * 1000 * 60;
    uint64_t second = t / 1000;
    t -= second * 1000;
    std::ostringstream hour_s;
    hour_s << std::right << std::setw(3) << std::setfill('0') << hour;
    res += hour_s.str();
    res += ":";
    std::ostringstream minute_s;
    minute_s << std::right << std::setw(2) << std::setfill('0') << minute;
    res += minute_s.str();
    res += ":";
    std::ostringstream second_s;
    second_s << std::right << std::setw(2) << std::setfill('0') << second;
    res += second_s.str();
    return res;
}

// ===== FILE: Egaroucid/src/engine/common.hpp =====



#pragma once
#include <iostream>
#include <sstream>
#include <iomanip>
#include <fstream>
#include <time.h>
#include <chrono>
#include <random>
#include <string>
#include "setting.hpp"


constexpr int HW = 8;
constexpr int HW_M1 = 7;
constexpr int HW_P1 = 9;
constexpr int HW2 = 64;
constexpr int HW2_M1 = 63;
constexpr int HW2_P1 = 65; constexpr int N_INVALID = 0;


constexpr int BLACK = 0;
constexpr int WHITE = 1;
constexpr int VACANT = 2;


constexpr int N_8BIT = 256; 
constexpr int N_16BIT = 65536; 
constexpr int INF = 100000000;
constexpr int SCORE_INF = 127;
constexpr int SCORE_MAX = 64;


constexpr uint64_t INVALID_MASK = 0ULL;

constexpr uint64_t LEGAL_UNDEFINED = 0x0000001818000000ULL;

constexpr int N_CELL_TYPE = 10;
constexpr uint64_t cell_type_mask[N_CELL_TYPE] = {
    0x8100000000000081ULL, 
    0x4281000000008142ULL, 
    0x2400810000810024ULL, 
    0x1800008181000018ULL, 
    0x0042000000004200ULL, 
    0x0024420000422400ULL, 
    0x0018004242001800ULL, 
    0x0000240000240000ULL, 
    0x0000182424180000ULL, 
    0x0000001818000000ULL  
};

constexpr int cell_type[HW2] = {
    0, 1, 2, 3, 3, 2, 1, 0, 
    1, 4, 5, 6, 6, 5, 4, 1, 
    2, 5, 7, 8, 8, 7, 5, 2, 
    3, 6, 8, 9, 9, 8, 6, 3, 
    3, 6, 8, 9, 9, 8, 6, 3, 
    2, 5, 7, 8, 8, 7, 5, 2, 
    1, 4, 5, 6, 6, 5, 4, 1, 
    0, 1, 2, 3, 3, 2, 1, 0
};


constexpr uint64_t bit_around[HW2] = {
    0x0000000000000302ULL, 0x0000000000000604ULL, 0x0000000000000e0aULL, 0x0000000000001c14ULL, 0x0000000000003828ULL, 0x0000000000007050ULL, 0x0000000000006020ULL, 0x000000000000c040ULL,
    0x0000000000030200ULL, 0x0000000000060400ULL, 0x00000000000e0a00ULL, 0x00000000001c1400ULL, 0x0000000000382800ULL, 0x0000000000705000ULL, 0x0000000000602000ULL, 0x0000000000c04000ULL,
    0x0000000003020300ULL, 0x0000000006040600ULL, 0x000000000e0a0e00ULL, 0x000000001c141c00ULL, 0x0000000038283800ULL, 0x0000000070507000ULL, 0x0000000060206000ULL, 0x00000000c040c000ULL,
    0x0000000302030000ULL, 0x0000000604060000ULL, 0x0000000e0a0e0000ULL, 0x0000001c141c0000ULL, 0x0000003828380000ULL, 0x0000007050700000ULL, 0x0000006020600000ULL, 0x000000c040c00000ULL,
    0x0000030203000000ULL, 0x0000060406000000ULL, 0x00000e0a0e000000ULL, 0x00001c141c000000ULL, 0x0000382838000000ULL, 0x0000705070000000ULL, 0x0000602060000000ULL, 0x0000c040c0000000ULL,
    0x0003020300000000ULL, 0x0006040600000000ULL, 0x000e0a0e00000000ULL, 0x001c141c00000000ULL, 0x0038283800000000ULL, 0x0070507000000000ULL, 0x0060206000000000ULL, 0x00c040c000000000ULL,
    0x0002030000000000ULL, 0x0004060000000000ULL, 0x000a0e0000000000ULL, 0x00141c0000000000ULL, 0x0028380000000000ULL, 0x0050700000000000ULL, 0x0020600000000000ULL, 0x0040c00000000000ULL,
    0x0203000000000000ULL, 0x0406000000000000ULL, 0x0a0e000000000000ULL, 0x141c000000000000ULL, 0x2838000000000000ULL, 0x5070000000000000ULL, 0x2060000000000000ULL, 0x40c0000000000000ULL
};


constexpr uint64_t bit_radiation[HW2] = {
    0x81412111090503FEULL, 0x02824222120A07FDULL, 0x0404844424150EFBULL, 0x08080888492A1CF7ULL, 0x10101011925438EFULL, 0x2020212224A870DFULL, 0x404142444850E0BFULL, 0x8182848890A0C07FULL, 
    0x412111090503FE03ULL, 0x824222120A07FD07ULL, 0x04844424150EFB0EULL, 0x080888492A1CF71CULL, 0x101011925438EF38ULL, 0x20212224A870DF70ULL, 0x4142444850E0BFE0ULL, 0x82848890A0C07FC0ULL, 
    0x2111090503FE0305ULL, 0x4222120A07FD070AULL, 0x844424150EFB0E15ULL, 0x0888492A1CF71C2AULL, 0x1011925438EF3854ULL, 0x212224A870DF70A8ULL, 0x42444850E0BFE050ULL, 0x848890A0C07FC0A0ULL,
    0x11090503FE030509ULL, 0x22120A07FD070A12ULL, 0x4424150EFB0E1524ULL, 0x88492A1CF71C2A49ULL, 0x11925438EF385492ULL, 0x2224A870DF70A824ULL, 0x444850E0BFE05048ULL, 0x8890A0C07FC0A090ULL,
    0x090503FE03050911ULL, 0x120A07FD070A1222ULL, 0x24150EFB0E152444ULL, 0x492A1CF71C2A4988ULL, 0x925438EF38549211ULL, 0x24A870DF70A82422ULL, 0x4850E0BFE0504844ULL, 0x90A0C07FC0A09088ULL,
    0x0503FE0305091121ULL, 0x0A07FD070A122242ULL, 0x150EFB0E15244484ULL, 0x2A1CF71C2A498808ULL, 0x5438EF3854921110ULL, 0xA870DF70A8242221ULL, 0x50E0BFE050484442ULL, 0xA0C07FC0A0908884ULL,
    0x03FE030509112141ULL, 0x07FD070A12224282ULL, 0x0EFB0E1524448404ULL, 0x1CF71C2A49880808ULL, 0x38EF385492111010ULL, 0x70DF70A824222120ULL, 0xE0BFE05048444241ULL, 0xC07FC0A090888482ULL,
    0xFE03050911214181ULL, 0xFD070A1222428202ULL, 0xFB0E152444840404ULL, 0xF71C2A4988080808ULL, 0xEF38549211101010ULL, 0xDF70A82422212020ULL, 0xBFE0504844424140ULL, 0x7FC0A09088848281ULL
};



constexpr uint64_t bit_left[HW2] = {
    0x00000000000000FEULL, 0x00000000000000FCULL, 0x00000000000000F8ULL, 0x00000000000000F0ULL, 0x00000000000000E0ULL, 0x00000000000000C0ULL, 0x0000000000000080ULL, 0x0000000000000000ULL, 
    0x000000000000FE00ULL, 0x000000000000FC00ULL, 0x000000000000F800ULL, 0x000000000000F000ULL, 0x000000000000E000ULL, 0x000000000000C000ULL, 0x0000000000008000ULL, 0x0000000000000000ULL, 
    0x0000000000FE0000ULL, 0x0000000000FC0000ULL, 0x0000000000F80000ULL, 0x0000000000F00000ULL, 0x0000000000E00000ULL, 0x0000000000C00000ULL, 0x0000000000800000ULL, 0x0000000000000000ULL,
    0x00000000FE000000ULL, 0x00000000FC000000ULL, 0x00000000F8000000ULL, 0x00000000F0000000ULL, 0x00000000E0000000ULL, 0x00000000C0000000ULL, 0x0000000080000000ULL, 0x0000000000000000ULL,
    0x000000FE00000000ULL, 0x000000FC00000000ULL, 0x000000F800000000ULL, 0x000000F000000000ULL, 0x000000E000000000ULL, 0x000000C000000000ULL, 0x0000008000000000ULL, 0x0000000000000000ULL,
    0x0000FE0000000000ULL, 0x0000FC0000000000ULL, 0x0000F80000000000ULL, 0x0000F00000000000ULL, 0x0000E00000000000ULL, 0x0000C00000000000ULL, 0x0000800000000000ULL, 0x0000000000000000ULL,
    0x00FE000000000000ULL, 0x00FC000000000000ULL, 0x00F8000000000000ULL, 0x00F0000000000000ULL, 0x00E0000000000000ULL, 0x00C0000000000000ULL, 0x0080000000000000ULL, 0x0000000000000000ULL,
    0xFE00000000000000ULL, 0xFC00000000000000ULL, 0xF800000000000000ULL, 0xF000000000000000ULL, 0xE000000000000000ULL, 0xC000000000000000ULL, 0x8000000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_right[HW2] = {
    0x0000000000000000ULL, 0x0000000000000001ULL, 0x0000000000000003ULL, 0x0000000000000007ULL, 0x000000000000000FULL, 0x000000000000001FULL, 0x000000000000003FULL, 0x000000000000007FULL,
    0x0000000000000000ULL, 0x0000000000000100ULL, 0x0000000000000300ULL, 0x0000000000000700ULL, 0x0000000000000F00ULL, 0x0000000000001F00ULL, 0x0000000000003F00ULL, 0x0000000000007F00ULL,
    0x0000000000000000ULL, 0x0000000000010000ULL, 0x0000000000030000ULL, 0x0000000000070000ULL, 0x00000000000F0000ULL, 0x00000000001F0000ULL, 0x00000000003F0000ULL, 0x00000000007F0000ULL,
    0x0000000000000000ULL, 0x0000000001000000ULL, 0x0000000003000000ULL, 0x0000000007000000ULL, 0x000000000F000000ULL, 0x000000001F000000ULL, 0x000000003F000000ULL, 0x000000007F000000ULL,
    0x0000000000000000ULL, 0x0000000100000000ULL, 0x0000000300000000ULL, 0x0000000700000000ULL, 0x0000000F00000000ULL, 0x0000001F00000000ULL, 0x0000003F00000000ULL, 0x0000007F00000000ULL,
    0x0000000000000000ULL, 0x0000010000000000ULL, 0x0000030000000000ULL, 0x0000070000000000ULL, 0x00000F0000000000ULL, 0x00001F0000000000ULL, 0x00003F0000000000ULL, 0x00007F0000000000ULL,
    0x0000000000000000ULL, 0x0001000000000000ULL, 0x0003000000000000ULL, 0x0007000000000000ULL, 0x000F000000000000ULL, 0x001F000000000000ULL, 0x003F000000000000ULL, 0x007F000000000000ULL,
    0x0000000000000000ULL, 0x0100000000000000ULL, 0x0300000000000000ULL, 0x0700000000000000ULL, 0x0F00000000000000ULL, 0x1F00000000000000ULL, 0x3F00000000000000ULL, 0x7F00000000000000ULL
};

constexpr uint64_t bit_up[HW2] = {
    0x0101010101010100ULL, 0x0202020202020200ULL, 0x0404040404040400ULL, 0x0808080808080800ULL, 0x1010101010101000ULL, 0x2020202020202000ULL, 0x4040404040404000ULL, 0x8080808080808000ULL,
    0x0101010101010000ULL, 0x0202020202020000ULL, 0x0404040404040000ULL, 0x0808080808080000ULL, 0x1010101010100000ULL, 0x2020202020200000ULL, 0x4040404040400000ULL, 0x8080808080800000ULL,
    0x0101010101000000ULL, 0x0202020202000000ULL, 0x0404040404000000ULL, 0x0808080808000000ULL, 0x1010101010000000ULL, 0x2020202020000000ULL, 0x4040404040000000ULL, 0x8080808080000000ULL,
    0x0101010100000000ULL, 0x0202020200000000ULL, 0x0404040400000000ULL, 0x0808080800000000ULL, 0x1010101000000000ULL, 0x2020202000000000ULL, 0x4040404000000000ULL, 0x8080808000000000ULL,
    0x0101010000000000ULL, 0x0202020000000000ULL, 0x0404040000000000ULL, 0x0808080000000000ULL, 0x1010100000000000ULL, 0x2020200000000000ULL, 0x4040400000000000ULL, 0x8080800000000000ULL,
    0x0101000000000000ULL, 0x0202000000000000ULL, 0x0404000000000000ULL, 0x0808000000000000ULL, 0x1010000000000000ULL, 0x2020000000000000ULL, 0x4040000000000000ULL, 0x8080000000000000ULL,
    0x0100000000000000ULL, 0x0200000000000000ULL, 0x0400000000000000ULL, 0x0800000000000000ULL, 0x1000000000000000ULL, 0x2000000000000000ULL, 0x4000000000000000ULL, 0x8000000000000000ULL,
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_down[HW2] = {
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0000000000000001ULL, 0x0000000000000002ULL, 0x0000000000000004ULL, 0x0000000000000008ULL, 0x0000000000000010ULL, 0x0000000000000020ULL, 0x0000000000000040ULL, 0x0000000000000080ULL,
    0x0000000000000101ULL, 0x0000000000000202ULL, 0x0000000000000404ULL, 0x0000000000000808ULL, 0x0000000000001010ULL, 0x0000000000002020ULL, 0x0000000000004040ULL, 0x0000000000008080ULL,
    0x0000000000010101ULL, 0x0000000000020202ULL, 0x0000000000040404ULL, 0x0000000000080808ULL, 0x0000000000101010ULL, 0x0000000000202020ULL, 0x0000000000404040ULL, 0x0000000000808080ULL,
    0x0000000001010101ULL, 0x0000000002020202ULL, 0x0000000004040404ULL, 0x0000000008080808ULL, 0x0000000010101010ULL, 0x0000000020202020ULL, 0x0000000040404040ULL, 0x0000000080808080ULL,
    0x0000000101010101ULL, 0x0000000202020202ULL, 0x0000000404040404ULL, 0x0000000808080808ULL, 0x0000001010101010ULL, 0x0000002020202020ULL, 0x0000004040404040ULL, 0x0000008080808080ULL,
    0x0000010101010101ULL, 0x0000020202020202ULL, 0x0000040404040404ULL, 0x0000080808080808ULL, 0x0000101010101010ULL, 0x0000202020202020ULL, 0x0000404040404040ULL, 0x0000808080808080ULL,
    0x0001010101010101ULL, 0x0002020202020202ULL, 0x0004040404040404ULL, 0x0008080808080808ULL, 0x0010101010101010ULL, 0x0020202020202020ULL, 0x0040404040404040ULL, 0x0080808080808080ULL
};

constexpr uint64_t bit_d7up[HW2] = {
    0x0000000000000000ULL, 0x0000000000000100ULL, 0x0000000000010200ULL, 0x0000000001020400ULL, 0x0000000102040800ULL, 0x0000010204081000ULL, 0x0001020408102000ULL, 0x0102040810204000ULL,
    0x0000000000000000ULL, 0x0000000000010000ULL, 0x0000000001020000ULL, 0x0000000102040000ULL, 0x0000010204080000ULL, 0x0001020408100000ULL, 0x0102040810200000ULL, 0x0204081020400000ULL,
    0x0000000000000000ULL, 0x0000000001000000ULL, 0x0000000102000000ULL, 0x0000010204000000ULL, 0x0001020408000000ULL, 0x0102040810000000ULL, 0x0204081020000000ULL, 0x0408102040000000ULL,
    0x0000000000000000ULL, 0x0000000100000000ULL, 0x0000010200000000ULL, 0x0001020400000000ULL, 0x0102040800000000ULL, 0x0204081000000000ULL, 0x0408102000000000ULL, 0x0810204000000000ULL,
    0x0000000000000000ULL, 0x0000010000000000ULL, 0x0001020000000000ULL, 0x0102040000000000ULL, 0x0204080000000000ULL, 0x0408100000000000ULL, 0x0810200000000000ULL, 0x1020400000000000ULL,
    0x0000000000000000ULL, 0x0001000000000000ULL, 0x0102000000000000ULL, 0x0204000000000000ULL, 0x0408000000000000ULL, 0x0810000000000000ULL, 0x1020000000000000ULL, 0x2040000000000000ULL,
    0x0000000000000000ULL, 0x0100000000000000ULL, 0x0200000000000000ULL, 0x0400000000000000ULL, 0x0800000000000000ULL, 0x1000000000000000ULL, 0x2000000000000000ULL, 0x4000000000000000ULL,
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_d7down[HW2] = {
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0000000000000002ULL, 0x0000000000000004ULL, 0x0000000000000008ULL, 0x0000000000000010ULL, 0x0000000000000020ULL, 0x0000000000000040ULL, 0x0000000000000080ULL, 0x0000000000000000ULL,
    0x0000000000000204ULL, 0x0000000000000408ULL, 0x0000000000000810ULL, 0x0000000000001020ULL, 0x0000000000002040ULL, 0x0000000000004080ULL, 0x0000000000008000ULL, 0x0000000000000000ULL,
    0x0000000000020408ULL, 0x0000000000040810ULL, 0x0000000000081020ULL, 0x0000000000102040ULL, 0x0000000000204080ULL, 0x0000000000408000ULL, 0x0000000000800000ULL, 0x0000000000000000ULL,
    0x0000000002040810ULL, 0x0000000004081020ULL, 0x0000000008102040ULL, 0x0000000010204080ULL, 0x0000000020408000ULL, 0x0000000040800000ULL, 0x0000000080000000ULL, 0x0000000000000000ULL,
    0x0000000204081020ULL, 0x0000000408102040ULL, 0x0000000810204080ULL, 0x0000001020408000ULL, 0x0000002040800000ULL, 0x0000004080000000ULL, 0x0000008000000000ULL, 0x0000000000000000ULL,
    0x0000020408102040ULL, 0x0000040810204080ULL, 0x0000081020408000ULL, 0x0000102040800000ULL, 0x0000204080000000ULL, 0x0000408000000000ULL, 0x0000800000000000ULL, 0x0000000000000000ULL,
    0x0002040810204080ULL, 0x0004081020408000ULL, 0x0008102040800000ULL, 0x0010204080000000ULL, 0x0020408000000000ULL, 0x0040800000000000ULL, 0x0080000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_d9up[HW2] = {
    0x8040201008040200ULL, 0x0080402010080400ULL, 0x0000804020100800ULL, 0x0000008040201000ULL, 0x0000000080402000ULL, 0x0000000000804000ULL, 0x0000000000008000ULL, 0x0000000000000000ULL,
    0x4020100804020000ULL, 0x8040201008040000ULL, 0x0080402010080000ULL, 0x0000804020100000ULL, 0x0000008040200000ULL, 0x0000000080400000ULL, 0x0000000000800000ULL, 0x0000000000000000ULL,
    0x2010080402000000ULL, 0x4020100804000000ULL, 0x8040201008000000ULL, 0x0080402010000000ULL, 0x0000804020000000ULL, 0x0000008040000000ULL, 0x0000000080000000ULL, 0x0000000000000000ULL,
    0x1008040200000000ULL, 0x2010080400000000ULL, 0x4020100800000000ULL, 0x8040201000000000ULL, 0x0080402000000000ULL, 0x0000804000000000ULL, 0x0000008000000000ULL, 0x0000000000000000ULL,
    0x0804020000000000ULL, 0x1008040000000000ULL, 0x2010080000000000ULL, 0x4020100000000000ULL, 0x8040200000000000ULL, 0x0080400000000000ULL, 0x0000800000000000ULL, 0x0000000000000000ULL,
    0x0402000000000000ULL, 0x0804000000000000ULL, 0x1008000000000000ULL, 0x2010000000000000ULL, 0x4020000000000000ULL, 0x8040000000000000ULL, 0x0080000000000000ULL, 0x0000000000000000ULL,
    0x0200000000000000ULL, 0x0400000000000000ULL, 0x0800000000000000ULL, 0x1000000000000000ULL, 0x2000000000000000ULL, 0x4000000000000000ULL, 0x8000000000000000ULL, 0x0000000000000000ULL,
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL
};

constexpr uint64_t bit_d9down[HW2] = {
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0000000000000000ULL, 0x0000000000000001ULL, 0x0000000000000002ULL, 0x0000000000000004ULL, 0x0000000000000008ULL, 0x0000000000000010ULL, 0x0000000000000020ULL, 0x0000000000000040ULL,
    0x0000000000000000ULL, 0x0000000000000100ULL, 0x0000000000000201ULL, 0x0000000000000402ULL, 0x0000000000000804ULL, 0x0000000000001008ULL, 0x0000000000002010ULL, 0x0000000000004020ULL,
    0x0000000000000000ULL, 0x0000000000010000ULL, 0x0000000000020100ULL, 0x0000000000040201ULL, 0x0000000000080402ULL, 0x0000000000100804ULL, 0x0000000000201008ULL, 0x0000000000402010ULL,
    0x0000000000000000ULL, 0x0000000001000000ULL, 0x0000000002010000ULL, 0x0000000004020100ULL, 0x0000000008040201ULL, 0x0000000010080402ULL, 0x0000000020100804ULL, 0x0000000040201008ULL,
    0x0000000000000000ULL, 0x0000000100000000ULL, 0x0000000201000000ULL, 0x0000000402010000ULL, 0x0000000804020100ULL, 0x0000001008040201ULL, 0x0000002010080402ULL, 0x0000004020100804ULL,
    0x0000000000000000ULL, 0x0000010000000000ULL, 0x0000020100000000ULL, 0x0000040201000000ULL, 0x0000080402010000ULL, 0x0000100804020100ULL, 0x0000201008040201ULL, 0x0000402010080402ULL,
    0x0000000000000000ULL, 0x0001000000000000ULL, 0x0002010000000000ULL, 0x0004020100000000ULL, 0x0008040201000000ULL, 0x0010080402010000ULL, 0x0020100804020100ULL, 0x0040201008040201ULL
};









bool global_searching = true;


inline uint64_t tim() {
    return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
}

std::mt19937 raw_myrandom(tim());


inline double myrandom() {
    return (double)raw_myrandom() / std::mt19937::max();
}


inline int32_t myrandrange(int32_t s, int32_t e) {
    return s +(int)((e - s) * myrandom());
}


inline uint32_t myrand_uint() {
    return (uint32_t)raw_myrandom();
}


inline uint32_t myrand_uint_rev() {
    uint32_t x = raw_myrandom();
    x = ((x & 0x55555555U) << 1) | ((x & 0xAAAAAAAAU) >> 1);
    x = ((x & 0x33333333U) << 2) | ((x & 0xCCCCCCCCU) >> 2);
    x = ((x & 0x0F0F0F0FU) << 4) | ((x & 0xF0F0F0F0U) >> 4);
    x = ((x & 0x00FF00FFU) << 8) | ((x & 0xFF00FF00U) >> 8);
    return ((x & 0x0000FFFFU) << 16) | ((x & 0xFFFF0000U) >> 16);
}


inline uint64_t myrand_ull() {
    return ((uint64_t)raw_myrandom() << 32) | (uint64_t)raw_myrandom();
}


inline bool file_open(FILE **fp, const char *file, const char *mode) {
#ifdef _WIN64
    return fopen_s(fp, file, mode) == 0;
#elif _WIN32
    return fopen_s(fp, file, mode) == 0;
#else
    *fp = fopen(file, mode);
    return *fp != NULL;
#endif
}


inline uint64_t calc_nps(uint64_t n_nodes, uint64_t elapsed) {
    if (elapsed == 0ULL) {
        elapsed = 1ULL;
    }
    return n_nodes * 1000ULL / elapsed;
}

int get_localtime(tm* a, time_t* b) {
#if _WIN64 || _WIN32
    return localtime_s(a, b);
#else
    a = localtime(b);
    return 0;
#endif
}

inline std::string calc_date() {
    time_t now;
    tm newtime;
    time(&now);
    get_localtime(&newtime, &now);
    std::stringstream sout;
    std::string year = std::to_string(newtime.tm_year + 1900);
    sout << std::setfill('0') << std::setw(2) << newtime.tm_mon + 1;
    std::string month = sout.str();
    sout.str("");
    sout.clear(std::stringstream::goodbit);
    sout << std::setfill('0') << std::setw(2) << newtime.tm_mday;
    std::string day = sout.str();
    sout.str("");
    sout.clear(std::stringstream::goodbit);
    sout << std::setfill('0') << std::setw(2) << newtime.tm_hour;
    std::string hour = sout.str();
    sout.str("");
    sout.clear(std::stringstream::goodbit);
    sout << std::setfill('0') << std::setw(2) << newtime.tm_min;
    std::string minute = sout.str();
    sout.str("");
    sout.clear(std::stringstream::goodbit);
    sout << std::setfill('0') << std::setw(2) << newtime.tm_sec;
    std::string second = sout.str();
    return year + "_" + month + "_" + day + "_" + hour + "_" + minute + "_" + second;
}

inline void calc_date(int *year, int *month, int *day, int *hour, int *minute, int *second) {
    time_t now;
    tm newtime;
    time(&now);
    get_localtime(&newtime, &now);
    *year = newtime.tm_year + 1900;
    *month = newtime.tm_mon + 1;
    *day = newtime.tm_mday;
    *hour = newtime.tm_hour;
    *minute = newtime.tm_min;
    *second = newtime.tm_sec;
}

inline bool is_valid_policy(int policy) {
    return 0 <= policy && policy < HW2;
}

inline bool is_valid_score(int score) {
    return -SCORE_MAX <= score && score <= SCORE_MAX;
}

inline bool is_black_like_char(char c) {
    return c == 'B' || c == 'b' || c == 'X' || c == 'x' || c == '0' || c == '*';
}

inline bool is_white_like_char(char c) {
    return c == 'W' || c == 'w' || c == 'O' || c == 'o' || c == '1';
}

inline bool is_vacant_like_char(char c) {
    return c == '-' || c == '.';
}

inline bool is_pass_like_str(std::string s) {
    return s == "PA" || s == "pa" || s == "PS" || s == "ps";
}

inline bool is_coord_like_chars(char c1, char c2) {
    c1 = c1 | 0x20;
    return 'a' <= c1 && c1 <= 'h' && '1' <= c2 && c2 <= '8';
}

inline int get_coord_from_chars(char c1, char c2) {
    c1 = c1 | 0x20;
    int y = c2 - '1';
    int x = c1 - 'a';
    return HW2_M1 - (y * HW + x);
}



std::string idx_to_coord(int idx) {
    if (idx < 0 || HW2 <= idx)
        return "??";
    int y = HW_M1 - idx / HW;
    int x = HW_M1 - idx % HW;
    const std::string x_coord = "abcdefgh";
    return x_coord[x] + std::to_string(y + 1);
}


std::string ms_to_time(uint64_t t) {
    std::string res;
    uint64_t hour = t / (1000 * 60 * 60);
    t %= 1000 * 60 * 60;
    uint64_t minute = t / (1000 * 60);
    t %= 1000 * 60;
    uint64_t second = t / 1000;
    uint64_t msecond = t % 1000;
    std::ostringstream hour_s;
    hour_s << std::right << std::setw(3) << std::setfill('0') << hour;
    res += hour_s.str();
    res += ":";
    std::ostringstream minute_s;
    minute_s << std::right << std::setw(2) << std::setfill('0') << minute;
    res += minute_s.str();
    res += ":";
    std::ostringstream second_s;
    second_s << std::right << std::setw(2) << std::setfill('0') << second;
    res += second_s.str();
    res += ".";
    std::ostringstream msecond_s;
    msecond_s << std::right << std::setw(3) << std::setfill('0') << msecond;
    res += msecond_s.str();
    return res;
}


std::string ms_to_time_short(uint64_t t) {
    std::string res;
    uint64_t hour = t / (1000 * 60 * 60);
    t -= hour * 1000 * 60 * 60;
    uint64_t minute = t / (1000 * 60);
    t -= minute * 1000 * 60;
    uint64_t second = t / 1000;
    t -= second * 1000;
    std::ostringstream hour_s;
    hour_s << std::right << std::setw(3) << std::setfill('0') << hour;
    res += hour_s.str();
    res += ":";
    std::ostringstream minute_s;
    minute_s << std::right << std::setw(2) << std::setfill('0') << minute;
    res += minute_s.str();
    res += ":";
    std::ostringstream second_s;
    second_s << std::right << std::setw(2) << std::setfill('0') << second;
    res += second_s.str();
    return res;
}

// ===== FILE: Egaroucid/src/engine/common_select.hpp =====

#pragma once

#include "common.hpp"
#include "common_b1.hpp"
#include "common_b2.hpp"
#include "common_b3.hpp"

inline int board_variant_global = 0;

namespace common_select {


inline int get_HW() {
    switch (board_variant_global) {
        case 1: return HW_B1;
        case 2: return HW_B2;
        case 3: return HW_B3;
        default: return HW;
    }
}

inline int get_HW_M1() {
    switch (board_variant_global) {
        case 1: return HW_M1_B1;
        case 2: return HW_M1_B2;
        case 3: return HW_M1_B3;
        default: return HW_M1;
    }
}

inline int get_HW_P1() {
    switch (board_variant_global) {
        case 1: return HW_P1_B1;
        case 2: return HW_P1_B2;
        case 3: return HW_P1_B3;
        default: return HW_P1;
    }
}

inline int get_HW2() {
    switch (board_variant_global) {
        case 1: return HW2_B1;
        case 2: return HW2_B2;
        case 3: return HW2_B3;
        default: return HW2;
    }
}

inline int get_HW2_M1() {
    switch (board_variant_global) {
        case 1: return HW2_M1_B1;
        case 2: return HW2_M1_B2;
        case 3: return HW2_M1_B3;
        default: return HW2_M1;
    }
}

inline int get_HW2_P1() {
    switch (board_variant_global) {
        case 1: return HW2_P1_B1;
        case 2: return HW2_P1_B2;
        case 3: return HW2_P1_B3;
        default: return HW2_P1;
    }
}


inline int get_SCORE_MAX() {
    switch (board_variant_global) {
        case 1: return SCORE_MAX_B1;
        case 2: return SCORE_MAX_B2;
        case 3: return SCORE_MAX_B3;
        default: return SCORE_MAX;
    }
}

inline int get_SCORE_INF() {
    switch (board_variant_global) {
        case 1: return SCORE_INF_B1;
        case 2: return SCORE_INF_B2;
        case 3: return SCORE_INF_B3;
        default: return SCORE_INF;
    }
}

inline int get_INF() {
    switch (board_variant_global) {
        case 1: return INF_B1;
        case 2: return INF_B2;
        case 3: return INF_B3;
        default: return INF;
    }
}

inline int get_N_8BIT() {
    switch (board_variant_global) {
        case 1: return N_8BIT_B1;
        case 2: return N_8BIT_B2;
        case 3: return N_8BIT_B3;
        default: return N_8BIT;
    }
}

inline int get_N_16BIT() {
    switch (board_variant_global) {
        case 1: return N_16BIT_B1;
        case 2: return N_16BIT_B2;
        case 3: return N_16BIT_B3;
        default: return N_16BIT;
    }
}


inline uint64_t get_INVALID_MASK() {
    switch (board_variant_global) {
        case 1: return INVALID_MASK_B1;
        case 2: return INVALID_MASK_B2;
        case 3: return INVALID_MASK_B3;
        default: return INVALID_MASK;
    }
}

inline int get_N_INVALID() {
    switch (board_variant_global) {
        case 1: return N_INVALID_B1;
        case 2: return N_INVALID_B2;
        case 3: return N_INVALID_B3;
        default: return N_INVALID;
    }
}

inline uint64_t get_LEGAL_UNDEFINED() {
    switch (board_variant_global) {
        case 1: return LEGAL_UNDEFINED_B1;
        case 2: return LEGAL_UNDEFINED_B2;
        case 3: return LEGAL_UNDEFINED_B3;
        default: return LEGAL_UNDEFINED;
    }
}


inline int get_N_CELL_TYPE() {
    switch (board_variant_global) {
        case 1: return N_CELL_TYPE_B1;
        case 2: return N_CELL_TYPE_B2;
        case 3: return N_CELL_TYPE_B3;
        default: return N_CELL_TYPE;
    }
}

inline const uint64_t* get_cell_type_mask() {
    switch (board_variant_global) {
        case 1: return cell_type_mask_b1;
        case 2: return cell_type_mask_b2;
        case 3: return cell_type_mask_b3;
        default: return cell_type_mask;
    }
}

inline const int* get_cell_type_map() {
    switch (board_variant_global) {
        case 1: return cell_type_b1;
        case 2: return cell_type_b2;
        case 3: return cell_type_b3;
        default: return cell_type;
    }
}


inline const uint64_t* get_bit_around() {
    switch (board_variant_global) {
        case 1: return bit_around_b1;
        case 2: return bit_around_b2;
        case 3: return bit_around_b3;
        default: return bit_around;
    }
}

inline const uint64_t* get_bit_radiation() {
    switch (board_variant_global) {
        case 1: return bit_radiation_b1;
        case 2: return bit_radiation_b2;
        case 3: return bit_radiation_b3;
        default: return bit_radiation;
    }
}


inline int get_BLACK() {
    switch (board_variant_global) {
        case 1: return BLACK_B1;
        case 2: return BLACK_B2;
        case 3: return BLACK_B3;
        default: return BLACK;
    }
}

inline int get_WHITE() {
    switch (board_variant_global) {
        case 1: return WHITE_B1;
        case 2: return WHITE_B2;
        case 3: return WHITE_B3;
        default: return WHITE;
    }
}

inline int get_VACANT() {
    switch (board_variant_global) {
        case 1: return VACANT_B1;
        case 2: return VACANT_B2;
        case 3: return VACANT_B3;
        default: return VACANT;
    }
}


inline uint64_t get_tim() {
    switch (board_variant_global) {
        case 1: return tim_b1();
        case 2: return tim_b2();
        case 3: return tim_b3();
        default: return tim();
    }
}

inline uint32_t get_myrand_uint() {
    switch (board_variant_global) {
        case 1: return myrand_uint_b1();
        case 2: return myrand_uint_b2();
        case 3: return myrand_uint_b3();
        default: return myrand_uint();
    }
}

inline uint32_t get_myrand_uint_rev() {
    switch (board_variant_global) {
        case 1: return myrand_uint_rev_b1();
        case 2: return myrand_uint_rev_b2();
        case 3: return myrand_uint_rev_b3();
        default: return myrand_uint_rev();
    }
}

inline uint64_t get_myrand_ull() {
    switch (board_variant_global) {
        case 1: return myrand_ull_b1();
        case 2: return myrand_ull_b2();
        case 3: return myrand_ull_b3();
        default: return myrand_ull();
    }
}


inline int get_pop_count_ull(uint64_t x) {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_popcountll(x);
#else
    x = x - ((x >> 1) & 0x5555555555555555ULL);
    x = (x & 0x3333333333333333ULL) + ((x >> 2) & 0x3333333333333333ULL);
    x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0FULL;
    return static_cast<int>((x * 0x0101010101010101ULL) >> 56);
#endif
}
} 

// ===== FILE: Egaroucid/src/engine/endsearch_common.hpp =====



#pragma once
#include <iostream>
#include <vector>
#include <functional>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "search.hpp"
#if USE_SIMD
#ifdef _MSC_VER
#include <intrin.h>
#else
#include <x86intrin.h>
#endif
#endif

#if USE_END_PO
const uint8_t parity_case[64] = {        
      0,   0,   1,   9,   2,  10,  11,   3,
      0,   0,   0,   0,   4,   4,   5,   5,
      1,   0,   1,   0,   6,   7,   6,   7,
      9,   0,   0,   9,   8,   0,   0,   8,
      2,   4,   6,   8,   2,   4,   6,   8,
     10,   4,   7,   0,   4,  10,   0,   7,
     11,   5,   6,   0,   6,   0,  11,   5,
      3,   5,   7,   8,   8,   7,   5,   3
};

#if USE_SIMD
union V4SI {
    unsigned int ui[4];
    __m128i v4;
};
const V4SI parity_ordering_shuffle_mask_last4[] = {      	
    {{ 0x00010203, 0x01000203, 0x02000103, 0x03000102 }},   
    {{ 0x00010203, 0x01000203, 0x02010003, 0x03010002 }},   
    {{ 0x00020103, 0x01020003, 0x02000103, 0x03020100 }},   
    {{ 0x00030201, 0x01030200, 0x02030100, 0x03000102 }},   
    {{ 0x00020103, 0x02000103, 0x01000203, 0x03000201 }},   
    {{ 0x00030201, 0x03000201, 0x02000301, 0x01000302 }},   
    {{ 0x02010003, 0x01020003, 0x00020103, 0x03020100 }},   
    {{ 0x03010200, 0x01030200, 0x02030100, 0x00030102 }},   
    {{ 0x02030001, 0x03020001, 0x00020301, 0x01020300 }},   
    {{ 0x00010203, 0x01000203, 0x02030100, 0x03020100 }},   
    {{ 0x00020103, 0x01030200, 0x02000103, 0x03010002 }},   
    {{ 0x00030201, 0x01020003, 0x02010003, 0x03000102 }}    
};

#else
const uint16_t parity_ordering_last3[] = {
    0x0000, 
    0x1100, 
    0x2011, 
    0x0222, 
    0x0000, 
    0x0000, 
    0x0000, 
    0x0000, 
    0x0000, 
    0x2200, 
    0x1021, 
    0x0112  
};
#endif
inline uint64_t empty1_bb(uint64_t player, uint64_t opponent) {
    uint64_t bn = ~(player | opponent);
    uint64_t t0 = (bn & 0x7f7f7f7f7f7f7f7fULL) << 1;
    uint64_t t1 = (bn & 0xfefefefefefefefeULL) >> 1;
    uint64_t e1 = t0 | t1;
    t0 = bn | e1;
    t1 = t0 << 8;
    t0 >>= 8;
    return ~(e1 | t0 | t1) & bn;
}
#endif

const uint64_t bb_adjacent_sq[64] = {
    0x0000000000000302ULL, 0x0000000000000705ULL, 0x0000000000000e0aULL, 0x0000000000001c14ULL, 0x0000000000003828ULL, 0x0000000000007050ULL, 0x000000000000e0a0ULL, 0x000000000000c040ULL,
    0x0000000000030203ULL, 0x0000000000070507ULL, 0x00000000000e0a0eULL, 0x00000000001c141cULL, 0x0000000000382838ULL, 0x0000000000705070ULL, 0x0000000000e0a0e0ULL, 0x0000000000c040c0ULL,
    0x0000000003020300ULL, 0x0000000007050700ULL, 0x000000000e0a0e00ULL, 0x000000001c141c00ULL, 0x0000000038283800ULL, 0x0000000070507000ULL, 0x00000000e0a0e000ULL, 0x00000000c040c000ULL,
    0x0000000302030000ULL, 0x0000000705070000ULL, 0x0000000e0a0e0000ULL, 0x0000001c141c0000ULL, 0x0000003828380000ULL, 0x0000007050700000ULL, 0x000000e0a0e00000ULL, 0x000000c040c00000ULL,
    0x0000030203000000ULL, 0x0000070507000000ULL, 0x00000e0a0e000000ULL, 0x00001c141c000000ULL, 0x0000382838000000ULL, 0x0000705070000000ULL, 0x0000e0a0e0000000ULL, 0x0000c040c0000000ULL,
    0x0003020300000000ULL, 0x0007050700000000ULL, 0x000e0a0e00000000ULL, 0x001c141c00000000ULL, 0x0038283800000000ULL, 0x0070507000000000ULL, 0x00e0a0e000000000ULL, 0x00c040c000000000ULL,
    0x0302030000000000ULL, 0x0705070000000000ULL, 0x0e0a0e0000000000ULL, 0x1c141c0000000000ULL, 0x3828380000000000ULL, 0x7050700000000000ULL, 0xe0a0e00000000000ULL, 0xc040c00000000000ULL,
    0x0203000000000000ULL, 0x0507000000000000ULL, 0x0a0e000000000000ULL, 0x141c000000000000ULL, 0x2838000000000000ULL, 0x5070000000000000ULL, 0xa0e0000000000000ULL, 0x40c0000000000000ULL,
};

inline bool is_1empty(uint32_t place, uint64_t b) {
    return (bb_adjacent_sq[place] & b) == 0;
}

#if USE_SIMD


#if defined(_MSC_VER) || defined(__clang__)
#define	vectorcall	__vectorcall
#else
#define	vectorcall
#endif

#define	SWAP64	0x4e	
#define	DUPHI	0xee


static uint64_t X_TO_BIT[64];

union V4DI {
    uint64_t u64[4];
    __m256i v4;
    __m128i v2[2];
};
static V4DI mask_dvhd[64];

static inline int vectorcall TESTZ_FLIP(__m128i X) { return _mm_testz_si128(X, X); }


static inline int end_evaluate(uint64_t b, int e) {
    int score = pop_count_ull(b) * 2 - HW2;	
    int diff = score + e;		

    if (diff == 0) {
        score = diff;
    } else if (diff > 0) {
        score = diff + e;
    }
    return score;
}


static inline __m128i vectorcall board_flip_next(__m128i OP, int x, __m128i flipped)
{
    OP = _mm_xor_si128(OP, _mm_or_si128(flipped, _mm_loadl_epi64((__m128i*) & X_TO_BIT[x])));
    return _mm_shuffle_epi32(OP, SWAP64);
}
#endif

void endsearch_init() {
#if USE_SIMD
    for (int i = 0; i < 64; ++i) {
            
        X_TO_BIT[i] = 1ULL << i;
            
        int x = i & 7;
        int y = i >> 3;
        int s = (7 - y) - x;
        uint64_t d = (s >= 0) ? 0x0102040810204080 >> (s * 8) : 0x0102040810204080 << (-s * 8);
        mask_dvhd[i].u64[0] = d;
        mask_dvhd[i].u64[1] = 0xffULL << (i & 0x38);
        s = y - x;
        d = (s >= 0) ? 0x8040201008040201 << (s * 8) : 0x8040201008040201 >> (-s * 8);
        mask_dvhd[i].u64[2] = 0x0101010101010101 << (i & 7);
        mask_dvhd[i].u64[3] = d;
    }
#endif
}

// ===== FILE: Egaroucid/src/engine/endsearch.hpp =====



#pragma once

#if USE_SIMD
#include "endsearch_last_simd.hpp"
#else
#include "endsearch_last_generic.hpp"
#endif
#include "endsearch_nws.hpp"

// ===== FILE: Egaroucid/src/engine/endsearch_last_generic.hpp =====


#pragma once
#include "setting.hpp"
#include "search.hpp"
#include "endsearch_common.hpp"

inline int last1(Search *search, uint64_t player, int alpha, uint_fast8_t p0) {
    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[63];
#endif
    int n_flip, score;
#if LAST1_OBVIOUS_PASS_OPT
    if ((~player & bit_around[p0]) == 0) { 
        ++search->n_nodes;
#if USE_SEARCH_STATISTICS
        ++search->n_nodes_discs[63];
#endif
        score = 2 * (pop_count_ull(player) + 1) - HW2;	
        int score2 = score - 2;	
         if (score <= 0)
            score = score2;
        if (score > alpha) {
            n_flip = count_last_flip(~player, p0);
            if (n_flip)
                score = score2 - 2 * n_flip;
        }
    } else {
#endif
#if LAST_FLIP_PASS_OPT
        const int x = p0 & 7;
        const int y = p0 >> 3;
        const int d7t = std::min(y, 7 - x);
        const int d9t = std::min(y, x);
        uint_fast8_t d7 = join_d7_line(player, x + y);
        uint_fast8_t d9 = join_d9_line(player, x + 7 - y);
        int n_flip_both = 
            N_LAST_FLIP_BOTH[join_h_line(player, y)][x] + 
            N_LAST_FLIP_BOTH[join_v_line(player, x)][y] + 
            N_LAST_FLIP[d7][d7t] + 
            N_LAST_FLIP[d9][d9t];  
        n_flip = n_flip_both & 0xff;
#else
        n_flip = count_last_flip(player, p0);
#endif
        score = 2 * (pop_count_ull(player) + n_flip + 1) - HW2;	
        if (n_flip == 0) {
            ++search->n_nodes;
#if USE_SEARCH_STATISTICS
            ++search->n_nodes_discs[63];
#endif
            int score2 = score - 2;	
            if (score <= 0)
                score = score2;
            if (score > alpha) {
#if LAST_FLIP_PASS_OPT
                n_flip = 
                    (n_flip_both >> 8) + 
                    N_LAST_FLIP[(0xff >> -std::min((x + y) - 7, 7 - (x + y))) ^ d7][d7t] + 
                    N_LAST_FLIP[(0xff >> -std::min(x - y, y - x)) ^ d9][d9t]; 
#else
                n_flip = count_last_flip(~player, p0);
#endif
                if (n_flip)
                    score = score2 - 2 * n_flip;
            }
        }
#if LAST1_OBVIOUS_PASS_OPT
    }
#endif
    return score;
}

static int last2(Search *search, int alpha, int beta, uint_fast8_t p0, uint_fast8_t p1, Board board) {
    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[62];
#endif
    int v;
    Flip flip;
 
    if ((bit_around[p0] & board.opponent) && calc_flip(&flip, &board, p0)) { 
        v = last1(search, board.opponent ^ flip.flip, alpha, p1);

        if ((v > alpha) && (bit_around[p1] & board.opponent) && calc_flip(&flip, &board, p1)) { 
            int g = last1(search, board.opponent ^ flip.flip, alpha, p0);
            if (v > g) {
                v = g;
            }
        }
    } else if ((bit_around[p1] & board.opponent) && calc_flip(&flip, &board, p1)) { 
        v = last1(search, board.opponent ^ flip.flip, alpha, p0);
    } else {	
        ++search->n_nodes;
#if USE_SEARCH_STATISTICS
        ++search->n_nodes_discs[62];
#endif
        alpha = -beta;
        if ((((board.invalid_mask >> p0) & 1ULL) == 0ULL)
    && flip.calc_flip(board.opponent, board.player, p0)) {  
            v = last1(search, board.player ^ flip.flip, alpha, p1);

            if ((v > alpha) &&
    (((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
flip.calc_flip(board.opponent, board.player, p1)) { 
                int g = last1(search, board.player ^ flip.flip, alpha, p0);
                if (v > g) {
                    v = g;
                }
            }
        } else if ((((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
           flip.calc_flip(board.opponent, board.player, p1)) { 
            v = last1(search, board.player ^ flip.flip, alpha, p0);
        } else { 
            v = end_evaluate(&board, 2);
        }
        v = -v;
    }
    return v;
}

static int last3(Search *search, int alpha, int beta, uint_fast8_t p0, uint_fast8_t p1, uint_fast8_t p2, Board board) {
#if USE_END_PO
    uint64_t empties = ~(search->board.player | search->board.opponent | search->board.invalid_mask);
    if (is_1empty(p2, empties)) {
        std::swap(p2, p0);
    } else if (is_1empty(p1, empties)) {
        std::swap(p1, p0);
    }
#endif

    Flip flip;
    Board board2;
    int v = -SCORE_INF;
    int pol = 1;
    do {
        ++search->n_nodes;
#if USE_SEARCH_STATISTICS
        ++search->n_nodes_discs[61];
#endif
        if ((bit_around[p0] & board.opponent) && calc_flip(&flip, &board, p0)) {
            board.move_copy(&flip, &board2);
            v = last2(search, alpha, beta, p1, p2, board2);
            if (beta <= v) {
                return v * pol;
            }
            if (alpha < v) {
                alpha = v;
            }
        }

        int g;
        if ((bit_around[p1] & board.opponent) && calc_flip(&flip, &board, p1)) {
            board.move_copy(&flip, &board2);
            g = last2(search, alpha, beta, p2, p0, board2);
            if (beta <= g) {
                return g * pol;
            }
            if (v < g) {
                v = g;
            }
            if (alpha < g) {
                alpha = g;
            }
        }

        if ((bit_around[p2] & board.opponent) && calc_flip(&flip, &board, p2)) {
            board.move_copy(&flip, &board2);
            g = last2(search, alpha, beta, p1, p0, board2);
            if (v < g) {
                v = g;
            }
            return v * pol;
        }

        if (v > -SCORE_INF) {
            return v * pol;
        }

        board.pass();
        int t = alpha;  alpha = -beta;  beta = -t;
    } while ((pol = -pol) < 0);

    return end_evaluate_odd(&board, 3);	
}

int last4(Search *search, int alpha, int beta) {
    uint64_t empties = ~(search->board.player | search->board.opponent | search->board.invalid_mask);
    uint_fast8_t p0, p1, p2, p3;

#if USE_LAST4_SC
    int stab_res = stability_cut_last4(search, &alpha, beta);
    if (stab_res != SCORE_UNDEFINED) {
        return stab_res;
    }
#endif
#if USE_END_PO
    uint64_t e1 = empty1_bb(search->board.player, search->board.opponent);
e1 &= ~search->board.invalid_mask;
    if (!e1) {
        e1 = empties;
    }
    empties &= ~e1;

    p0 = first_bit(&e1);
    if (!(e1 &= e1 - 1)) {
        e1 = empties;
    }
    p1 = first_bit(&e1);
    if (!(e1 &= e1 - 1)) {
        e1 = empties;
    }
    p2 = first_bit(&e1);
    if ((e1 &= e1 - 1)) {
        p3 = first_bit(&e1);
    } else {
        p3 = first_bit(&empties);
    }
#else
    p0 = first_bit(&empties);
    p1 = next_bit(&empties);
    p2 = next_bit(&empties);
    p3 = next_bit(&empties);
#endif

    Flip flip;
    Board board3, board4;
    search->board.copy(&board4);
    int v = SCORE_INF;	
    int pol = 1;
    do {
        ++search->n_nodes;
#if USE_SEARCH_STATISTICS
        ++search->n_nodes_discs[60];
#endif
        if ((bit_around[p0] & board4.opponent) && calc_flip(&flip, &board4, p0)) {
            board4.move_copy(&flip, &board3);
            v = last3(search, alpha, beta, p1, p2, p3, board3);
            if (alpha >= v) {
                return v * pol;
            }
            if (beta > v) {
                beta = v;
            }
        }

        int g;
        if ((bit_around[p1] & board4.opponent) && calc_flip(&flip, &board4, p1)) {
            board4.move_copy(&flip, &board3);
            g = last3(search, alpha, beta, p0, p2, p3, board3);
            if (alpha >= g) {
                return g * pol;
            }
            if (v > g) {
                v = g;
            }
            if (beta > g) {
                beta = g;
            }
        }

        if ((bit_around[p2] & board4.opponent) && calc_flip(&flip, &board4, p2)) {
            board4.move_copy(&flip, &board3);
            g = last3(search, alpha, beta, p0, p1, p3, board3);
            if (alpha >= g) {
                return g * pol;
            }
            if (v > g) {
                v = g;
            }
            if (beta > g) {
                beta = g;
            }
        }

        if ((bit_around[p3] & board4.opponent) && calc_flip(&flip, &board4, p3)) {
            board4.move_copy(&flip, &board3);
            g = last3(search, alpha, beta, p0, p1, p2, board3);
            if (v > g) {
                v = g;
            }
            return v * pol;
        }

        if (v < SCORE_INF) {
            return v * pol;
        }
        board4.pass();
        int t = alpha;  alpha = -beta;  beta = -t;
    } while ((pol = -pol) < 0);

    return -end_evaluate(&search->board, 4);	
}

// ===== FILE: Egaroucid/src/engine/endsearch_last_simd.hpp =====


#pragma once
#ifdef _MSC_VER
#include <intrin.h>
#else
#include <x86intrin.h>
#endif
#include "setting.hpp"
#include "search.hpp"
#include "endsearch_common.hpp"

static inline int vectorcall last1(Search *search, __m128i PO, int alpha, int place) {
    __m128i M0 = mask_dvhd[place].v2[0];
    __m128i M1 = mask_dvhd[place].v2[1];
    __m128i PP = _mm_shuffle_epi32(PO, DUPHI);
    __m128i II = _mm_sad_epu8(_mm_and_si128(PP, M0), _mm_setzero_si128());
    const int x = place & 7;
    const int y = place >> 3;

    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[63];
#endif
#if LAST_FLIP_PASS_OPT
    uint_fast16_t n_flip_both = N_LAST_FLIP_BOTH[_mm_extract_epi16(II, 4)][x];
    n_flip_both += N_LAST_FLIP[_mm_cvtsi128_si32(II)][x];
    int t = _mm_movemask_epi8(_mm_sub_epi8(_mm_setzero_si128(), _mm_and_si128(PP, M1)));
    n_flip_both += N_LAST_FLIP[t >> 8][y];
    n_flip_both += N_LAST_FLIP_BOTH[t & 0xFF][y];
    uint_fast8_t n_flip = n_flip_both & 0xff;
#else
    uint_fast8_t n_flip = N_LAST_FLIP[_mm_extract_epi16(II, 4)][x];
    n_flip += N_LAST_FLIP[_mm_cvtsi128_si32(II)][x];
    int t = _mm_movemask_epi8(_mm_sub_epi8(_mm_setzero_si128(), _mm_and_si128(PP, M1)));
    n_flip += N_LAST_FLIP[t >> 8][y];
    n_flip += N_LAST_FLIP[t & 0xFF][y];
#endif
    int score = 2 * (pop_count_ull(_mm_cvtsi128_si64(PP)) + n_flip + 1) - HW2;	

    if (n_flip == 0) {
        ++search->n_nodes;
        #if USE_SEARCH_STATISTICS
            ++search->n_nodes_discs[63];
        #endif
        int score2 = score - 2;	
        if (score <= 0) {
            score = score2;
        }
        if (score > alpha) {	
            II = _mm_sad_epu8(_mm_andnot_si128(PP, M0), _mm_setzero_si128());
#if LAST_FLIP_PASS_OPT
            n_flip = n_flip_both >> 8;
            n_flip += N_LAST_FLIP[_mm_cvtsi128_si32(II)][x];
            t = _mm_movemask_epi8(_mm_sub_epi8(_mm_setzero_si128(), _mm_andnot_si128(PP, M1)));
            n_flip += N_LAST_FLIP[t >> 8][y];
#else
            n_flip = N_LAST_FLIP[_mm_extract_epi16(II, 4)][x];
            n_flip += N_LAST_FLIP[_mm_cvtsi128_si32(II)][x];
            t = _mm_movemask_epi8(_mm_sub_epi8(_mm_setzero_si128(), _mm_andnot_si128(PP, M1)));
            n_flip += N_LAST_FLIP[t >> 8][y];
            n_flip += N_LAST_FLIP[t & 0xFF][y];
#endif
            if (n_flip != 0) {
                score = score2 - 2 * n_flip;
            }
        }
    }

    return score;
}

static int vectorcall last2(Search *search, __m128i OP, int alpha, int beta, uint32_t p0, uint32_t p1) {
    __m128i flipped;
    uint64_t opponent = _mm_extract_epi64(OP, 1);

    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[62];
#endif
    int v;
    if (bit_around[p0] & opponent) { 
        if ((((board.invalid_mask >> p0) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p0))) {
            v = last1(search, _mm_xor_si128(OP, flipped), alpha, p1);
    
            if ((v > alpha) && (bit_around[p1] & opponent) &&
    (((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p1))) { 
                int g = last1(search, _mm_xor_si128(OP, flipped), alpha, p0);
                if (v > g) {
                    v = g;
                }
            }
            return v;
        }
    }
    if (bit_around[p1] & opponent) { 
        if ((((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p1))) {
            v = last1(search, _mm_xor_si128(OP, flipped), alpha, p0);
            return v;
        }
    }

    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[62];
#endif
    alpha = -beta;
    __m128i PO = _mm_shuffle_epi32(OP, SWAP64);
    if ((((board.invalid_mask >> p0) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(PO, p0))) { 
        v = last1(search, _mm_xor_si128(PO, flipped), alpha, p1);

        if ((v > alpha) &&
    (((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(PO, p1))) { 
            int g = last1(search, _mm_xor_si128(PO, flipped), alpha, p0);
            if (v > g) {
                v = g;
            }
        }
    } else if ((((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
           !TESTZ_FLIP(flipped = Flip::calc_flip(PO, p1))) { 
        v = last1(search, _mm_xor_si128(PO, flipped), alpha, p0);
    } else {	
        v = end_evaluate(_mm_extract_epi64(PO, 1), 2);
    }
    v = -v;
    return v;
}

static int vectorcall last3(Search *search, __m128i OP, int alpha, int beta, uint32_t p0, uint32_t p1, uint32_t p2) {
    __m128i flipped;
    uint64_t opponent;

    uint64_t empties = ~(search->board.player | search->board.opponent | search->board.invalid_mask);
    if (is_1empty(p2, empties)) {
        std::swap(p2, p0);
    } else if (is_1empty(p1, empties)) {
        std::swap(p1, p0);
    }

    int v = -SCORE_INF;
    int pol = 1;
    do {
        ++search->n_nodes;
#if USE_SEARCH_STATISTICS
        ++search->n_nodes_discs[61];
#endif
        opponent = _mm_extract_epi64(OP, 1);
        int x = p0;
        if (bit_around[x] & opponent) {
            if ((((board.invalid_mask >> x) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, x))) {
                v = last2(search, board_flip_next(OP, x, flipped), alpha, beta, p1, p2);
                if (beta <= v) {
                    return v * pol;
                }
                if (alpha < v) {
                    alpha = v;
                }
            }
        }

        int g;
        x = p1;
        if (bit_around[x] & opponent) {
            if ((((board.invalid_mask >> x) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, x))) {
                g = last2(search, board_flip_next(OP, x, flipped), alpha, beta, p2, p0);	
                if (beta <= g) {
                    return g * pol;
                }
                if (v < g) {
                    v = g;
                }
                if (alpha < g) {
                    alpha = g;
                }
            }
        }

        x = p2;
        if (bit_around[x] & opponent) {
            if ((((board.invalid_mask >> x) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, x))) {
                g = last2(search, board_flip_next(OP, x, flipped), alpha, beta, p1, p0);	
                if (v < g) {
                    v = g;
                }
                return v * pol;
            }
        }

        if (v > -SCORE_INF) {
            return v * pol;
        }

        OP = _mm_shuffle_epi32(OP, SWAP64);	
        int t = alpha;  alpha = -beta;  beta = -t;
    } while ((pol = -pol) < 0);

    return end_evaluate(opponent, 3);	
}

int last4(Search *search, int alpha, int beta) {
    __m128i flipped;
    uint64_t opponent;
    __m128i OP = _mm_loadu_si128((__m128i*) & search->board);
    uint64_t empties = ~(search->board.player | search->board.opponent | search->board.invalid_mask);
    uint_fast8_t p0, p1, p2, p3;

#if USE_LAST4_SC
    int stab_res = stability_cut_last4(search, &alpha, beta);
    if (stab_res != SCORE_UNDEFINED) {
        return stab_res;
    }
#endif
    #if USE_END_PO
        uint64_t e1 = empty1_bb(search->board.player, search->board.opponent);
e1 &= ~search->board.invalid_mask;
        if (!e1) {
            e1 = empties;
        }
        empties &= ~e1;
    
        p0 = first_bit(&e1);
        if (!(e1 &= e1 - 1)) {
            e1 = empties;
        }
        p1 = first_bit(&e1);
        if (!(e1 &= e1 - 1)) {
            e1 = empties;
        }
        p2 = first_bit(&e1);
        if ((e1 &= e1 - 1)) {
            p3 = first_bit(&e1);
        } else {
            p3 = first_bit(&empties);
        }
    #else
        p0 = first_bit(&empties);
        p1 = next_bit(&empties);
        p2 = next_bit(&empties);
        p3 = next_bit(&empties);
    #endif

    int v = SCORE_INF;	
    int pol = 1;
    do {
        ++search->n_nodes;
#if USE_SEARCH_STATISTICS
        ++search->n_nodes_discs[60];
#endif
        opponent = _mm_extract_epi64(OP, 1);
        if (bit_around[p0] & opponent) {
            if ((((board.invalid_mask >> p0) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p0))) {
                v = last3(search, board_flip_next(OP, p0, flipped), alpha, beta, p1, p2, p3);
                if (alpha >= v) {
                    return v * pol;
                }
                if (beta > v) {
                    beta = v;
                }
            }
        }

        int g;
        if (bit_around[p1] & opponent) {
            if ((((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p1))) {
                g = last3(search, board_flip_next(OP, p1, flipped), alpha, beta, p0, p2, p3);
                if (alpha >= g) {
                    return g * pol;
                }
                if (v > g) {
                    v = g;
                }
                if (beta > g) {
                    beta = g;
                }
            }
        }
 
        if (bit_around[p2] & opponent) {
            if ((((board.invalid_mask >> p2) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p2))) {
                g = last3(search, board_flip_next(OP, p2, flipped), alpha, beta, p0, p1, p3);
                if (alpha >= g) {
                    return g * pol;
                }
                if (v > g) {
                    v = g;
                }
                if (beta > g) {
                    beta = g;
                }
            }
        }
 
        if (bit_around[p3] & opponent) {
            if ((((board.invalid_mask >> p3) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p3))) {
                g = last3(search, board_flip_next(OP, p3, flipped), alpha, beta, p0, p1, p2);
                if (v > g) {
                    v = g;
                }
                return v * pol;
            }
        }

        if (v < SCORE_INF) {
            return v * pol;
        }

        OP = _mm_shuffle_epi32(OP, SWAP64);	
        int t = alpha;  alpha = -beta;  beta = -t;
    } while ((pol = -pol) < 0);

    return end_evaluate(_mm_extract_epi64(OP, 1), 4);	
}

// ===== FILE: Egaroucid/src/engine/endsearch_nws.hpp =====



#pragma once
#include <vector>
#include <functional>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "evaluate.hpp"
#include "search.hpp"
#include "move_ordering.hpp"
#include "multi_probcut.hpp"
#include "transposition_table.hpp"
#include "util.hpp"
#include "stability_cutoff.hpp"
#include "endsearch_common.hpp"
#include "parallel.hpp"
#include "ybwc.hpp"
#if USE_SIMD
#include "endsearch_nws_last_simd.hpp"
#else
#include "endsearch_nws_last_generic.hpp"
#endif

constexpr int LOCAL_TT_SIZE = 1024;
constexpr int LOCAL_TT_SIZE_BIT = 10;




int nega_alpha_end_fast_nws(Search *search, int alpha, const bool skipped) {
    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[search->n_discs];
#endif
#if USE_END_SC
    if (!skipped) {
        int stab_res = stability_cut_nws(search, alpha);
        if (stab_res != SCORE_UNDEFINED) {
            return stab_res;
        }
    }
#endif
    uint64_t legal = search->board.get_legal();
    if (legal == 0ULL) {
        if (skipped) {
            return end_evaluate(&search->board);
        }
        search->pass_noeval();
            int v = -nega_alpha_end_fast_nws(search, -alpha - 1, true);
        search->pass_noeval();
        return v;
    }

    Board board0;
    search->board.copy(&board0);
    int v = -SCORE_INF;
    int g;
    Flip flip;
    uint_fast8_t cell;
    uint64_t prioritymoves = legal;
#if USE_END_PO
    prioritymoves &= empty1_bb(search->board.player, search->board.opponent);
    if (prioritymoves == 0) {
        prioritymoves = legal;
    }
#endif
    
    if (search->n_discs == 59) {     
        do {
            legal ^= prioritymoves;
            for (cell = first_bit(&prioritymoves); prioritymoves; cell = next_bit(&prioritymoves)) {
                calc_flip(&flip, &board0, cell);
                board0.move_copy(&flip, &search->board);
                g = last4_nws(search, alpha);
                if (alpha < g) {
                    board0.copy(&search->board);
                    return g;
                }
                if (v < g) {
                    v = g;
                }
            }
        } while ((prioritymoves = legal));
    } else {
        ++search->n_discs;  
        do {
            legal ^= prioritymoves;
            for (cell = first_bit(&prioritymoves); prioritymoves; cell = next_bit(&prioritymoves)) {
                calc_flip(&flip, &board0, cell);
                board0.move_copy(&flip, &search->board);
                g = -nega_alpha_end_fast_nws(search, -alpha - 1, false);
                if (alpha < g) {
                    --search->n_discs;
                    board0.copy(&search->board);
                    return g;
                }
                if (v < g) {
                    v = g;
                }
            }
        } while ((prioritymoves = legal));
        --search->n_discs;
    }
    board0.copy(&search->board);
    return v;
}

struct LocalTTEntry {
    uint64_t player;
    uint64_t opponent;
    int lower;
    int upper;

    bool cmp(Board *board) {
        return board->player == player && board->opponent == opponent;
    }

    void set_score(Board *board, int l, int u) {
        player = board->player;
        opponent = board->opponent;
        lower = l;
        upper = u;
    }
};

static thread_local LocalTTEntry lttable[MID_TO_END_DEPTH - END_FAST_DEPTH][LOCAL_TT_SIZE];

inline uint32_t hash_bb(Board *board) {
#if USE_SIMD && USE_CRC32C_HASH_LTT
    uint64_t res = _mm_crc32_u64(0, board->player);
    res = _mm_crc32_u64(res, board->opponent);
    return res & (LOCAL_TT_SIZE - 1);
#else
    return ((board->player * 0x9dda1c54cfe6b6e9ull) ^ (board->opponent * 0xa2e6c0300831e05aull)) >> (HW2 - LOCAL_TT_SIZE_BIT);
#endif
}

inline LocalTTEntry *get_ltt(Board *board, uint32_t n_discs) {
    return lttable[HW2 - n_discs - END_FAST_DEPTH] + hash_bb(board);
}


int nega_alpha_end_simple_nws(Search *search, int alpha, const bool skipped, uint64_t legal) {
    if (search->n_discs >= HW2 - END_FAST_DEPTH) {
        return nega_alpha_end_fast_nws(search, alpha, skipped);
    }
    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[search->n_discs];
#endif
#if USE_END_SC
    if (!skipped) {
        int stab_res = stability_cut_nws(search, alpha);
        if (stab_res != SCORE_UNDEFINED) {
            return stab_res;
        }
    }
#endif
    if (legal == LEGAL_UNDEFINED) {
        legal = search->board.get_legal();
    }
    int v = -SCORE_INF;
    if (legal == 0ULL) {
        if (skipped) {
            return end_evaluate(&search->board);
        }
        search->pass_noeval();
            v = -nega_alpha_end_simple_nws(search, -alpha - 1, true, LEGAL_UNDEFINED);
        search->pass_noeval();
        return v;
    }
    const int canput = pop_count_ull(legal);
    Flip_value move_list[END_SIMPLE_DEPTH];
    int idx = 0;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&move_list[idx].flip, &search->board, cell);
        if (move_list[idx].flip.flip == search->board.opponent) {
            return SCORE_MAX;
        }
        ++idx;
    }
    int g;
    
    uint64_t done = 0;
    if (canput > 1) {
        for (int i = 0; i < canput; ++i) {
            Flip_value *flip_value = move_list + i;
            flip_value->value = 0;
            if (search->parity & cell_div4[flip_value->flip.pos]) {
                flip_value->value += W_END_NWS_SIMPLE_PARITY;
            }
            search->move_noeval(&flip_value->flip);
                Board nboard = search->board;
                LocalTTEntry *tt = get_ltt(&nboard, search->n_discs);
                if (tt->cmp(&nboard)) {
                    if (alpha < tt->lower) {
                        v = tt->lower;
                        search->undo_noeval(&flip_value->flip);
                        return v;
                    }
                    if (tt->upper <= alpha) {
                        if (v < tt->upper) {
                            v = tt->upper;
                        }
                        done |= (1ULL << flip_value->flip.pos);
                        search->undo_noeval(&flip_value->flip);
                        continue;
                    }
                }
                flip_value->n_legal = search->board.get_legal();
                int nm = get_n_moves_cornerX2(flip_value->n_legal);
                if (nm <= 1) {
                    g = -nega_alpha_end_simple_nws(search, -alpha - 1, false, flip_value->n_legal);
                    search->undo_noeval(&flip_value->flip);
                    if (v < g) {
                        v = g;
                        if (alpha < v) {
                            tt->set_score(&nboard, v, 64);
                            return v;
                        }
                    }
                    tt->set_score(&nboard, -64, g);
                    done |= (1ULL << flip_value->flip.pos);
                    continue;
                }
                flip_value->value += (MO_OFFSET_L_PM - nm) * W_END_NWS_SIMPLE_MOBILITY;
            search->undo_noeval(&flip_value->flip);
        }
    }

    for (int move_idx = 0; move_idx < canput; ++move_idx) {
        swap_next_best_move(move_list, move_idx, canput);
        if ((1ULL << move_list[move_idx].flip.pos) & done) {
            continue;
        }
        search->move_noeval(&move_list[move_idx].flip);
            Board nboard = search->board;
            LocalTTEntry *tt = get_ltt(&nboard, search->n_discs);
            g = -nega_alpha_end_simple_nws(search, -alpha - 1, false, move_list[move_idx].n_legal);
        search->undo_noeval(&move_list[move_idx].flip);
        if (v < g) {
            v = g;
            if (alpha < v) {
                tt->set_score(&nboard, v, 64);
                break;
            }
        }
        tt->set_score(&nboard, -64, g);
    }
    return v;
}


int nega_alpha_end_nws(Search *search, int alpha, const bool skipped, uint64_t legal) {
    if (search->n_discs >= HW2 - END_SIMPLE_DEPTH) {
        return nega_alpha_end_simple_nws(search, alpha, skipped, legal);
    }
    ++search->n_nodes;
    #if USE_SEARCH_STATISTICS
        ++search->n_nodes_discs[search->n_discs];
    #endif
    #if USE_END_SC
        if (!skipped) {
            int stab_res = stability_cut_nws(search, alpha);
            if (stab_res != SCORE_UNDEFINED) {
                return stab_res;
            }
        }
    #endif
    if (legal == LEGAL_UNDEFINED) {
        legal = search->board.get_legal();
    }
    int v = -SCORE_INF;
    if (legal == 0ULL) {
        if (skipped) {
            return end_evaluate(&search->board);
        }
        search->pass_endsearch();
            v = -nega_alpha_end_nws(search, -alpha - 1, true, LEGAL_UNDEFINED);
        search->pass_endsearch();
        return v;
    }
    int best_move = MOVE_UNDEFINED;
    int g;
    const int canput = pop_count_ull(legal);
    std::vector<Flip_value> move_list(canput);
    int idx = 0;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&move_list[idx].flip, &search->board, cell);
        if (move_list[idx].flip.flip == search->board.opponent) {
            return SCORE_MAX;
        }
        ++idx;
    }
    uint64_t done = 0;
    if (move_list.size() > 1) {
        for (int i = 0; i < canput; ++i) {
            Flip_value *flip_value = &move_list[i];
            flip_value->value = 0;
            search->move_endsearch(&flip_value->flip);
                Board nboard = search->board;
                LocalTTEntry *tt = get_ltt(&nboard, search->n_discs);
                if (tt->cmp(&nboard)) {
                    if (alpha < tt->lower) {
                        best_move = flip_value->flip.pos;
                        v = tt->lower;
                        search->undo_endsearch(&flip_value->flip);
                        return v;
                    }
                    if (tt->upper <= alpha) {
                        if (v < tt->upper) {
                            v = tt->upper;
                        }
                        done |= (1ULL << flip_value->flip.pos);
                        search->undo_endsearch(&flip_value->flip);
                        continue;
                    }
                }
                flip_value->n_legal = search->board.get_legal();
                int nm = get_n_moves_cornerX2(flip_value->n_legal);
                if (nm <= 1) {
                    g = -nega_alpha_end_nws(search, -alpha - 1, false, flip_value->n_legal);
                    search->undo_endsearch(&flip_value->flip);
                    if (v < g) {
                        v = g;
                        best_move = flip_value->flip.pos;
                        if (alpha < v) {
                            tt->set_score(&nboard, v, 64);
                            return v;
                        }
                    }
                    tt->set_score(&nboard, -64, g);
                    done |= (1ULL << flip_value->flip.pos);
                    continue;
                }
                flip_value->value += (MO_OFFSET_L_PM - nm) * W_END_NWS_MOBILITY;
                flip_value->value += (MO_OFFSET_L_PM - mid_evaluate_move_ordering_end(search)) * W_END_NWS_VALUE;
            search->undo_endsearch(&flip_value->flip);
        }
    }
    for (int move_idx = 0; move_idx < canput; ++move_idx) {
        swap_next_best_move(move_list, move_idx, canput);
        if ((1ULL << move_list[move_idx].flip.pos) & done) {
            continue;
        }
        search->move_endsearch(&move_list[move_idx].flip);
            Board nboard = search->board;
            LocalTTEntry *tt = get_ltt(&nboard, search->n_discs);
            g = -nega_alpha_end_nws(search, -alpha - 1, false, move_list[move_idx].n_legal);
        search->undo_endsearch(&move_list[move_idx].flip);
        if (v < g) {
            v = g;
            best_move = move_list[move_idx].flip.pos;
            if (alpha < v) {
                tt->set_score(&nboard, v, 64);
                break;
            }
        }
        tt->set_score(&nboard, -64, g);
    }
    return v;
}

// ===== FILE: Egaroucid/src/engine/endsearch_nws_last_generic.hpp =====


#pragma once
#include "setting.hpp"
#include "search.hpp"
#include "endsearch_common.hpp"

static int last2_nws(Search *search, int alpha, uint_fast8_t p0, uint_fast8_t p1, Board board) {
    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[62];
#endif
    int v;
    Flip flip;
    
    if ((bit_around[p0] & board.opponent) && calc_flip(&flip, &board, p0)) { 
        v = last1(search, board.opponent ^ flip.flip, alpha, p1);

        if ((v > alpha) && (bit_around[p1] & board.opponent) && calc_flip(&flip, &board, p1)) { 
            int g = last1(search, board.opponent ^ flip.flip, alpha, p0);
            if (v > g) {
                v = g;
            }
        }
    } else if ((bit_around[p1] & board.opponent) && calc_flip(&flip, &board, p1)) { 
        v = last1(search, board.opponent ^ flip.flip, alpha, p0);
    } else { 
        ++search->n_nodes;
#if USE_SEARCH_STATISTICS
        ++search->n_nodes_discs[62];
#endif
        alpha = -alpha - 1;
        if ((((board.invalid_mask >> p0) & 1ULL) == 0ULL) &&
    flip.calc_flip(board.opponent, board.player, p0)) { 
            v = last1(search, board.player ^ flip.flip, alpha, p1);

            if ((v > alpha) &&
    (((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
    flip.calc_flip(board.opponent, board.player, p1)) { 
                int g = last1(search, board.player ^ flip.flip, alpha, p0);
                if (v > g) {
                    v = g;
                }
            }
         } else if ((((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
           flip.calc_flip(board.opponent, board.player, p1)) { 
            v = last1(search, board.player ^ flip.flip, alpha, p0);
        } else { 
            v = end_evaluate(&board, 2);
        }
        v = -v;
    }
    return v;
}

static int last3_nws(Search *search, int alpha, uint_fast8_t p0, uint_fast8_t p1, uint_fast8_t p2, Board board) {
#if USE_END_PO
uint64_t empties = ~(search->board.player | search->board.opponent | search->board.invalid_mask);    if (is_1empty(p2, empties)) {
        std::swap(p2, p0);
    } else if (is_1empty(p1, empties)) {
        std::swap(p1, p0);
    }
#endif

    Flip flip;
    Board board2;
    int v = -SCORE_INF;
    int pol = 1;
    do {
        ++search->n_nodes;
#if USE_SEARCH_STATISTICS
        ++search->n_nodes_discs[61];
#endif
        if ((bit_around[p0] & board.opponent) && calc_flip(&flip, &board, p0)) {
            board.move_copy(&flip, &board2);
            v = last2_nws(search, alpha, p1, p2, board2);
            if (alpha < v) {
                return v * pol;
            }
        }

        int g;
        if ((bit_around[p1] & board.opponent) && calc_flip(&flip, &board, p1)) {
            board.move_copy(&flip, &board2);
            g = last2_nws(search, alpha, p2, p0, board2);
            if (alpha < g) {
                return g * pol;
            }
            if (v < g) {
                v = g;
            }
        }

        if ((bit_around[p2] & board.opponent) && calc_flip(&flip, &board, p2)) {
            board.move_copy(&flip, &board2);
            g = last2_nws(search, alpha, p1, p0, board2);
            if (v < g) {
                v = g;
            }
            return v * pol;
        }

        if (v > -SCORE_INF) {
            return v * pol;
        }

        board.pass();
        alpha = -alpha - 1;
    } while ((pol = -pol) < 0);

    return end_evaluate_odd(&board, 3); 
}

int last4_nws(Search *search, int alpha) {
     uint64_t empties = ~(search->board.player | search->board.opponent | search->board.invalid_mask);
    uint_fast8_t p0, p1, p2, p3;

#if USE_LAST4_SC
    int stab_res = stability_cut_last4_nws(search, alpha);
    if (stab_res != SCORE_UNDEFINED) {
        return stab_res;
    }
#endif
#if USE_END_PO
     uint64_t e1 = empty1_bb(search->board.player, search->board.opponent);
e1 &= ~search->board.invalid_mask;
    if (!e1) {
        e1 = empties;
    }
    empties &= ~e1;

    p0 = first_bit(&e1);
    if (!(e1 &= e1 - 1)) {
        e1 = empties;
    }
    p1 = first_bit(&e1);
    if (!(e1 &= e1 - 1)) {
        e1 = empties;
    }
    p2 = first_bit(&e1);
    if ((e1 &= e1 - 1)) {
        p3 = first_bit(&e1);
    } else {
        p3 = first_bit(&empties);
    }
#else
    p0 = first_bit(&empties);
    p1 = next_bit(&empties);
    p2 = next_bit(&empties);
    p3 = next_bit(&empties);
#endif

    Flip flip;
    Board board3, board4;
    search->board.copy(&board4);
    int v = SCORE_INF; 
    int pol = 1;
    do {
        ++search->n_nodes;
#if USE_SEARCH_STATISTICS
        ++search->n_nodes_discs[60];
#endif
        if ((bit_around[p0] & board4.opponent) && calc_flip(&flip, &board4, p0)) {
            board4.move_copy(&flip, &board3);
            v = last3_nws(search, alpha, p1, p2, p3, board3);
            if (alpha >= v) {
                return v * pol;
            }
        }

        int g;
        if ((bit_around[p1] & board4.opponent) && calc_flip(&flip, &board4, p1)) {
            board4.move_copy(&flip, &board3);
            g = last3_nws(search, alpha, p0, p2, p3, board3);
            if (alpha >= g) {
                return g * pol;
            }
            if (v > g) {
                v = g;
            }
        }

        if ((bit_around[p2] & board4.opponent) && calc_flip(&flip, &board4, p2)) {
            board4.move_copy(&flip, &board3);
            g = last3_nws(search, alpha, p0, p1, p3, board3);
            if (alpha >= g) {
                return g * pol;
            }
            if (v > g) {
                v = g;
            }
        }

        if ((bit_around[p3] & board4.opponent) && calc_flip(&flip, &board4, p3)) {
            board4.move_copy(&flip, &board3);
            g = last3_nws(search, alpha, p0, p1, p2, board3);
            if (v > g) {
                v = g;
            }
            return v * pol;
        }

        if (v < SCORE_INF) {
            return v * pol;
        }

        board4.pass();
        alpha = -alpha - 1;
    } while ((pol = -pol) < 0);

    return -end_evaluate(&search->board, 4); 
}

// ===== FILE: Egaroucid/src/engine/endsearch_nws_last_simd.hpp =====


#pragma once
#ifdef _MSC_VER
#include <intrin.h>
#else
#include <x86intrin.h>
#endif
#include "setting.hpp"
#include "search.hpp"
#include "endsearch_common.hpp"

#if USE_AVX512

static inline int vectorcall last1_nws(Search *search, __m128i PO, int alhpphpppha, int place) {
    __m128i P2 = _mm_unpackhi_epi64(PO, PO);
    __m256i P4 = _mm256_broadcastq_epi64(P2);
    uint64_t P = _mm_cvtsi128_si64(P2);
    int score = 2 * pop_count_ull(P) - HW2 + 2;    

    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[63];
#endif
    __m256i lM = lrmask[place].v4[0];
    __m256i rM = lrmask[place].v4[1];
    __mmask16 lp = _mm256_test_epi64_mask(P4, lM);    
    __mmask16 rp = _mm256_test_epi64_mask(P4, rM);
    __m256i F4, outflank, eraser, lmO, rmO;
    __m128i F2;
    int n_flip;

    if (score > alpha) {    
        lmO = _mm256_maskz_andnot_epi64(lp, P4, lM);    
        rmO = _mm256_maskz_andnot_epi64(rp, P4, rM);    

        if (_mm256_testz_si256(_mm256_or_si256(lmO, rmO), _mm256_set1_epi64x(bit_around[place]))) {
            ++search->n_nodes;
#if USE_SEARCH_STATISTICS
            ++search->n_nodes_discs[63];
#endif
                
                
            F4 = _mm256_maskz_add_epi64(_mm256_test_epi64_mask(lmO, lmO), lmO, _mm256_set1_epi64x(-1));
            F4 = _mm256_and_si256(_mm256_andnot_si256(lmO, F4), lM);

                
            eraser = _mm256_srlv_epi64(_mm256_set1_epi64x(-1),
                _mm256_maskz_lzcnt_epi64(_mm256_test_epi64_mask(rmO, rmO), rmO));
            F4 = _mm256_or_si256(F4, _mm256_andnot_si256(eraser, rM));

            F2 = _mm_or_si128(_mm256_castsi256_si128(F4), _mm256_extracti128_si256(F4, 1));
            n_flip = -pop_count_ull(_mm_cvtsi128_si64(_mm_or_si128(F2, _mm_unpackhi_epi64(F2, F2))));
                
            score += (n_flip - (int)((n_flip | (score - 1)) < 0)) * 2;
        } else  score += 2;    

    } else {    
            
        outflank = _mm256_and_si256(P4, lM);
        F4 = _mm256_maskz_add_epi64(lp, outflank, _mm256_set1_epi64x(-1));
        F4 = _mm256_and_si256(_mm256_andnot_si256(outflank, F4), lM);

            
        outflank = _mm256_and_si256(P4, rM);
        eraser = _mm256_srlv_epi64(_mm256_set1_epi64x(-1), _mm256_maskz_lzcnt_epi64(rp, outflank));
        F4 = _mm256_or_si256(F4, _mm256_andnot_si256(eraser, rM));

        F2 = _mm_or_si128(_mm256_castsi256_si128(F4), _mm256_extracti128_si256(F4, 1));
        n_flip = pop_count_ull(_mm_cvtsi128_si64(_mm_or_si128(F2, _mm_unpackhi_epi64(F2, F2))));
        score += n_flip * 2;
            
    }
    return score;
}

#else 

static inline int vectorcall last1_nws(Search *search, __m128i PO, int alpha, int place) {
#if LAST_FLIP_PASS_OPT && false
    return last1(search, PO, alpha, place);
#else
    uint_fast16_t n_flip;
    uint32_t t;
    uint64_t P = _mm_extract_epi64(PO, 1);
    __m256i PP = _mm256_permute4x64_epi64(_mm256_castsi128_si256(PO), 0x55);
    int score = 2 * pop_count_ull(P) - HW2 + 2;    

    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[63];
#endif
    if (score > alpha) {    
        __m256i lM = lrmask[place].v4[0];
        __m256i rM = lrmask[place].v4[1];
        __m256i lmO = _mm256_andnot_si256(PP, lM);
        __m256i F = _mm256_andnot_si256(_mm256_cmpeq_epi64(lmO, lM), lmO); 
        __m256i rmO = _mm256_andnot_si256(PP, rM);
        F = _mm256_or_si256(F, _mm256_andnot_si256(_mm256_cmpeq_epi64(rmO, rM), rmO));
        if (_mm256_testz_si256(F, _mm256_broadcastq_epi64(*(__m128i *) &bit_around[place]))) {    
            ++search->n_nodes;
#if USE_SEARCH_STATISTICS
            ++search->n_nodes_discs[63];
#endif
                
            t = ~_mm256_movemask_epi8(_mm256_cmpeq_epi8(lmO, rmO));    
            const int y = place >> 3;
            n_flip  = N_LAST_FLIP[(~P >> (y * 8)) & 0xFF][place & 7];    
            n_flip += N_LAST_FLIP[(t >> 8) & 0xFF][y];    
            n_flip += N_LAST_FLIP[(t >> 16) & 0xFF][y];    
            n_flip += N_LAST_FLIP[t >> 24][y];    
            score -= (n_flip + (int)((n_flip > 0) | (score <= 0))) * 2;
        } else { 
            score += 2;    
        }
    } else {    
            
        const int y = place >> 3;
        t = _mm256_movemask_epi8(_mm256_sub_epi8(_mm256_setzero_si256(), _mm256_and_si256(PP, mask_dvhd[place].v4)));
        n_flip  = N_LAST_FLIP[(P >> (y * 8)) & 0xFF][place & 7];    
        n_flip += N_LAST_FLIP[t & 0xFF][y];    
        n_flip += N_LAST_FLIP[(t >> 16) & 0xFF][y];    
        n_flip += N_LAST_FLIP[t >> 24][y];    
        score += n_flip * 2;
            
    }
    return score;
#endif
}

#endif

static int vectorcall last2_nws(Search *search, __m128i OP, int alpha, uint32_t p0, uint32_t p1) {
    __m128i flipped;
    uint64_t opponent = _mm_extract_epi64(OP, 1);

    ++search->n_nodes;
    #if USE_SEARCH_STATISTICS
        ++search->n_nodes_discs[62];
    #endif
    int v;
    if (bit_around[p0] & opponent) {
        if ((((board.invalid_mask >> p0) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p0))) {
            v = last1_nws(search, _mm_xor_si128(OP, flipped), alpha, p1);
    
if ((v > alpha) && (bit_around[p1] & opponent) &&
    (((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p1))) { 
                if (v > g)
                    v = g;
            }
            return v;
        }
    }

    if (bit_around[p1] & opponent) {
        if ((((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p1))) {
            v = last1_nws(search, _mm_xor_si128(OP, flipped), alpha, p0);
            return v;
        }
    }
 
    
    ++search->n_nodes;
    #if USE_SEARCH_STATISTICS
        ++search->n_nodes_discs[62];
    #endif
    alpha = -(alpha + 1);    
    __m128i PO = _mm_shuffle_epi32(OP, SWAP64);
    if ((((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p0))) {
        v = last1_nws(search, _mm_xor_si128(PO, flipped), alpha, p1);

        if ((v > alpha) &&
    (((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(PO, p1))) { 
            int g = last1_nws(search, _mm_xor_si128(PO, flipped), alpha, p0);
            if (v > g)
                v = g;
        }
    }

     else if ((((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
           !TESTZ_FLIP(flipped = Flip::calc_flip(PO, p1))) { 
        v = last1_nws(search, _mm_xor_si128(PO, flipped), alpha, p0);

    else    
        v = end_evaluate(_mm_extract_epi64(PO, 1), 2);

    v = -v;
    return v;
}

static int vectorcall last3_nws(Search *search, __m128i OP, int alpha, uint32_t p0, uint32_t p1, uint32_t p2) {
    __m128i flipped;
    uint64_t opponent;

     uint64_t empties = ~(search->board.player | search->board.opponent | search->board.invalid_mask);
    if (is_1empty(p2, empties))
        std::swap(p2, p0);
    else if (is_1empty(p1, empties))
        std::swap(p1, p0);

    int v = -SCORE_INF;
    int pol = 1;
    do {
        ++search->n_nodes;
        #if USE_SEARCH_STATISTICS
            ++search->n_nodes_discs[61];
        #endif
        opponent = _mm_extract_epi64(OP, 1);
        int x = p0;
        if (bit_around[x] & opponent) {
            if ((((board.invalid_mask >> x) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, x))) {
                v = last2_nws(search, board_flip_next(OP, x, flipped), alpha, p1, p2);
                if (alpha < v)
                    return v * pol;
            }
        }

        int g;
        x = p1;
        if (bit_around[x] & opponent) {
            if ((((board.invalid_mask >> x) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, x))) {
                g = last2_nws(search, board_flip_next(OP, x, flipped), alpha, p2, p0);    
                if (alpha < g)
                    return g * pol;
                if (v < g)
                    v = g;
            }
        }

        x = p2;
        if (bit_around[x] & opponent) {
            if ((((board.invalid_mask >> x) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, x))) {
                g = last2_nws(search, board_flip_next(OP, x, flipped), alpha, p1, p0);
                if (v < g)
                    v = g;
                return v * pol;
            }
        }

        if (v > -SCORE_INF)
            return v * pol;

        OP = _mm_shuffle_epi32(OP, SWAP64);    
        alpha = -alpha - 1;
    } while ((pol = -pol) < 0);

    return end_evaluate(opponent, 3);    
}

int last4_nws(Search *search, int alpha) {
    __m128i flipped;
    uint64_t opponent;
    __m128i OP = _mm_loadu_si128((__m128i*) & search->board);
    u uint64_t empties = ~(search->board.player | search->board.opponent | search->board.invalid_mask);
    uint_fast8_t p0, p1, p2, p3;

    #if USE_LAST4_SC
        int stab_res = stability_cut_last4_nws(search, alpha);
        if (stab_res != SCORE_UNDEFINED) {
            return stab_res;
        }
    #endif
    #if USE_END_PO
        uint64_t e1 = empty1_bb(search->board.player, search->board.opponent);
e1 &= ~search->board.invalid_mask;
        if (!e1)
            e1 = empties;
        empties &= ~e1;
    
        p0 = first_bit(&e1);
        if (!(e1 &= e1 - 1))
            e1 = empties;
        p1 = first_bit(&e1);
        if (!(e1 &= e1 - 1))
            e1 = empties;
        p2 = first_bit(&e1);
        if ((e1 &= e1 - 1))
            p3 = first_bit(&e1);
        else
            p3 = first_bit(&empties);
    #else
        p0 = first_bit(&empties);
        p1 = next_bit(&empties);
        p2 = next_bit(&empties);
        p3 = next_bit(&empties);
    #endif

    int v = SCORE_INF;    
    int pol = 1;
    do {
        ++search->n_nodes;
        #if USE_SEARCH_STATISTICS
            ++search->n_nodes_discs[60];
        #endif
        opponent = _mm_extract_epi64(OP, 1);
        if (bit_around[p0] & opponent) {
            if ((((board.invalid_mask >> p0) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p0))) {
                v = last3_nws(search, board_flip_next(OP, p0, flipped), alpha, p1, p2, p3);
                if (alpha >= v)
                    return v * pol;
            }
        }

        int g;
        if (bit_around[p1] & opponent) {
            if ((((board.invalid_mask >> p1) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p1))) {
                g = last3_nws(search, board_flip_next(OP, p1, flipped), alpha, p0, p2, p3);
                if (alpha >= g)
                    return g * pol;
                if (v > g)
                    v = g;
            }
        }
 
        if (bit_around[p2] & opponent) {
            if ((((board.invalid_mask >> p2) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p2))) {
                g = last3_nws(search, board_flip_next(OP, p2, flipped), alpha, p0, p1, p3);
                if (alpha >= g)
                    return g * pol;
                if (v > g)
                    v = g;
            }
        }
 
        if (bit_around[p3] & opponent) {
            if ((((board.invalid_mask >> p3) & 1ULL) == 0ULL) &&
    !TESTZ_FLIP(flipped = Flip::calc_flip(OP, p3))) {
                g = last3_nws(search, board_flip_next(OP, p3, flipped), alpha, p0, p1, p2);
                if (v > g)
                    v = g;
                return v * pol;
            }
        }

        if (v < SCORE_INF)
            return v * pol;

        OP = _mm_shuffle_epi32(OP, SWAP64);    
        alpha = -alpha - 1;
    } while ((pol = -pol) < 0);

    return end_evaluate(_mm_extract_epi64(OP, 1), 4);    
}

// ===== FILE: Egaroucid/src/engine/engine_all.hpp =====



#pragma once
#include "ai.hpp"
#include "book_accuracy.hpp"
#include "book_enlarge.hpp"
#include "human_like_ai.hpp"
#include "local_strategy.hpp"
#include "minimax.hpp"
#include "perft.hpp"
#include "principal_variation.hpp"
#include "problem_generator.hpp"
#include "random_board_generator.hpp"
#include "umigame.hpp"
#include "version.hpp"
#if TEST_ENDGAME_ACCURACY
#include "test.hpp"
#endif

// ===== FILE: Egaroucid/src/engine/evaluate_common_7_4.hpp =====



#pragma once
#include "board.hpp"



#define N_PATTERNhpphppS 16
#define MAX_PATTERN_CELLS 10
#define MAX_CELL_PATTERNS 13
#define MAX_EVALUATE_IDX 59049
#define N_SYMMETRY_PATTERNS 64
#if USE_SIMD_EVALUATION
    #define N_SIMD_EVAL_FEATURES 4 
#endif


#define MAX_SURROUND 64
#define MAX_STONE_NUM 65


#define N_PHASES 60
#define PHASE_N_DISCS 1


#define MAX_EVALUATE_IDX_MO 59049
#define N_PATTERNS_MO_END 4
#define N_SYMMETRY_PATTERNS_MO_END 16

#if USE_LIGHT_EVALUATION

#define N_SYMMETRY_PATTERNS_LIGHT 46
#endif

#define STEP 32
#define STEP_2 16


#define PNO 0
#define P30 1
#define P31 3
#define P32 9
#define P33 27
#define P34 81
#define P35 243
#define P36 729
#define P37 2187
#define P38 6561
#define P39 19683
#define P310 59049


#define COORD_A1 63
#define COORD_B1 62
#define COORD_C1 61
#define COORD_D1 60
#define COORD_E1 59
#define COORD_F1 58
#define COORD_G1 57
#define COORD_H1 56

#define COORD_A2 55
#define COORD_B2 54
#define COORD_C2 53
#define COORD_D2 52
#define COORD_E2 51
#define COORD_F2 50
#define COORD_G2 49
#define COORD_H2 48

#define COORD_A3 47
#define COORD_B3 46
#define COORD_C3 45
#define COORD_D3 44
#define COORD_E3 43
#define COORD_F3 42
#define COORD_G3 41
#define COORD_H3 40

#define COORD_A4 39
#define COORD_B4 38
#define COORD_C4 37
#define COORD_D4 36
#define COORD_E4 35
#define COORD_F4 34
#define COORD_G4 33
#define COORD_H4 32

#define COORD_A5 31
#define COORD_B5 30
#define COORD_C5 29
#define COORD_D5 28
#define COORD_E5 27
#define COORD_F5 26
#define COORD_G5 25
#define COORD_H5 24

#define COORD_A6 23
#define COORD_B6 22
#define COORD_C6 21
#define COORD_D6 20
#define COORD_E6 19
#define COORD_F6 18
#define COORD_G6 17
#define COORD_H6 16

#define COORD_A7 15
#define COORD_B7 14
#define COORD_C7 13
#define COORD_D7 12
#define COORD_E7 11
#define COORD_F7 10
#define COORD_G7 9
#define COORD_H7 8

#define COORD_A8 7
#define COORD_B8 6
#define COORD_C8 5
#define COORD_D8 4
#define COORD_E8 3
#define COORD_F8 2
#define COORD_G8 1
#define COORD_H8 0

#define COORD_NO 64

#define N_ZEROS_PLUS (1 << 12) 

struct Feature_to_coord {
    uint_fast8_t n_cells;
    uint_fast8_t cells[MAX_PATTERN_CELLS];
};

struct Coord_feature {
    uint_fast8_t feature;
    uint_fast16_t x;
};

struct Coord_to_feature {
    uint_fast8_t n_features;
    Coord_feature features[MAX_CELL_PATTERNS];
};

#if USE_SIMD
    union Eval_features {
        __m256i f256[N_SIMD_EVAL_FEATURES];
        __m128i f128[N_SIMD_EVAL_FEATURES * 2];
    };

    struct Eval_search {
        Eval_features features[HW2 - 4];
        uint_fast8_t feature_idx;
    };
#else
    struct Eval_search {
        uint_fast16_t features[HW2 - 4][N_SYMMETRY_PATTERNS];
        bool reversed[HW2 - 4];
        uint_fast8_t feature_idx;
    };
#endif


constexpr uint_fast16_t pow3[11] = {1, P31, P32, P33, P34, P35, P36, P37, P38, P39, P310};

inline int end_evaluate(Board *b) {
    return b->score_player();
}

inline int end_evaluate(Board *b, int e) {
    int score = b->count_player() * 2 + e;
    score += (((score >> 6) & 1) + (((score + HW2_M1) >> 7) & 1) - 1) * e;
    return score - HW2;
}

inline int end_evaluate_odd(Board *b, int e) {
    int score = b->count_player() * 2 + e;
    score += (((score >> 5) & 2) - 1) * e;
    return score - HW2;
}

inline std::vector<int16_t> load_unzip_egev2(const char* file, bool show_log, bool *failed) {
    *failed = false;
    std::vector<int16_t> res;
    FILE* fp;
    if (!file_open(&fp, file, "rb")) {
        std::cerr << "[ERROR] [FATAL] can't open eval " << file << std::endl;
        *failed = true;
        return res;
    }
    int n_unzipped_params = -1;
    if (fread(&n_unzipped_params, 4, 1, fp) < 1) {
        std::cerr << "[ERROR] [FATAL] evaluation file broken" << std::endl;
        fclose(fp);
        *failed = true;
        return res;
    }
    if (show_log) {
        std::cerr << n_unzipped_params << " elems found in " << file << std::endl;
    }
    short *unzipped_params = (short*)malloc(sizeof(short) * n_unzipped_params);
    if (fread(unzipped_params, 2, n_unzipped_params, fp) < n_unzipped_params) {
        std::cerr << "[ERROR] [FATAL] evaluation file broken" << std::endl;
        fclose(fp);
        free(unzipped_params);
        *failed = true;
        return res;
    }
    for (int i = 0; i < n_unzipped_params; ++i) {
        if (unzipped_params[i] >= N_ZEROS_PLUS) {
            for (int j = 0; j < unzipped_params[i] - N_ZEROS_PLUS; ++j) {
                res.emplace_back(0);
            }
        } else{
            res.emplace_back(unzipped_params[i]);
        }
    }
    if (show_log) {
        std::cerr << res.size() << " elems found in unzipped " << file << std::endl;
    }
    free(unzipped_params);
    return res;
}

// ===== FILE: Egaroucid/src/engine/evaluate_common.hpp =====



#pragma once
#include "board.hpp"



constexpr int N_PATTERNS = 16;          
constexpr int MAX_CELL_PATTERNS = 15;   
constexpr int MAX_PATTERN_CELLS = 10;   
constexpr int MAX_EVALUATE_IDX = 59049; 
constexpr int N_PATTERN_FEATURES = 64;  
#if USE_SIMD_EVALUATION
constexpr int N_EVAL_VECTORS = 4; 
#endif


constexpr int MAX_STONE_NUM = 65; 


constexpr int N_PHASES = 60;
constexpr int PHASE_N_DISCS = 1; 


constexpr int MAX_EVALUATE_IDX_MO = 59049; 
constexpr int N_PATTERNS_MO_END = 4; 
constexpr int N_PATTERN_FEATURES_MO_END = 16; 


constexpr int STEP = 32; 
constexpr int STEP_2 = 16; 





constexpr int PNO = 0;
constexpr int P30 = 1;
constexpr int P31 = 3;
constexpr int P32 = 9;
constexpr int P33 = 27;
constexpr int P34 = 81;
constexpr int P35 = 243;
constexpr int P36 = 729;
constexpr int P37 = 2187;
constexpr int P38 = 6561;
constexpr int P39 = 19683;
constexpr int P310 = 59049;


constexpr int COORD_A1 = 63;
constexpr int COORD_B1 = 62;
constexpr int COORD_C1 = 61;
constexpr int COORD_D1 = 60;
constexpr int COORD_E1 = 59;
constexpr int COORD_F1 = 58;
constexpr int COORD_G1 = 57;
constexpr int COORD_H1 = 56;

constexpr int COORD_A2 = 55;
constexpr int COORD_B2 = 54;
constexpr int COORD_C2 = 53;
constexpr int COORD_D2 = 52;
constexpr int COORD_E2 = 51;
constexpr int COORD_F2 = 50;
constexpr int COORD_G2 = 49;
constexpr int COORD_H2 = 48;

constexpr int COORD_A3 = 47;
constexpr int COORD_B3 = 46;
constexpr int COORD_C3 = 45;
constexpr int COORD_D3 = 44;
constexpr int COORD_E3 = 43;
constexpr int COORD_F3 = 42;
constexpr int COORD_G3 = 41;
constexpr int COORD_H3 = 40;

constexpr int COORD_A4 = 39;
constexpr int COORD_B4 = 38;
constexpr int COORD_C4 = 37;
constexpr int COORD_D4 = 36;
constexpr int COORD_E4 = 35;
constexpr int COORD_F4 = 34;
constexpr int COORD_G4 = 33;
constexpr int COORD_H4 = 32;

constexpr int COORD_A5 = 31;
constexpr int COORD_B5 = 30;
constexpr int COORD_C5 = 29;
constexpr int COORD_D5 = 28;
constexpr int COORD_E5 = 27;
constexpr int COORD_F5 = 26;
constexpr int COORD_G5 = 25;
constexpr int COORD_H5 = 24;

constexpr int COORD_A6 = 23;
constexpr int COORD_B6 = 22;
constexpr int COORD_C6 = 21;
constexpr int COORD_D6 = 20;
constexpr int COORD_E6 = 19;
constexpr int COORD_F6 = 18;
constexpr int COORD_G6 = 17;
constexpr int COORD_H6 = 16;

constexpr int COORD_A7 = 15;
constexpr int COORD_B7 = 14;
constexpr int COORD_C7 = 13;
constexpr int COORD_D7 = 12;
constexpr int COORD_E7 = 11;
constexpr int COORD_F7 = 10;
constexpr int COORD_G7 = 9;
constexpr int COORD_H7 = 8;

constexpr int COORD_A8 = 7;
constexpr int COORD_B8 = 6;
constexpr int COORD_C8 = 5;
constexpr int COORD_D8 = 4;
constexpr int COORD_E8 = 3;
constexpr int COORD_F8 = 2;
constexpr int COORD_G8 = 1;
constexpr int COORD_H8 = 0;

constexpr int COORD_NO = 64;

constexpr int N_ZEROS_PLUS = 1 << 12; 


struct Feature_to_coord {
    uint_fast8_t n_cells;
    uint_fast8_t cells[MAX_PATTERN_CELLS];
};


struct Coord_feature {
    uint_fast8_t feature;
    uint_fast16_t x;
};


struct Coord_to_feature {
    uint_fast8_t n_features;
    Coord_feature features[MAX_CELL_PATTERNS];
};

#if USE_SIMD
union Eval_features {
    __m256i f256[N_EVAL_VECTORS];
    __m128i f128[N_EVAL_VECTORS * 2];
};

struct Eval_search {
    Eval_features features[HW2 - 4];
    uint_fast8_t feature_idx;
};
#else
struct Eval_search {
    uint_fast16_t features[HW2 - 4][N_PATTERN_FEATURES];
    bool reversed[HW2 - 4];
    uint_fast8_t feature_idx;
};
#endif


constexpr uint_fast16_t pow3[11] = {1, P31, P32, P33, P34, P35, P36, P37, P38, P39, P310};


inline int end_evaluate(Board *b) {
    return b->score_player();
}


inline int end_evaluate(Board *b, int e) {
    int score = b->count_player() * 2 + e;
    score += (((score >> 6) & 1) + (((score + HW2_M1) >> 7) & 1) - 1) * e;
    return score - HW2;
}


inline int end_evaluate_odd(Board *b, int e) {
    int score = b->count_player() * 2 + e;
    score += (((score >> 5) & 2) - 1) * e;
    return score - HW2;
}

inline std::vector<int16_t> load_unzip_egev2(const char* file, bool show_log, bool *failed) {
    *failed = false;
    std::vector<int16_t> res;
    FILE* fp;
    if (!file_open(&fp, file, "rb")) {
        std::cerr << "[ERROR] [FATAL] can't open eval " << file << std::endl;
        *failed = true;
        return res;
    }
    int n_unzipped_params = -1;
    if (fread(&n_unzipped_params, 4, 1, fp) < 1) {
        std::cerr << "[ERROR] [FATAL] evaluation file broken" << std::endl;
        fclose(fp);
        *failed = true;
        return res;
    }
    if (show_log) {
        std::cerr << n_unzipped_params << " elems found in " << file << std::endl;
    }
    short *unzipped_params = (short*)malloc(sizeof(short) * n_unzipped_params);
    if (fread(unzipped_params, 2, n_unzipped_params, fp) < n_unzipped_params) {
        std::cerr << "[ERROR] [FATAL] evaluation file broken" << std::endl;
        fclose(fp);
        free(unzipped_params);
        *failed = true;
        return res;
    }
    for (int i = 0; i < n_unzipped_params; ++i) {
        if (unzipped_params[i] >= N_ZEROS_PLUS) {
            for (int j = 0; j < unzipped_params[i] - N_ZEROS_PLUS; ++j) {
                res.emplace_back(0);
            }
        } else{
            res.emplace_back(unzipped_params[i]);
        }
    }
    if (show_log) {
        std::cerr << res.size() << " elems found in unzipped " << file << std::endl;
    }
    free(unzipped_params);
    return res;
}

// ===== FILE: Egaroucid/src/engine/evaluate_generic_7_4.hpp =====



#pragma once
#include <iostream>
#include <fstream>
#include <cstring>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "search.hpp"
#include "util.hpp"
#include "evaluate_common.hpp"

#define EVAL_IDX_START_MOVE_ORDERING_END 32
#define EVAL_IDX_END_MOVE_ORDERING_END 48
#define EVAL_FEATURE_START_MOVE_ORDERING_END 8
#define MAX_CELL_PATTERNS_MOVE_ORDERING_END 6

constexpr Feature_to_coord feature_to_coord[N_SYMMETRY_PATTERNS] = {
    
    {8, {COORD_A2, COORD_B2, COORD_C2, COORD_D2, COORD_E2, COORD_F2, COORD_G2, COORD_H2, COORD_NO, COORD_NO}},
    {8, {COORD_B1, COORD_B2, COORD_B3, COORD_B4, COORD_B5, COORD_B6, COORD_B7, COORD_B8, COORD_NO, COORD_NO}},
    {8, {COORD_A7, COORD_B7, COORD_C7, COORD_D7, COORD_E7, COORD_F7, COORD_G7, COORD_H7, COORD_NO, COORD_NO}},
    {8, {COORD_G1, COORD_G2, COORD_G3, COORD_G4, COORD_G5, COORD_G6, COORD_G7, COORD_G8, COORD_NO, COORD_NO}},

    
    {8, {COORD_A3, COORD_B3, COORD_C3, COORD_D3, COORD_E3, COORD_F3, COORD_G3, COORD_H3, COORD_NO, COORD_NO}},
    {8, {COORD_C1, COORD_C2, COORD_C3, COORD_C4, COORD_C5, COORD_C6, COORD_C7, COORD_C8, COORD_NO, COORD_NO}},
    {8, {COORD_A6, COORD_B6, COORD_C6, COORD_D6, COORD_E6, COORD_F6, COORD_G6, COORD_H6, COORD_NO, COORD_NO}},
    {8, {COORD_F1, COORD_F2, COORD_F3, COORD_F4, COORD_F5, COORD_F6, COORD_F7, COORD_F8, COORD_NO, COORD_NO}},

    
    {8, {COORD_A4, COORD_B4, COORD_C4, COORD_D4, COORD_E4, COORD_F4, COORD_G4, COORD_H4, COORD_NO, COORD_NO}},
    {8, {COORD_D1, COORD_D2, COORD_D3, COORD_D4, COORD_D5, COORD_D6, COORD_D7, COORD_D8, COORD_NO, COORD_NO}},
    {8, {COORD_A5, COORD_B5, COORD_C5, COORD_D5, COORD_E5, COORD_F5, COORD_G5, COORD_H5, COORD_NO, COORD_NO}},
    {8, {COORD_E1, COORD_E2, COORD_E3, COORD_E4, COORD_E5, COORD_E6, COORD_E7, COORD_E8, COORD_NO, COORD_NO}},

    
    {9, {COORD_A1, COORD_B1, COORD_C1, COORD_A2, COORD_B2, COORD_C2, COORD_A3, COORD_B3, COORD_C3, COORD_NO}},
    {9, {COORD_H1, COORD_G1, COORD_F1, COORD_H2, COORD_G2, COORD_F2, COORD_H3, COORD_G3, COORD_F3, COORD_NO}},
    {9, {COORD_A8, COORD_B8, COORD_C8, COORD_A7, COORD_B7, COORD_C7, COORD_A6, COORD_B6, COORD_C6, COORD_NO}},
    {9, {COORD_H8, COORD_G8, COORD_F8, COORD_H7, COORD_G7, COORD_F7, COORD_H6, COORD_G6, COORD_F6, COORD_NO}},

    
    {5, {COORD_D1, COORD_E2, COORD_F3, COORD_G4, COORD_H5, COORD_NO, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},
    {5, {COORD_E1, COORD_D2, COORD_C3, COORD_B4, COORD_A5, COORD_NO, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},
    {5, {COORD_A4, COORD_B5, COORD_C6, COORD_D7, COORD_E8, COORD_NO, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},
    {5, {COORD_H4, COORD_G5, COORD_F6, COORD_E7, COORD_D8, COORD_NO, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},

    
    {6, {COORD_C1, COORD_D2, COORD_E3, COORD_F4, COORD_G5, COORD_H6, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},
    {6, {COORD_F1, COORD_E2, COORD_D3, COORD_C4, COORD_B5, COORD_A6, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},
    {6, {COORD_A3, COORD_B4, COORD_C5, COORD_D6, COORD_E7, COORD_F8, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},
    {6, {COORD_H3, COORD_G4, COORD_F5, COORD_E6, COORD_D7, COORD_C8, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},

    
    {7, {COORD_B1, COORD_C2, COORD_D3, COORD_E4, COORD_F5, COORD_G6, COORD_H7, COORD_NO, COORD_NO, COORD_NO}},
    {7, {COORD_G1, COORD_F2, COORD_E3, COORD_D4, COORD_C5, COORD_B6, COORD_A7, COORD_NO, COORD_NO, COORD_NO}},
    {7, {COORD_A2, COORD_B3, COORD_C4, COORD_D5, COORD_E6, COORD_F7, COORD_G8, COORD_NO, COORD_NO, COORD_NO}},
    {7, {COORD_H2, COORD_G3, COORD_F4, COORD_E5, COORD_D6, COORD_C7, COORD_B8, COORD_NO, COORD_NO, COORD_NO}},

    
    {10, {COORD_A1, COORD_B2, COORD_C3, COORD_D4, COORD_E5, COORD_F6, COORD_G7, COORD_H8, COORD_A2, COORD_B1}},
    {10, {COORD_H8, COORD_G7, COORD_F6, COORD_E5, COORD_D4, COORD_C3, COORD_B2, COORD_A1, COORD_H7, COORD_G8}},
    {10, {COORD_H1, COORD_G2, COORD_F3, COORD_E4, COORD_D5, COORD_C6, COORD_B7, COORD_A8, COORD_H2, COORD_G1}},
    {10, {COORD_A8, COORD_B7, COORD_C6, COORD_D5, COORD_E4, COORD_F3, COORD_G2, COORD_H1, COORD_A7, COORD_B8}},
 
    
    {10, {COORD_B2, COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_G1, COORD_H1, COORD_G2}},
    {10, {COORD_B2, COORD_A1, COORD_A2, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A7, COORD_A8, COORD_B7}},
    {10, {COORD_B7, COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_G8, COORD_H8, COORD_G7}},
    {10, {COORD_G2, COORD_H1, COORD_H2, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H7, COORD_H8, COORD_G7}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_A2, COORD_B2, COORD_C2, COORD_A3, COORD_B3, COORD_A4}},
    {10, {COORD_H1, COORD_G1, COORD_F1, COORD_E1, COORD_H2, COORD_G2, COORD_F2, COORD_H3, COORD_G3, COORD_H4}},
    {10, {COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_A7, COORD_B7, COORD_C7, COORD_A6, COORD_B6, COORD_A5}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_E8, COORD_H7, COORD_G7, COORD_F7, COORD_H6, COORD_G6, COORD_H5}},

    
    {10, {COORD_A1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_H1, COORD_C2, COORD_D2, COORD_E2, COORD_F2}},
    {10, {COORD_A1, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A8, COORD_B3, COORD_B4, COORD_B5, COORD_B6}},
    {10, {COORD_A8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_H8, COORD_C7, COORD_D7, COORD_E7, COORD_F7}},
    {10, {COORD_H1, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H8, COORD_G3, COORD_G4, COORD_G5, COORD_G6}},

    
    {10, {COORD_A1, COORD_B2, COORD_C3, COORD_D4, COORD_B1, COORD_C2, COORD_D3, COORD_A2, COORD_B3, COORD_C4}},
    {10, {COORD_H1, COORD_G2, COORD_F3, COORD_E4, COORD_G1, COORD_F2, COORD_E3, COORD_H2, COORD_G3, COORD_F4}},
    {10, {COORD_A8, COORD_B7, COORD_C6, COORD_D5, COORD_B8, COORD_C7, COORD_D6, COORD_A7, COORD_B6, COORD_C5}},
    {10, {COORD_H8, COORD_G7, COORD_F6, COORD_E5, COORD_G8, COORD_F7, COORD_E6, COORD_H7, COORD_G6, COORD_F5}},

    
    {10, {COORD_C2, COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_G1, COORD_H1, COORD_F2}},
    {10, {COORD_B3, COORD_A1, COORD_A2, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A7, COORD_A8, COORD_B6}},
    {10, {COORD_C7, COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_G8, COORD_H8, COORD_F7}},
    {10, {COORD_G3, COORD_H1, COORD_H2, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H7, COORD_H8, COORD_G6}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_A2, COORD_B2, COORD_A3, COORD_A4, COORD_A5}},
    {10, {COORD_H1, COORD_G1, COORD_F1, COORD_E1, COORD_D1, COORD_H2, COORD_G2, COORD_H3, COORD_H4, COORD_H5}},
    {10, {COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_A7, COORD_B7, COORD_A6, COORD_A5, COORD_A4}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_E8, COORD_D8, COORD_H7, COORD_G7, COORD_H6, COORD_H5, COORD_H4}},

    
    {10, {COORD_A1, COORD_B1, COORD_A2, COORD_B2, COORD_C2, COORD_D2, COORD_B3, COORD_C3, COORD_B4, COORD_D4}},
    {10, {COORD_H1, COORD_G1, COORD_H2, COORD_G2, COORD_F2, COORD_E2, COORD_G3, COORD_F3, COORD_G4, COORD_E4}},
    {10, {COORD_A8, COORD_B8, COORD_A7, COORD_B7, COORD_C7, COORD_D7, COORD_B6, COORD_C6, COORD_B5, COORD_D5}},
    {10, {COORD_H8, COORD_G8, COORD_H7, COORD_G7, COORD_F7, COORD_E7, COORD_G6, COORD_F6, COORD_G5, COORD_E5}},

    
    {10, {COORD_C6, COORD_D6, COORD_D7, COORD_D8, COORD_C8, COORD_F8, COORD_E8, COORD_E7, COORD_E6, COORD_F6}},
    {10, {COORD_C3, COORD_C4, COORD_B4, COORD_A4, COORD_A3, COORD_A6, COORD_A5, COORD_B5, COORD_C5, COORD_C6}},
    {10, {COORD_F3, COORD_E3, COORD_E2, COORD_E1, COORD_F1, COORD_C1, COORD_D1, COORD_D2, COORD_D3, COORD_C3}},
    {10, {COORD_F6, COORD_F5, COORD_G5, COORD_H5, COORD_H6, COORD_H3, COORD_H4, COORD_G4, COORD_F4, COORD_F3}}
};

constexpr Coord_to_feature coord_to_feature[HW2] = {
    {13, {{15, P38}, {28, P32}, {29, P39}, {34, P31}, {35, P31}, {39, P39}, {42, P34}, {43, P34}, {47, P39}, {50, P31}, {51, P31}, {55, P39}, {59, P39}}}, 
    {10, {{ 3, P30}, {15, P37}, {26, P30}, {29, P30}, {34, P32}, {39, P38}, {47, P35}, {50, P32}, {55, P38}, {59, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 7, P30}, {15, P36}, {22, P30}, {34, P33}, {39, P37}, {42, P35}, {50, P33}, {55, P37}, {60, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{11, P30}, {18, P30}, {34, P34}, {39, P36}, {42, P36}, {50, P34}, {54, P35}, {55, P36}, {60, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 9, P30}, {19, P30}, {34, P35}, {38, P36}, {42, P37}, {50, P35}, {54, P36}, {55, P35}, {60, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 5, P30}, {14, P36}, {23, P30}, {34, P36}, {38, P37}, {42, P38}, {50, P36}, {54, P37}, {60, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 1, P30}, {14, P37}, {27, P30}, {31, P30}, {34, P37}, {38, P38}, {46, P35}, {50, P37}, {54, P38}, {58, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {13, {{14, P38}, {30, P32}, {31, P39}, {33, P31}, {34, P38}, {38, P39}, {41, P34}, {42, P39}, {46, P39}, {49, P31}, {50, P38}, {54, P39}, {58, P39}}}, 
    {10, {{ 2, P30}, {15, P35}, {24, P30}, {29, P31}, {35, P32}, {39, P35}, {47, P32}, {51, P32}, {55, P34}, {59, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 2, P31}, { 3, P31}, {15, P34}, {28, P33}, {29, P38}, {34, P30}, {35, P30}, {39, P34}, {47, P38}, {55, P33}, {59, P36}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 2, P32}, { 7, P31}, {15, P33}, {26, P31}, {39, P33}, {42, P30}, {47, P34}, {50, P30}, {59, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 2, P33}, {11, P31}, {19, P31}, {22, P31}, {42, P31}, {59, P34}, {60, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 2, P34}, { 9, P31}, {18, P31}, {23, P31}, {42, P32}, {58, P34}, {60, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 2, P35}, { 5, P31}, {14, P33}, {27, P31}, {38, P33}, {42, P33}, {46, P34}, {50, P39}, {58, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 1, P31}, { 2, P36}, {14, P34}, {30, P33}, {31, P38}, {33, P30}, {34, P39}, {38, P34}, {46, P38}, {54, P33}, {58, P36}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 2, P37}, {14, P35}, {25, P30}, {31, P31}, {33, P32}, {38, P35}, {46, P32}, {49, P32}, {54, P34}, {58, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 6, P30}, {15, P32}, {20, P30}, {35, P33}, {39, P32}, {43, P35}, {51, P33}, {55, P32}, {63, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 3, P32}, { 6, P31}, {15, P31}, {24, P31}, {39, P31}, {43, P30}, {47, P31}, {51, P30}, {59, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 6, P32}, { 7, P32}, {15, P30}, {19, P32}, {28, P34}, {29, P37}, {47, P37}, {59, P32}, {60, P30}, {63, P39}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 6, P33}, {11, P32}, {23, P32}, {26, P32}, {47, P33}, {60, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 6, P34}, { 9, P32}, {22, P32}, {27, P32}, {46, P33}, {60, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 5, P32}, { 6, P35}, {14, P30}, {18, P32}, {30, P34}, {31, P37}, {46, P37}, {58, P32}, {60, P39}, {61, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 1, P32}, { 6, P36}, {14, P31}, {25, P31}, {38, P31}, {41, P30}, {46, P31}, {49, P30}, {58, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 6, P37}, {14, P32}, {21, P30}, {33, P33}, {38, P32}, {41, P35}, {49, P33}, {54, P32}, {61, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{10, P30}, {16, P30}, {35, P34}, {39, P30}, {43, P36}, {51, P34}, {53, P30}, {55, P31}, {63, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 3, P33}, {10, P31}, {19, P33}, {20, P31}, {43, P31}, {59, P31}, {63, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 7, P33}, {10, P32}, {23, P33}, {24, P32}, {47, P30}, {63, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{10, P33}, {11, P33}, {27, P33}, {28, P35}, {29, P36}, {47, P36}, {59, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 9, P33}, {10, P34}, {26, P33}, {30, P35}, {31, P36}, {46, P36}, {58, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 5, P33}, {10, P35}, {22, P33}, {25, P32}, {46, P30}, {61, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 1, P33}, {10, P36}, {18, P33}, {21, P31}, {41, P31}, {58, P31}, {61, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{10, P37}, {17, P30}, {33, P34}, {38, P30}, {41, P36}, {49, P34}, {52, P30}, {54, P31}, {61, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 8, P30}, {19, P34}, {35, P35}, {37, P30}, {43, P37}, {51, P35}, {53, P31}, {55, P30}, {63, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 3, P34}, { 8, P31}, {16, P31}, {23, P34}, {43, P32}, {57, P31}, {63, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 7, P34}, { 8, P32}, {20, P32}, {27, P34}, {45, P30}, {63, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 8, P33}, {11, P34}, {24, P33}, {30, P36}, {31, P35}, {45, P36}, {57, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 8, P34}, { 9, P34}, {25, P33}, {28, P36}, {29, P35}, {44, P36}, {56, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 5, P34}, { 8, P35}, {21, P32}, {26, P34}, {44, P30}, {61, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 1, P34}, { 8, P36}, {17, P31}, {22, P34}, {41, P32}, {56, P31}, {61, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 8, P37}, {18, P34}, {33, P35}, {36, P30}, {41, P37}, {49, P35}, {52, P31}, {54, P30}, {61, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 4, P30}, {13, P32}, {23, P35}, {35, P36}, {37, P32}, {43, P38}, {51, P36}, {53, P32}, {63, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 3, P35}, { 4, P31}, {13, P31}, {27, P35}, {37, P31}, {43, P33}, {45, P31}, {51, P39}, {57, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 4, P32}, { 7, P35}, {13, P30}, {16, P32}, {30, P37}, {31, P34}, {45, P37}, {57, P32}, {62, P39}, {63, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 4, P33}, {11, P35}, {20, P33}, {25, P34}, {45, P33}, {62, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 4, P34}, { 9, P35}, {21, P33}, {24, P34}, {44, P33}, {62, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 4, P35}, { 5, P35}, {12, P30}, {17, P32}, {28, P37}, {29, P34}, {44, P37}, {56, P32}, {61, P39}, {62, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 1, P35}, { 4, P36}, {12, P31}, {26, P35}, {36, P31}, {41, P33}, {44, P31}, {49, P39}, {56, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 4, P37}, {12, P32}, {22, P35}, {33, P36}, {36, P32}, {41, P38}, {49, P36}, {52, P32}, {61, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 0, P30}, {13, P35}, {27, P36}, {30, P31}, {35, P37}, {37, P35}, {45, P32}, {51, P37}, {53, P34}, {57, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 0, P31}, { 3, P36}, {13, P34}, {30, P38}, {31, P33}, {32, P30}, {35, P39}, {37, P34}, {45, P38}, {53, P33}, {57, P36}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 0, P32}, { 7, P36}, {13, P33}, {25, P35}, {37, P33}, {40, P30}, {45, P34}, {48, P30}, {57, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 0, P33}, {11, P36}, {16, P33}, {21, P34}, {40, P31}, {57, P34}, {62, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 0, P34}, { 9, P36}, {17, P33}, {20, P34}, {40, P32}, {56, P34}, {62, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 0, P35}, { 5, P36}, {12, P33}, {24, P35}, {36, P33}, {40, P33}, {44, P34}, {48, P39}, {56, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 0, P36}, { 1, P36}, {12, P34}, {28, P38}, {29, P33}, {32, P39}, {33, P39}, {36, P34}, {44, P38}, {52, P33}, {56, P36}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 0, P37}, {12, P35}, {26, P36}, {28, P31}, {33, P37}, {36, P35}, {44, P32}, {49, P37}, {52, P34}, {56, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {13, {{13, P38}, {30, P39}, {31, P32}, {32, P31}, {35, P38}, {37, P39}, {40, P34}, {43, P39}, {45, P39}, {48, P31}, {51, P38}, {53, P39}, {57, P39}}}, 
    {10, {{ 3, P37}, {13, P37}, {25, P36}, {30, P30}, {32, P32}, {37, P38}, {45, P35}, {48, P32}, {53, P38}, {57, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 7, P37}, {13, P36}, {21, P35}, {32, P33}, {37, P37}, {40, P35}, {48, P33}, {53, P37}, {62, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{11, P37}, {17, P34}, {32, P34}, {37, P36}, {40, P36}, {48, P34}, {52, P35}, {53, P36}, {62, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 9, P37}, {16, P34}, {32, P35}, {36, P36}, {40, P37}, {48, P35}, {52, P36}, {53, P35}, {62, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 5, P37}, {12, P36}, {20, P35}, {32, P36}, {36, P37}, {40, P38}, {48, P36}, {52, P37}, {62, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 1, P37}, {12, P37}, {24, P36}, {28, P30}, {32, P37}, {36, P38}, {44, P35}, {48, P37}, {52, P38}, {56, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {13, {{12, P38}, {28, P39}, {29, P32}, {32, P38}, {33, P38}, {36, P39}, {40, P39}, {41, P39}, {44, P39}, {48, P38}, {49, P38}, {52, P39}, {56, P39}}}  
};

constexpr Coord_to_feature coord_to_feature_move_ordering_end[HW2] = {
    { 6, {{ 2, P31}, { 3, P31}, { 7, P39}, {10, P34}, {11, P34}, {15, P39}}}, 
    { 3, {{ 2, P32}, { 7, P38}, {15, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P33}, { 7, P37}, {10, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P34}, { 7, P36}, {10, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P35}, { 6, P36}, {10, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P36}, { 6, P37}, {10, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P37}, { 6, P38}, {14, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 1, P31}, { 2, P38}, { 6, P39}, { 9, P34}, {10, P39}, {14, P39}}}, 
    { 3, {{ 3, P32}, { 7, P35}, {15, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 4, {{ 2, P30}, { 3, P30}, { 7, P34}, {15, P38}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 7, P33}, {10, P30}, {15, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{10, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{10, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 6, P33}, {10, P33}, {14, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 4, {{ 1, P30}, { 2, P39}, { 6, P34}, {14, P38}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P32}, { 6, P35}, {14, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P33}, { 7, P32}, {11, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 7, P31}, {11, P30}, {15, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{15, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{15, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{14, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{14, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 6, P31}, { 9, P30}, {14, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P33}, { 6, P32}, { 9, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P34}, { 7, P30}, {11, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{11, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{15, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{15, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{14, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{14, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{ 9, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P34}, { 6, P30}, { 9, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P35}, { 5, P30}, {11, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{11, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{13, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{13, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{12, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{12, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{ 9, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P35}, { 4, P30}, { 9, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P36}, { 5, P32}, {11, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 5, P31}, {11, P33}, {13, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{13, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{13, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{12, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{12, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 4, P31}, { 9, P33}, {12, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P36}, { 4, P32}, { 9, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P37}, { 5, P35}, {13, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 4, {{ 0, P30}, { 3, P39}, { 5, P34}, {13, P38}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 5, P33}, { 8, P30}, {13, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{ 8, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{ 8, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 4, P33}, { 8, P33}, {12, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 4, {{ 0, P39}, { 1, P39}, { 4, P34}, {12, P38}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P37}, { 4, P35}, {12, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 0, P31}, { 3, P38}, { 5, P39}, { 8, P34}, {11, P39}, {13, P39}}}, 
    { 3, {{ 0, P32}, { 5, P38}, {13, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P33}, { 5, P37}, { 8, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P34}, { 5, P36}, { 8, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P35}, { 4, P36}, { 8, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P36}, { 4, P37}, { 8, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P37}, { 4, P38}, {12, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 0, P38}, { 1, P38}, { 4, P39}, { 8, P39}, { 9, P39}, {12, P39}}}  
};


constexpr int feature_to_pattern[N_SYMMETRY_PATTERNS] = {
    0, 0, 0, 0,
    1, 1, 1, 1,
    2, 2, 2, 2,
    3, 3, 3, 3,
    4, 4, 4, 4,
    5, 5, 5, 5,
    6, 6, 6, 6,
    7, 7, 7, 7,
    8, 8, 8, 8,
    9, 9, 9, 9,
    10, 10, 10, 10,
    11, 11, 11, 11,
    12, 12, 12, 12,
    13, 13, 13, 13,
    14, 14, 14, 14,
    15, 15, 15, 15
};


int16_t pattern_arr[2][N_PHASES][N_PATTERNS][MAX_EVALUATE_IDX];
int16_t eval_sur0_sur1_arr[N_PHASES][MAX_SURROUND][MAX_SURROUND];
int16_t eval_num_arr[N_PHASES][MAX_STONE_NUM];
int16_t pattern_arr_move_ordering_end[2][N_PATTERNS][MAX_EVALUATE_IDX];


inline int swap_player_idx(int i, int pattern_size) {
    int j, ri = i;
    for (j = 0; j < pattern_size; ++j) {
        if ((i / pow3[j]) % 3 == 0)
            ri += pow3[j];
        else if ((i / pow3[j]) % 3 == 1)
            ri -= pow3[j];
    }
    return ri;
}


void init_pattern_arr_rev(int phase_idx, int pattern_idx, int siz) {
    for (int i = 0; i < (int)pow3[siz]; ++i) {
        int ri = swap_player_idx(i, siz);
        pattern_arr[1][phase_idx][pattern_idx][ri] = pattern_arr[0][phase_idx][pattern_idx][i];
    }
}


inline bool load_eval_file(const char* file, bool show_log) {
    if (show_log)
        std::cerr << "evaluation file " << file << std::endl;
    bool failed = false;
    std::vector<int16_t> unzipped_params = load_unzip_egev2(file, show_log, &failed);
    if (failed) {
        return false;
    }
    constexpr int pattern_sizes[N_PATTERNS] = {
        8, 8, 8, 9,
        5, 6, 7, 10, 
        10, 10, 10, 10, 
        10, 10, 10, 10
    };
    size_t param_idx = 0;
    for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
        for (int pattern_idx = 0; pattern_idx < N_PATTERNS; ++pattern_idx) {
            std::memcpy(pattern_arr[0][phase_idx][pattern_idx], &unzipped_params[param_idx], sizeof(short) * pow3[pattern_sizes[pattern_idx]]);
            param_idx += pow3[pattern_sizes[pattern_idx]];
        }
        std::memcpy(eval_num_arr[phase_idx], &unzipped_params[param_idx], sizeof(short) * MAX_STONE_NUM);
        param_idx += MAX_STONE_NUM;
        std::memcpy(eval_sur0_sur1_arr[phase_idx], &unzipped_params[param_idx], sizeof(short) * MAX_SURROUND * MAX_SURROUND);
        param_idx += MAX_SURROUND * MAX_SURROUND;
    }
    if (thread_pool.size() >= 2) {
        std::future<void> tasks[N_PHASES * N_PATTERNS];
        int i = 0;
        for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
            for (int pattern_idx = 0; pattern_idx < N_PATTERNS; ++pattern_idx) {
                bool pushed = false;
                while (!pushed) {
                    tasks[i] = thread_pool.push(&pushed, std::bind(init_pattern_arr_rev, phase_idx, pattern_idx, pattern_sizes[pattern_idx]));
                }
                ++i;
            }
        }
        for (std::future<void> &task: tasks)
            task.get();
    } else{
        for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
            for (int pattern_idx = 0; pattern_idx < N_PATTERNS; ++pattern_idx) {
                init_pattern_arr_rev(phase_idx, pattern_idx, pattern_sizes[pattern_idx]);
            }
        }
    }
    return true;
}

inline bool load_eval_move_ordering_end_file(const char* file, bool show_log) {
    if (show_log)
        std::cerr << "evaluation for move ordering end file " << file << std::endl;
    FILE* fp;
    if (!file_open(&fp, file, "rb")) {
        std::cerr << "[ERROR] [FATAL] can't open eval " << file << std::endl;
        return false;
    }
    constexpr int pattern_sizes[N_PATTERNS_MO_END] = {10, 10, 10, 10};
    for (int pattern_idx = 0; pattern_idx < N_PATTERNS_MO_END; ++pattern_idx) {
        if (fread(pattern_arr_move_ordering_end[0][pattern_idx], 2, pow3[pattern_sizes[pattern_idx]], fp) < pow3[pattern_sizes[pattern_idx]]) {
            std::cerr << "[ERROR] [FATAL] evaluation file file for move ordering broken" << std::endl;
            fclose(fp);
            return false;
        }
    }
    for (int pattern_idx = 0; pattern_idx < N_PATTERNS_MO_END; ++pattern_idx) {
        for (int i = 0; i < (int)pow3[pattern_sizes[pattern_idx]]; ++i) {
            int ri = swap_player_idx(i, pattern_sizes[pattern_idx]);
            pattern_arr_move_ordering_end[1][pattern_idx][ri] = pattern_arr_move_ordering_end[0][pattern_idx][i];
        }
    }
    return true;
}


inline bool evaluate_init(const char* file, const char* mo_end_nws_file, bool show_log) {
    bool eval_loaded = load_eval_file(file, show_log);
    if (!eval_loaded) {
        std::cerr << "[ERROR] [FATAL] evaluation file not loaded" << std::endl;
        return false;
    }
    bool eval_move_ordering_end_nws_loaded = load_eval_move_ordering_end_file(mo_end_nws_file, show_log);
    if (!eval_move_ordering_end_nws_loaded) {
        std::cerr << "[ERROR] [FATAL] evaluation file for move ordering end not loaded" << std::endl;
        return false;
    }
    if (show_log)
        std::cerr << "evaluation function initialized" << std::endl;
    return true;
}


bool evaluate_init(const std::string file, std::string mo_end_nws_file, bool show_log) {
    return evaluate_init(file.c_str(), mo_end_nws_file.c_str(), show_log);
}


bool evaluate_init(bool show_log) {
    return evaluate_init(EXE_DIRECTORY_PATH + "resources/eval.egev2", EXE_DIRECTORY_PATH + "resources/eval_move_ordering_end.egev", show_log);
}


inline int calc_surround(uint64_t discs, uint64_t empties) {
    uint64_t hmask = discs & 0x7E7E7E7E7E7E7E7EULL;
    uint64_t vmask = discs & 0x00FFFFFFFFFFFF00ULL;
    uint64_t hvmask = discs & 0x007E7E7E7E7E7E00ULL;
    uint64_t res = 
        (hmask << 1) | (hmask >> 1) | 
        (vmask << HW) | (vmask >> HW) | 
        (hvmask << HW_M1) | (hvmask >> HW_M1) | 
        (hvmask << HW_P1) | (hvmask >> HW_P1);
    return pop_count_ull(empties & res);
}
#define CALC_SURROUND_FUNCTION


inline int calc_pattern(const int phase_idx, Eval_search *eval) {
    int res = 0;
    for (int i = 0; i < N_SYMMETRY_PATTERNS; ++i)
        res += pattern_arr[eval->reversed[eval->feature_idx]][phase_idx][feature_to_pattern[i]][eval->features[eval->feature_idx][i]];
    return res;
}


inline int calc_pattern_move_ordering_end(Eval_search *eval) {
    int res = 0;
    for (int i = EVAL_IDX_START_MOVE_ORDERING_END; i < EVAL_IDX_END_MOVE_ORDERING_END; ++i)
        res += pattern_arr_move_ordering_end[eval->reversed[eval->feature_idx]][feature_to_pattern[i] - EVAL_FEATURE_START_MOVE_ORDERING_END][eval->features[eval->feature_idx][i]];
    return res;
}

inline void calc_eval_features(Board *board, Eval_search *eval);


inline int mid_evaluate(Board *board) {
    Search search(board);
    calc_eval_features(board, &search.eval);
    int phase_idx, sur0, sur1, num0;
    uint64_t empties;
    phase_idx = search.phase();
    empties = ~(search.board.player | search.board.opponent);
    sur0 = calc_surround(search.board.player, empties);
    sur1 = calc_surround(search.board.opponent, empties);
    num0 = pop_count_ull(search.board.player);
    int res = calc_pattern(phase_idx, &search.eval) + 
        eval_num_arr[phase_idx][num0] + 
        eval_sur0_sur1_arr[phase_idx][sur0][sur1];
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    res = std::clamp(res, -SCORE_MAX, SCORE_MAX);
    return res;
}


inline int mid_evaluate_diff(Search *search) {
    int phase_idx, sur0, sur1, num0;
    uint64_t empties;
    phase_idx = search->phase();
    empties = ~(search->board.player | search->board.opponent);
    sur0 = calc_surround(search->board.player, empties);
    sur1 = calc_surround(search->board.opponent, empties);
    num0 = pop_count_ull(search->board.player);
    int res = calc_pattern(phase_idx, &search->eval) + 
        eval_num_arr[phase_idx][num0] + 
        eval_sur0_sur1_arr[phase_idx][sur0][sur1];
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    res = std::clamp(res, -SCORE_MAX, SCORE_MAX);
    return res;
}


inline int mid_evaluate_move_ordering_end(Search *search) {
    int res = calc_pattern_move_ordering_end(&search->eval);
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    return res;
}

inline uint_fast16_t pick_pattern_idx(const uint_fast8_t b_arr[], const Feature_to_coord *f) {
    uint_fast16_t res = 0;
    for (int i = 0; i < f->n_cells; ++i) {
        res *= 3;
        res += b_arr[HW2_M1 - f->cells[i]];
    }
    return res;
}

inline void calc_eval_features(Board *board, Eval_search *eval) {
    uint_fast8_t b_arr[HW2];
    board->translate_to_arr_player(b_arr);
    for (int i = 0; i < N_SYMMETRY_PATTERNS; ++i)
        eval->features[0][i] = pick_pattern_idx(b_arr, &feature_to_coord[i]);
    eval->reversed[0] = 0;
    eval->feature_idx = 0;
}

inline void eval_move(Eval_search *eval, const Flip *flip) {
    uint_fast8_t i, cell;
    uint64_t f;
    for (i = 0; i < N_SYMMETRY_PATTERNS; ++i) {
        eval->features[eval->feature_idx + 1][i] = eval->features[eval->feature_idx][i];
    }
    if (eval->reversed[eval->feature_idx]) {
        for (i = 0; i < MAX_CELL_PATTERNS && coord_to_feature[flip->pos].features[i].x; ++i)
            eval->features[eval->feature_idx + 1][coord_to_feature[flip->pos].features[i].feature] -= coord_to_feature[flip->pos].features[i].x;
        f = flip->flip;
        for (cell = first_bit(&f); f; cell = next_bit(&f)) {
            for (i = 0; i < MAX_CELL_PATTERNS && coord_to_feature[cell].features[i].x; ++i)
                eval->features[eval->feature_idx + 1][coord_to_feature[cell].features[i].feature] += coord_to_feature[cell].features[i].x;
        }
    } else{
        for (i = 0; i < MAX_CELL_PATTERNS && coord_to_feature[flip->pos].features[i].x; ++i)
            eval->features[eval->feature_idx + 1][coord_to_feature[flip->pos].features[i].feature] -= 2 * coord_to_feature[flip->pos].features[i].x;
        f = flip->flip;
        for (cell = first_bit(&f); f; cell = next_bit(&f)) {
            for (i = 0; i < MAX_CELL_PATTERNS && coord_to_feature[cell].features[i].x; ++i)
                eval->features[eval->feature_idx + 1][coord_to_feature[cell].features[i].feature] -= coord_to_feature[cell].features[i].x;
        }
    }
    eval->reversed[eval->feature_idx + 1] = eval->reversed[eval->feature_idx] ^ 1;
    ++eval->feature_idx;
}

inline void eval_undo(Eval_search *eval, const Flip *flip) {
    --eval->feature_idx;
}


inline void eval_pass(Eval_search *eval) {
    eval->reversed[eval->feature_idx] ^= 1;
}



inline void eval_move_endsearch(Eval_search *eval, const Flip *flip) {
    uint_fast8_t i, cell;
    uint64_t f;
    for (i = EVAL_IDX_START_MOVE_ORDERING_END; i < EVAL_IDX_END_MOVE_ORDERING_END; ++i) {
        eval->features[eval->feature_idx + 1][i] = eval->features[eval->feature_idx][i];
    }
    if (eval->reversed[eval->feature_idx]) {
        for (i = 0; i < MAX_CELL_PATTERNS_MOVE_ORDERING_END && coord_to_feature_move_ordering_end[flip->pos].features[i].x; ++i)
            eval->features[eval->feature_idx + 1][coord_to_feature_move_ordering_end[flip->pos].features[i].feature + EVAL_IDX_START_MOVE_ORDERING_END] -= coord_to_feature_move_ordering_end[flip->pos].features[i].x;
        f = flip->flip;
        for (cell = first_bit(&f); f; cell = next_bit(&f)) {
            for (i = 0; i < MAX_CELL_PATTERNS_MOVE_ORDERING_END && coord_to_feature_move_ordering_end[cell].features[i].x; ++i)
                eval->features[eval->feature_idx + 1][coord_to_feature_move_ordering_end[cell].features[i].feature + EVAL_IDX_START_MOVE_ORDERING_END] += coord_to_feature_move_ordering_end[cell].features[i].x;
        }
    } else{
        for (i = 0; i < MAX_CELL_PATTERNS_MOVE_ORDERING_END && coord_to_feature_move_ordering_end[flip->pos].features[i].x; ++i)
            eval->features[eval->feature_idx + 1][coord_to_feature_move_ordering_end[flip->pos].features[i].feature + EVAL_IDX_START_MOVE_ORDERING_END] -= 2 * coord_to_feature_move_ordering_end[flip->pos].features[i].x;
        f = flip->flip;
        for (cell = first_bit(&f); f; cell = next_bit(&f)) {
            for (i = 0; i < MAX_CELL_PATTERNS_MOVE_ORDERING_END && coord_to_feature_move_ordering_end[cell].features[i].x; ++i)
                eval->features[eval->feature_idx + 1][coord_to_feature_move_ordering_end[cell].features[i].feature + EVAL_IDX_START_MOVE_ORDERING_END] -= coord_to_feature_move_ordering_end[cell].features[i].x;
        }
    }
    eval->reversed[eval->feature_idx + 1] = eval->reversed[eval->feature_idx] ^ 1;
    ++eval->feature_idx;
}

inline void eval_undo_endsearch(Eval_search *eval, const Flip *flip) {
    --eval->feature_idx;
}


inline void eval_pass_endsearch(Eval_search *eval) {
    eval->reversed[eval->feature_idx] ^= 1;
}

// ===== FILE: Egaroucid/src/engine/evaluate_generic_7_7_beta.hpp =====



#pragma once
#include <iostream>
#include <fstream>
#include <cstring>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "search.hpp"
#include "util.hpp"
#include "evaluate_common.hpp"

constexpr int EVAL_IDX_START_MOVE_ORDERING_END = 32;
constexpr int EVAL_IDX_END_MOVE_ORDERING_END = 48;
constexpr int EVAL_FEATURE_START_MOVE_ORDERING_END = 8;
constexpr int MAX_CELL_PATTERNS_MOVE_ORDERING_END = 6;


constexpr Feature_to_coord feature_to_coord[N_PATTERN_FEATURES] = {
    
    {10, {COORD_A1, COORD_A2, COORD_B2, COORD_C2, COORD_D2, COORD_E2, COORD_F2, COORD_G2, COORD_H2, COORD_H1}},
    {10, {COORD_H1, COORD_G1, COORD_G2, COORD_G3, COORD_G4, COORD_G5, COORD_G6, COORD_G7, COORD_G8, COORD_H8}},
    {10, {COORD_H8, COORD_H7, COORD_G7, COORD_F7, COORD_E7, COORD_D7, COORD_C7, COORD_B7, COORD_A7, COORD_A8}},
    {10, {COORD_A8, COORD_B8, COORD_B7, COORD_B6, COORD_B5, COORD_B4, COORD_B3, COORD_B2, COORD_B1, COORD_A1}},
    
    
    {10, {COORD_B2, COORD_A3, COORD_B3, COORD_C3, COORD_D3, COORD_E3, COORD_F3, COORD_G3, COORD_H3, COORD_G2}},
    {10, {COORD_G2, COORD_F1, COORD_F2, COORD_F3, COORD_F4, COORD_F5, COORD_F6, COORD_F7, COORD_F8, COORD_G7}},
    {10, {COORD_G7, COORD_H6, COORD_G6, COORD_F6, COORD_E6, COORD_D6, COORD_C6, COORD_B6, COORD_A6, COORD_B7}},
    {10, {COORD_B7, COORD_C8, COORD_C7, COORD_C6, COORD_C5, COORD_C4, COORD_C3, COORD_C2, COORD_C1, COORD_B2}},

    
    {10, {COORD_D3, COORD_A4, COORD_B4, COORD_C4, COORD_D4, COORD_E4, COORD_F4, COORD_G4, COORD_H4, COORD_E3}},
    {10, {COORD_F4, COORD_E1, COORD_E2, COORD_E3, COORD_E4, COORD_E5, COORD_E6, COORD_E7, COORD_E8, COORD_F5}},
    {10, {COORD_E6, COORD_H5, COORD_G5, COORD_F5, COORD_E5, COORD_D5, COORD_C5, COORD_B5, COORD_A5, COORD_D6}},
    {10, {COORD_C5, COORD_D8, COORD_D7, COORD_D6, COORD_D5, COORD_D4, COORD_D3, COORD_D2, COORD_D1, COORD_C4}},

    
    {10, {COORD_B2, COORD_C1, COORD_D1, COORD_E2, COORD_F3, COORD_G4, COORD_H5, COORD_H6, COORD_G7, COORD_G2}},
    {10, {COORD_G2, COORD_H3, COORD_H4, COORD_G5, COORD_F6, COORD_E7, COORD_D8, COORD_C8, COORD_B7, COORD_G7}},
    {10, {COORD_G7, COORD_F8, COORD_E8, COORD_D7, COORD_C6, COORD_B5, COORD_A4, COORD_A3, COORD_B2, COORD_B7}},
    {10, {COORD_B7, COORD_A6, COORD_A5, COORD_B4, COORD_C3, COORD_D2, COORD_E1, COORD_F1, COORD_G2, COORD_B2}},
    
    
    {10, {COORD_B1, COORD_C1, COORD_D2, COORD_E3, COORD_F2, COORD_G3, COORD_F4, COORD_G5, COORD_H6, COORD_H7}},
    {10, {COORD_H2, COORD_H3, COORD_G4, COORD_F5, COORD_G6, COORD_F7, COORD_E6, COORD_D7, COORD_C8, COORD_B8}},
    {10, {COORD_G8, COORD_F8, COORD_E7, COORD_D6, COORD_C7, COORD_B6, COORD_C5, COORD_B4, COORD_A3, COORD_A2}},
    {10, {COORD_A7, COORD_A6, COORD_B5, COORD_C4, COORD_B3, COORD_C2, COORD_D3, COORD_E2, COORD_F1, COORD_G1}},

    
    {10, {COORD_A1, COORD_B1, COORD_C2, COORD_D3, COORD_E4, COORD_F5, COORD_G6, COORD_H7, COORD_H8, COORD_D5}},
    {10, {COORD_H1, COORD_H2, COORD_G3, COORD_F4, COORD_E5, COORD_D6, COORD_C7, COORD_B8, COORD_A8, COORD_D4}},
    {10, {COORD_H8, COORD_G8, COORD_F7, COORD_E6, COORD_D5, COORD_C4, COORD_B3, COORD_A2, COORD_A1, COORD_E4}},
    {10, {COORD_A8, COORD_A7, COORD_B6, COORD_C5, COORD_D4, COORD_E3, COORD_F2, COORD_G1, COORD_H1, COORD_E5}},

    
    {10, {COORD_A1, COORD_B2, COORD_C3, COORD_D4, COORD_E5, COORD_F6, COORD_G7, COORD_H8, COORD_A2, COORD_B1}},
    {10, {COORD_H8, COORD_G7, COORD_F6, COORD_E5, COORD_D4, COORD_C3, COORD_B2, COORD_A1, COORD_H7, COORD_G8}},
    {10, {COORD_H1, COORD_G2, COORD_F3, COORD_E4, COORD_D5, COORD_C6, COORD_B7, COORD_A8, COORD_H2, COORD_G1}},
    {10, {COORD_A8, COORD_B7, COORD_C6, COORD_D5, COORD_E4, COORD_F3, COORD_G2, COORD_H1, COORD_A7, COORD_B8}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_A2, COORD_B2, COORD_C2, COORD_A3, COORD_B3, COORD_C3, COORD_D4}},
    {10, {COORD_H1, COORD_H2, COORD_H3, COORD_G1, COORD_G2, COORD_G3, COORD_F1, COORD_F2, COORD_F3, COORD_E4}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_H7, COORD_G7, COORD_F7, COORD_H6, COORD_G6, COORD_F6, COORD_E5}},
    {10, {COORD_A8, COORD_A7, COORD_A6, COORD_B8, COORD_B7, COORD_B6, COORD_C8, COORD_C7, COORD_C6, COORD_D5}},
    
    
    {10, {COORD_B2, COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_G1, COORD_H1, COORD_G2}},
    {10, {COORD_B2, COORD_A1, COORD_A2, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A7, COORD_A8, COORD_B7}},
    {10, {COORD_B7, COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_G8, COORD_H8, COORD_G7}},
    {10, {COORD_G2, COORD_H1, COORD_H2, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H7, COORD_H8, COORD_G7}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_A2, COORD_B2, COORD_C2, COORD_A3, COORD_B3, COORD_A4}},
    {10, {COORD_H1, COORD_G1, COORD_F1, COORD_E1, COORD_H2, COORD_G2, COORD_F2, COORD_H3, COORD_G3, COORD_H4}},
    {10, {COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_A7, COORD_B7, COORD_C7, COORD_A6, COORD_B6, COORD_A5}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_E8, COORD_H7, COORD_G7, COORD_F7, COORD_H6, COORD_G6, COORD_H5}},

    
    {10, {COORD_A1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_H1, COORD_C2, COORD_D2, COORD_E2, COORD_F2}},
    {10, {COORD_A1, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A8, COORD_B3, COORD_B4, COORD_B5, COORD_B6}},
    {10, {COORD_A8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_H8, COORD_C7, COORD_D7, COORD_E7, COORD_F7}},
    {10, {COORD_H1, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H8, COORD_G3, COORD_G4, COORD_G5, COORD_G6}},

    
    {10, {COORD_A1, COORD_B2, COORD_C3, COORD_D4, COORD_B1, COORD_C2, COORD_D3, COORD_A2, COORD_B3, COORD_C4}},
    {10, {COORD_H1, COORD_G2, COORD_F3, COORD_E4, COORD_G1, COORD_F2, COORD_E3, COORD_H2, COORD_G3, COORD_F4}},
    {10, {COORD_A8, COORD_B7, COORD_C6, COORD_D5, COORD_B8, COORD_C7, COORD_D6, COORD_A7, COORD_B6, COORD_C5}},
    {10, {COORD_H8, COORD_G7, COORD_F6, COORD_E5, COORD_G8, COORD_F7, COORD_E6, COORD_H7, COORD_G6, COORD_F5}},

    
    {10, {COORD_C2, COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_G1, COORD_H1, COORD_F2}},
    {10, {COORD_B3, COORD_A1, COORD_A2, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A7, COORD_A8, COORD_B6}},
    {10, {COORD_C7, COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_G8, COORD_H8, COORD_F7}},
    {10, {COORD_G3, COORD_H1, COORD_H2, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H7, COORD_H8, COORD_G6}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_A2, COORD_B2, COORD_A3, COORD_A4, COORD_A5}},
    {10, {COORD_H1, COORD_G1, COORD_F1, COORD_E1, COORD_D1, COORD_H2, COORD_G2, COORD_H3, COORD_H4, COORD_H5}},
    {10, {COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_A7, COORD_B7, COORD_A6, COORD_A5, COORD_A4}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_E8, COORD_D8, COORD_H7, COORD_G7, COORD_H6, COORD_H5, COORD_H4}},

    
    {10, {COORD_A1, COORD_B1, COORD_A2, COORD_B2, COORD_C2, COORD_D2, COORD_B3, COORD_C3, COORD_B4, COORD_D4}},
    {10, {COORD_H1, COORD_G1, COORD_H2, COORD_G2, COORD_F2, COORD_E2, COORD_G3, COORD_F3, COORD_G4, COORD_E4}},
    {10, {COORD_A8, COORD_B8, COORD_A7, COORD_B7, COORD_C7, COORD_D7, COORD_B6, COORD_C6, COORD_B5, COORD_D5}},
    {10, {COORD_H8, COORD_G8, COORD_H7, COORD_G7, COORD_F7, COORD_E7, COORD_G6, COORD_F6, COORD_G5, COORD_E5}},

    
    {10, {COORD_F3, COORD_E3, COORD_E2, COORD_E1, COORD_F1, COORD_C1, COORD_D1, COORD_D2, COORD_D3, COORD_C3}},
    {10, {COORD_C6, COORD_D6, COORD_D7, COORD_D8, COORD_C8, COORD_F8, COORD_E8, COORD_E7, COORD_E6, COORD_F6}},
    {10, {COORD_C3, COORD_C4, COORD_B4, COORD_A4, COORD_A3, COORD_A6, COORD_A5, COORD_B5, COORD_C5, COORD_C6}},
    {10, {COORD_F6, COORD_F5, COORD_G5, COORD_H5, COORD_H6, COORD_H3, COORD_H4, COORD_G4, COORD_F4, COORD_F3}}
};

constexpr Coord_to_feature coord_to_feature[HW2] = {
    {17, {{ 1, P30}, { 2, P39}, {20, P31}, {22, P39}, {24, P32}, {25, P39}, {30, P39}, {34, P31}, {35, P31}, {39, P39}, {42, P34}, {43, P34}, {47, P39}, {50, P31}, {51, P31}, {55, P39}, {59, P39}}}, 
    {11, {{ 1, P31}, {18, P39}, {22, P38}, {25, P30}, {30, P38}, {34, P32}, {39, P38}, {47, P35}, {50, P32}, {55, P38}, {59, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 5, P31}, {14, P38}, {18, P38}, {30, P37}, {34, P33}, {39, P37}, {42, P35}, {50, P33}, {55, P37}, {61, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 9, P31}, {14, P37}, {34, P34}, {39, P36}, {42, P36}, {50, P34}, {54, P35}, {55, P36}, {61, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{11, P38}, {13, P33}, {34, P35}, {38, P36}, {42, P37}, {50, P35}, {54, P36}, {55, P35}, {61, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 7, P38}, {13, P32}, {17, P31}, {31, P33}, {34, P36}, {38, P37}, {42, P38}, {50, P36}, {54, P37}, {61, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 3, P38}, {17, P30}, {21, P32}, {27, P30}, {31, P36}, {34, P37}, {38, P38}, {46, P35}, {50, P37}, {54, P38}, {58, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {17, {{ 2, P30}, { 3, P39}, {21, P31}, {23, P39}, {26, P32}, {27, P39}, {31, P39}, {33, P31}, {34, P38}, {38, P39}, {41, P34}, {42, P39}, {46, P39}, {49, P31}, {50, P38}, {54, P39}, {58, P39}}}, 
    {11, {{ 2, P38}, {16, P30}, {20, P32}, {25, P31}, {30, P36}, {35, P32}, {39, P35}, {47, P32}, {51, P32}, {55, P34}, {59, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {16, {{ 1, P32}, { 2, P37}, { 5, P30}, { 6, P39}, {12, P31}, {13, P30}, {14, P39}, {24, P33}, {25, P38}, {30, P35}, {34, P30}, {35, P30}, {39, P34}, {47, P38}, {55, P33}, {59, P36}, { 0, PNO}}}, 
    {10, {{ 2, P36}, { 5, P32}, {17, P34}, {22, P37}, {30, P34}, {39, P33}, {42, P30}, {47, P34}, {50, P30}, {59, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 2, P35}, { 9, P32}, {13, P34}, {18, P37}, {42, P31}, {59, P34}, {61, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 2, P34}, {11, P37}, {14, P36}, {17, P32}, {42, P32}, {58, P34}, {61, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 2, P33}, { 7, P37}, {18, P35}, {21, P33}, {31, P32}, {38, P33}, {42, P33}, {46, P34}, {50, P39}, {58, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {16, {{ 2, P32}, { 3, P37}, { 6, P30}, { 7, P39}, {13, P31}, {14, P30}, {15, P39}, {26, P33}, {27, P38}, {31, P35}, {33, P30}, {34, P39}, {38, P34}, {46, P38}, {54, P33}, {58, P36}, { 0, PNO}}}, 
    {11, {{ 2, P31}, {19, P39}, {23, P38}, {27, P31}, {31, P38}, {33, P32}, {38, P35}, {46, P32}, {49, P32}, {54, P34}, {58, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 6, P38}, {12, P32}, {16, P31}, {30, P33}, {35, P33}, {39, P32}, {43, P35}, {51, P33}, {55, P32}, {63, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 1, P33}, { 6, P37}, {17, P35}, {20, P33}, {30, P32}, {39, P31}, {43, P30}, {47, P31}, {51, P30}, {59, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 5, P33}, { 6, P36}, {13, P35}, {24, P34}, {25, P37}, {30, P31}, {47, P37}, {59, P32}, {61, P30}, {63, P39}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 6, P35}, { 9, P33}, {10, P39}, {17, P33}, {22, P36}, {47, P33}, {61, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 6, P34}, {10, P30}, {11, P36}, {18, P36}, {21, P34}, {46, P33}, {61, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 6, P33}, { 7, P36}, {14, P35}, {26, P34}, {27, P37}, {31, P31}, {46, P37}, {58, P32}, {61, P39}, {62, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 3, P36}, { 6, P32}, {18, P34}, {23, P37}, {31, P34}, {38, P31}, {41, P30}, {46, P31}, {49, P30}, {58, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 6, P31}, {15, P38}, {19, P38}, {31, P37}, {33, P33}, {38, P32}, {41, P35}, {49, P33}, {54, P32}, {62, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{10, P38}, {12, P33}, {35, P34}, {39, P30}, {43, P36}, {51, P34}, {53, P30}, {55, P31}, {63, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 1, P34}, {10, P37}, {13, P36}, {16, P32}, {43, P31}, {59, P31}, {63, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 5, P34}, { 9, P30}, {10, P36}, {17, P36}, {20, P34}, {47, P30}, {63, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 9, P34}, {10, P35}, {21, P35}, {23, P30}, {24, P35}, {25, P36}, {30, P30}, {47, P36}, {59, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{10, P34}, {11, P35}, {20, P30}, {22, P35}, {26, P35}, {27, P36}, {31, P30}, {46, P36}, {58, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 7, P35}, {10, P33}, {11, P39}, {18, P33}, {23, P36}, {46, P30}, {62, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 3, P35}, {10, P32}, {14, P34}, {19, P37}, {41, P31}, {58, P31}, {62, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{10, P31}, {15, P37}, {33, P34}, {38, P30}, {41, P36}, {49, P34}, {52, P30}, {54, P31}, {62, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 8, P31}, {13, P37}, {35, P35}, {37, P30}, {43, P37}, {51, P35}, {53, P31}, {55, P30}, {63, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 1, P35}, { 8, P32}, {12, P34}, {17, P37}, {43, P32}, {57, P31}, {63, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 5, P35}, { 8, P33}, { 9, P39}, {16, P33}, {21, P36}, {45, P30}, {63, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 8, P34}, { 9, P35}, {20, P35}, {22, P30}, {26, P36}, {27, P35}, {29, P30}, {45, P36}, {57, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 8, P35}, {11, P34}, {21, P30}, {23, P35}, {24, P36}, {25, P35}, {28, P30}, {44, P36}, {56, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 7, P34}, { 8, P36}, {11, P30}, {19, P36}, {22, P34}, {44, P30}, {62, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 3, P34}, { 8, P37}, {15, P36}, {18, P32}, {41, P32}, {56, P31}, {62, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 8, P38}, {14, P33}, {33, P35}, {36, P30}, {41, P37}, {49, P35}, {52, P31}, {54, P30}, {62, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 4, P31}, {13, P38}, {17, P38}, {29, P37}, {35, P36}, {37, P32}, {43, P38}, {51, P36}, {53, P32}, {63, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 1, P36}, { 4, P32}, {16, P34}, {21, P37}, {29, P34}, {37, P31}, {43, P33}, {45, P31}, {51, P39}, {57, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 4, P33}, { 5, P36}, {12, P35}, {26, P37}, {27, P34}, {29, P31}, {45, P37}, {57, P32}, {60, P39}, {63, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 4, P34}, { 8, P30}, { 9, P36}, {16, P36}, {23, P34}, {45, P33}, {60, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 4, P35}, { 8, P39}, {11, P33}, {19, P33}, {20, P36}, {44, P33}, {60, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 4, P36}, { 7, P33}, {15, P35}, {24, P37}, {25, P34}, {28, P31}, {44, P37}, {56, P32}, {60, P30}, {62, P39}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 3, P33}, { 4, P37}, {19, P35}, {22, P33}, {28, P32}, {36, P31}, {41, P33}, {44, P31}, {49, P39}, {56, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 4, P38}, {14, P32}, {18, P31}, {28, P33}, {33, P36}, {36, P32}, {41, P38}, {49, P36}, {52, P32}, {62, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 0, P31}, {17, P39}, {21, P38}, {26, P31}, {29, P38}, {35, P37}, {37, P35}, {45, P32}, {51, P37}, {53, P34}, {57, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {16, {{ 0, P32}, { 1, P37}, { 4, P30}, { 5, P39}, {12, P30}, {13, P39}, {15, P31}, {26, P38}, {27, P33}, {29, P35}, {32, P30}, {35, P39}, {37, P34}, {45, P38}, {53, P33}, {57, P36}, { 0, PNO}}}, 
    {10, {{ 0, P33}, { 5, P37}, {16, P35}, {23, P33}, {29, P32}, {37, P33}, {40, P30}, {45, P34}, {48, P30}, {57, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 0, P34}, { 9, P37}, {12, P36}, {19, P32}, {40, P31}, {57, P34}, {60, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 0, P35}, {11, P32}, {15, P34}, {16, P37}, {40, P32}, {56, P34}, {60, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 0, P36}, { 7, P32}, {19, P34}, {20, P37}, {28, P34}, {36, P33}, {40, P33}, {44, P34}, {48, P39}, {56, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {16, {{ 0, P37}, { 3, P32}, { 4, P39}, { 7, P30}, {12, P39}, {14, P31}, {15, P30}, {24, P38}, {25, P33}, {28, P35}, {32, P39}, {33, P39}, {36, P34}, {44, P38}, {52, P33}, {56, P36}, { 0, PNO}}}, 
    {11, {{ 0, P38}, {18, P30}, {22, P32}, {24, P31}, {28, P36}, {33, P37}, {36, P35}, {44, P32}, {49, P37}, {52, P34}, {56, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {17, {{ 0, P30}, { 1, P39}, {21, P39}, {23, P31}, {26, P39}, {27, P32}, {29, P39}, {32, P31}, {35, P38}, {37, P39}, {40, P34}, {43, P39}, {45, P39}, {48, P31}, {51, P38}, {53, P39}, {57, P39}}}, 
    {11, {{ 1, P38}, {19, P30}, {23, P32}, {26, P30}, {29, P36}, {32, P32}, {37, P38}, {45, P35}, {48, P32}, {53, P38}, {57, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 5, P38}, {15, P32}, {19, P31}, {29, P33}, {32, P33}, {37, P37}, {40, P35}, {48, P33}, {53, P37}, {60, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 9, P38}, {15, P33}, {32, P34}, {37, P36}, {40, P36}, {48, P34}, {52, P35}, {53, P36}, {60, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{11, P31}, {12, P37}, {32, P35}, {36, P36}, {40, P37}, {48, P35}, {52, P36}, {53, P35}, {60, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 7, P31}, {12, P38}, {16, P38}, {28, P37}, {32, P36}, {36, P37}, {40, P38}, {48, P36}, {52, P37}, {60, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 3, P31}, {16, P39}, {20, P38}, {24, P30}, {28, P38}, {32, P37}, {36, P38}, {44, P35}, {48, P37}, {52, P38}, {56, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {17, {{ 0, P39}, { 3, P30}, {20, P39}, {22, P31}, {24, P39}, {25, P32}, {28, P39}, {32, P38}, {33, P38}, {36, P39}, {40, P39}, {41, P39}, {44, P39}, {48, P38}, {49, P38}, {52, P39}, {56, P39}}}, 
};

constexpr Coord_to_feature coord_to_feature_move_ordering_end[HW2] = {
    { 6, {{ 2, P31}, { 3, P31}, { 7, P39}, {10, P34}, {11, P34}, {15, P39}}}, 
    { 3, {{ 2, P32}, { 7, P38}, {15, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P33}, { 7, P37}, {10, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P34}, { 7, P36}, {10, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P35}, { 6, P36}, {10, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P36}, { 6, P37}, {10, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P37}, { 6, P38}, {14, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 1, P31}, { 2, P38}, { 6, P39}, { 9, P34}, {10, P39}, {14, P39}}}, 
    { 3, {{ 3, P32}, { 7, P35}, {15, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 4, {{ 2, P30}, { 3, P30}, { 7, P34}, {15, P38}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 7, P33}, {10, P30}, {15, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{10, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{10, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 6, P33}, {10, P33}, {14, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 4, {{ 1, P30}, { 2, P39}, { 6, P34}, {14, P38}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P32}, { 6, P35}, {14, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P33}, { 7, P32}, {11, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 7, P31}, {11, P30}, {15, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{15, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{15, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{14, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{14, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 6, P31}, { 9, P30}, {14, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P33}, { 6, P32}, { 9, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P34}, { 7, P30}, {11, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{11, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{15, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{15, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{14, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{14, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{ 9, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P34}, { 6, P30}, { 9, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P35}, { 5, P30}, {11, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{11, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{13, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{13, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{12, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{12, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{ 9, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P35}, { 4, P30}, { 9, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P36}, { 5, P32}, {11, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 5, P31}, {11, P33}, {13, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{13, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{13, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{12, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{12, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 4, P31}, { 9, P33}, {12, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P36}, { 4, P32}, { 9, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P37}, { 5, P35}, {13, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 4, {{ 0, P30}, { 3, P39}, { 5, P34}, {13, P38}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 5, P33}, { 8, P30}, {13, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{ 8, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{ 8, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 4, P33}, { 8, P33}, {12, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 4, {{ 0, P39}, { 1, P39}, { 4, P34}, {12, P38}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P37}, { 4, P35}, {12, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 0, P31}, { 3, P38}, { 5, P39}, { 8, P34}, {11, P39}, {13, P39}}}, 
    { 3, {{ 0, P32}, { 5, P38}, {13, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P33}, { 5, P37}, { 8, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P34}, { 5, P36}, { 8, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P35}, { 4, P36}, { 8, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P36}, { 4, P37}, { 8, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P37}, { 4, P38}, {12, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 0, P38}, { 1, P38}, { 4, P39}, { 8, P39}, { 9, P39}, {12, P39}}}  
};

constexpr int pattern_sizes[N_PATTERNS] = {
    10, 10, 10, 10, 
    10, 10, 10, 10, 
    10, 10, 10, 10, 
    10, 10, 10, 10
};


constexpr int feature_to_pattern[N_PATTERN_FEATURES] = {
    0, 0, 0, 0,
    1, 1, 1, 1,
    2, 2, 2, 2,
    3, 3, 3, 3,
    4, 4, 4, 4,
    5, 5, 5, 5,
    6, 6, 6, 6,
    7, 7, 7, 7,
    8, 8, 8, 8,
    9, 9, 9, 9,
    10, 10, 10, 10,
    11, 11, 11, 11,
    12, 12, 12, 12,
    13, 13, 13, 13,
    14, 14, 14, 14,
    15, 15, 15, 15
};


int16_t pattern_arr[2][N_PHASES][N_PATTERNS][MAX_EVALUATE_IDX];
int16_t eval_num_arr[N_PHASES][MAX_STONE_NUM];
int16_t pattern_arr_move_ordering_end[2][N_PATTERNS][MAX_EVALUATE_IDX];


inline int swap_player_idx(int i, int pattern_size) {
    int j, ri = i;
    for (j = 0; j < pattern_size; ++j) {
        if ((i / pow3[j]) % 3 == 0) {
            ri += pow3[j];
        } else if ((i / pow3[j]) % 3 == 1) {
            ri -= pow3[j];
        }
    }
    return ri;
}


void init_pattern_arr_rev(int phase_idx, int pattern_idx, int siz) {
    for (int i = 0; i < (int)pow3[siz]; ++i) {
        int ri = swap_player_idx(i, siz);
        pattern_arr[1][phase_idx][pattern_idx][ri] = pattern_arr[0][phase_idx][pattern_idx][i];
    }
}


inline bool load_eval_file(const char* file, bool show_log) {
    if (show_log) {
        std::cerr << "evaluation file " << file << std::endl;
    }
    bool failed = false;
    std::vector<int16_t> unzipped_params = load_unzip_egev2(file, show_log, &failed);
    if (failed) {
        return false;
    }
    size_t param_idx = 0;
    for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
        for (int pattern_idx = 0; pattern_idx < N_PATTERNS; ++pattern_idx) {
            std::memcpy(pattern_arr[0][phase_idx][pattern_idx], &unzipped_params[param_idx], sizeof(short) * pow3[pattern_sizes[pattern_idx]]);
            param_idx += pow3[pattern_sizes[pattern_idx]];
        }
        std::memcpy(eval_num_arr[phase_idx], &unzipped_params[param_idx], sizeof(short) * MAX_STONE_NUM);
        param_idx += MAX_STONE_NUM;
    }
    if (thread_pool.size() >= 2) {
        std::future<void> tasks[N_PHASES * N_PATTERNS];
        int i = 0;
        for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
            for (int pattern_idx = 0; pattern_idx < N_PATTERNS; ++pattern_idx) {
                bool pushed = false;
                while (!pushed) {
                    tasks[i] = thread_pool.push(&pushed, std::bind(init_pattern_arr_rev, phase_idx, pattern_idx, pattern_sizes[pattern_idx]));
                }
                ++i;
            }
        }
        for (std::future<void> &task: tasks) {
            task.get();
        }
    } else{
        for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
            for (int pattern_idx = 0; pattern_idx < N_PATTERNS; ++pattern_idx) {
                init_pattern_arr_rev(phase_idx, pattern_idx, pattern_sizes[pattern_idx]);
            }
        }
    }
    return true;
}

inline bool load_eval_move_ordering_end_file(const char* file, bool show_log) {
    if (show_log) {
        std::cerr << "evaluation for move ordering end file " << file << std::endl;
    }
    FILE* fp;
    if (!file_open(&fp, file, "rb")) {
        std::cerr << "[ERROR] [FATAL] can't open eval " << file << std::endl;
        return false;
    }
    constexpr int pattern_sizes[N_PATTERNS_MO_END] = {10, 10, 10, 10};
    for (int pattern_idx = 0; pattern_idx < N_PATTERNS_MO_END; ++pattern_idx) {
        if (fread(pattern_arr_move_ordering_end[0][pattern_idx], 2, pow3[pattern_sizes[pattern_idx]], fp) < pow3[pattern_sizes[pattern_idx]]) {
            std::cerr << "[ERROR] [FATAL] evaluation file file for move ordering broken" << std::endl;
            fclose(fp);
            return false;
        }
    }
    for (int pattern_idx = 0; pattern_idx < N_PATTERNS_MO_END; ++pattern_idx) {
        for (int i = 0; i < (int)pow3[pattern_sizes[pattern_idx]]; ++i) {
            int ri = swap_player_idx(i, pattern_sizes[pattern_idx]);
            pattern_arr_move_ordering_end[1][pattern_idx][ri] = pattern_arr_move_ordering_end[0][pattern_idx][i];
        }
    }
    return true;
}


inline bool evaluate_init(const char* file, const char* mo_end_nws_file, bool show_log) {
    bool eval_loaded = load_eval_file(file, show_log);
    if (!eval_loaded) {
        std::cerr << "[ERROR] [FATAL] evaluation file not loaded" << std::endl;
        return false;
    }
    bool eval_move_ordering_end_nws_loaded = load_eval_move_ordering_end_file(mo_end_nws_file, show_log);
    if (!eval_move_ordering_end_nws_loaded) {
        std::cerr << "[ERROR] [FATAL] evaluation file for move ordering end not loaded" << std::endl;
        return false;
    }
    if (show_log) {
        std::cerr << "evaluation function initialized" << std::endl;
    }
    return true;
}


bool evaluate_init(const std::string file, std::string mo_end_nws_file, bool show_log) {
    return evaluate_init(file.c_str(), mo_end_nws_file.c_str(), show_log);
}


bool evaluate_init(bool show_log) {
    return evaluate_init(EXE_DIRECTORY_PATH + "resources/eval.egev2", EXE_DIRECTORY_PATH + "resources/eval_move_ordering_end.egev", show_log);
}


inline int calc_pattern(const int phase_idx, Eval_search *eval) {
    int res = 0;
    for (int i = 0; i < N_PATTERN_FEATURES; ++i) {
        res += pattern_arr[eval->reversed[eval->feature_idx]][phase_idx][feature_to_pattern[i]][eval->features[eval->feature_idx][i]];
    }
    return res;
}


inline int calc_pattern_move_ordering_end(Eval_search *eval) {
    int res = 0;
    for (int i = EVAL_IDX_START_MOVE_ORDERING_END; i < EVAL_IDX_END_MOVE_ORDERING_END; ++i) {
        res += pattern_arr_move_ordering_end[eval->reversed[eval->feature_idx]][feature_to_pattern[i] - EVAL_FEATURE_START_MOVE_ORDERING_END][eval->features[eval->feature_idx][i]];
    }
    return res;
}

inline void calc_eval_features(Board *board, Eval_search *eval);


inline int mid_evaluate(Board *board) {
    Search search(board);
    calc_eval_features(board, &search.eval);
    int phase_idx, num0;
    phase_idx = search.phase();
    num0 = pop_count_ull(search.board.player);
    int res = calc_pattern(phase_idx, &search.eval) + eval_num_arr[phase_idx][num0];
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    res = std::clamp(res, -SCORE_MAX, SCORE_MAX);
    return res;
}


inline int mid_evaluate_diff(Search *search) {
    int phase_idx, num0;
    phase_idx = search->phase();
    num0 = pop_count_ull(search->board.player);
    int res = calc_pattern(phase_idx, &search->eval) + eval_num_arr[phase_idx][num0];
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    res = std::clamp(res, -SCORE_MAX, SCORE_MAX);
    return res;
}


inline int mid_evaluate_move_ordering_end(Search *search) {
    int res = calc_pattern_move_ordering_end(&search->eval);
    res += res >= 0 ? STEP_2_MO_END : -STEP_2_MO_END;
    res /= STEP_MO_END;
    return res;
}

inline uint_fast16_t pick_pattern_idx(const uint_fast8_t b_arr[], const Feature_to_coord *f) {
    uint_fast16_t res = 0;
    for (int i = 0; i < f->n_cells; ++i) {
        res *= 3;
        res += b_arr[HW2_M1 - f->cells[i]];
    }
    return res;
}

inline void calc_eval_features(Board *board, Eval_search *eval) {
    uint_fast8_t b_arr[HW2];
    board->translate_to_arr_player(b_arr);
    for (int i = 0; i < N_PATTERN_FEATURES; ++i) {
        eval->features[0][i] = pick_pattern_idx(b_arr, &feature_to_coord[i]);
    }
    eval->reversed[0] = 0;
    eval->feature_idx = 0;
}

inline void eval_move(Eval_search *eval, const Flip *flip) {
    uint_fast8_t i, cell;
    uint64_t f;
    for (i = 0; i < N_PATTERN_FEATURES; ++i) {
        eval->features[eval->feature_idx + 1][i] = eval->features[eval->feature_idx][i];
    }
    if (eval->reversed[eval->feature_idx]) {
        for (i = 0; i < MAX_CELL_PATTERNS && coord_to_feature[flip->pos].features[i].x; ++i) {
            eval->features[eval->feature_idx + 1][coord_to_feature[flip->pos].features[i].feature] -= coord_to_feature[flip->pos].features[i].x;
        }
        f = flip->flip;
        for (cell = first_bit(&f); f; cell = next_bit(&f)) {
            for (i = 0; i < MAX_CELL_PATTERNS && coord_to_feature[cell].features[i].x; ++i) {
                eval->features[eval->feature_idx + 1][coord_to_feature[cell].features[i].feature] += coord_to_feature[cell].features[i].x;
            }
        }
    } else{
        for (i = 0; i < MAX_CELL_PATTERNS && coord_to_feature[flip->pos].features[i].x; ++i) {
            eval->features[eval->feature_idx + 1][coord_to_feature[flip->pos].features[i].feature] -= 2 * coord_to_feature[flip->pos].features[i].x;
        }
        f = flip->flip;
        for (cell = first_bit(&f); f; cell = next_bit(&f)) {
            for (i = 0; i < MAX_CELL_PATTERNS && coord_to_feature[cell].features[i].x; ++i) {
                eval->features[eval->feature_idx + 1][coord_to_feature[cell].features[i].feature] -= coord_to_feature[cell].features[i].x;
            }
        }
    }
    eval->reversed[eval->feature_idx + 1] = eval->reversed[eval->feature_idx] ^ 1;
    ++eval->feature_idx;
}

inline void eval_undo(Eval_search *eval) {
    --eval->feature_idx;
}


inline void eval_pass(Eval_search *eval) {
    eval->reversed[eval->feature_idx] ^= 1;
}



inline void eval_move_endsearch(Eval_search *eval, const Flip *flip) {
    uint_fast8_t i, cell;
    uint64_t f;
    for (i = EVAL_IDX_START_MOVE_ORDERING_END; i < EVAL_IDX_END_MOVE_ORDERING_END; ++i) {
        eval->features[eval->feature_idx + 1][i] = eval->features[eval->feature_idx][i];
    }
    if (eval->reversed[eval->feature_idx]) {
        for (i = 0; i < MAX_CELL_PATTERNS_MOVE_ORDERING_END && coord_to_feature_move_ordering_end[flip->pos].features[i].x; ++i) {
            eval->features[eval->feature_idx + 1][coord_to_feature_move_ordering_end[flip->pos].features[i].feature + EVAL_IDX_START_MOVE_ORDERING_END] -= coord_to_feature_move_ordering_end[flip->pos].features[i].x;
        }
        f = flip->flip;
        for (cell = first_bit(&f); f; cell = next_bit(&f)) {
            for (i = 0; i < MAX_CELL_PATTERNS_MOVE_ORDERING_END && coord_to_feature_move_ordering_end[cell].features[i].x; ++i) {
                eval->features[eval->feature_idx + 1][coord_to_feature_move_ordering_end[cell].features[i].feature + EVAL_IDX_START_MOVE_ORDERING_END] += coord_to_feature_move_ordering_end[cell].features[i].x;
            }
        }
    } else{
        for (i = 0; i < MAX_CELL_PATTERNS_MOVE_ORDERING_END && coord_to_feature_move_ordering_end[flip->pos].features[i].x; ++i) {
            eval->features[eval->feature_idx + 1][coord_to_feature_move_ordering_end[flip->pos].features[i].feature + EVAL_IDX_START_MOVE_ORDERING_END] -= 2 * coord_to_feature_move_ordering_end[flip->pos].features[i].x;
        }
        f = flip->flip;
        for (cell = first_bit(&f); f; cell = next_bit(&f)) {
            for (i = 0; i < MAX_CELL_PATTERNS_MOVE_ORDERING_END && coord_to_feature_move_ordering_end[cell].features[i].x; ++i) {
                eval->features[eval->feature_idx + 1][coord_to_feature_move_ordering_end[cell].features[i].feature + EVAL_IDX_START_MOVE_ORDERING_END] -= coord_to_feature_move_ordering_end[cell].features[i].x;
            }
        }
    }
    eval->reversed[eval->feature_idx + 1] = eval->reversed[eval->feature_idx] ^ 1;
    ++eval->feature_idx;
}

inline void eval_undo_endsearch(Eval_search *eval) {
    --eval->feature_idx;
}


inline void eval_pass_endsearch(Eval_search *eval) {
    eval->reversed[eval->feature_idx] ^= 1;
}

// ===== FILE: Egaroucid/src/engine/evaluate_generic.hpp =====



#pragma once
#include <iostream>
#include <fstream>
#include <cstring>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "search.hpp"
#include "util.hpp"
#include "evaluate_common.hpp"

constexpr int EVAL_IDX_START_MOVE_ORDERING_END = 32;
constexpr int EVAL_IDX_END_MOVE_ORDERING_END = 48;
constexpr int EVAL_FEATURE_START_MOVE_ORDERING_END = 8;
constexpr int MAX_CELL_PATTERNS_MOVE_ORDERING_END = 6;


constexpr Feature_to_coord feature_to_coord[N_PATTERN_FEATURES] = {
    
    {8, {COORD_A2, COORD_B2, COORD_C2, COORD_D2, COORD_E2, COORD_F2, COORD_G2, COORD_H2, COORD_NO, COORD_NO}},
    {8, {COORD_B1, COORD_B2, COORD_B3, COORD_B4, COORD_B5, COORD_B6, COORD_B7, COORD_B8, COORD_NO, COORD_NO}},
    {8, {COORD_A7, COORD_B7, COORD_C7, COORD_D7, COORD_E7, COORD_F7, COORD_G7, COORD_H7, COORD_NO, COORD_NO}},
    {8, {COORD_G1, COORD_G2, COORD_G3, COORD_G4, COORD_G5, COORD_G6, COORD_G7, COORD_G8, COORD_NO, COORD_NO}},
    
    
    {9, {COORD_B1, COORD_C1, COORD_D2, COORD_E3, COORD_G2, COORD_F4, COORD_G5, COORD_H6, COORD_H7, COORD_NO}},
    {9, {COORD_H2, COORD_H3, COORD_G4, COORD_F5, COORD_G7, COORD_E6, COORD_D7, COORD_C8, COORD_B8, COORD_NO}},
    {9, {COORD_G8, COORD_F8, COORD_E7, COORD_D6, COORD_B7, COORD_C5, COORD_B4, COORD_A3, COORD_A2, COORD_NO}},
    {9, {COORD_A7, COORD_A6, COORD_B5, COORD_C4, COORD_B2, COORD_D3, COORD_E2, COORD_F1, COORD_G1, COORD_NO}},

    
    {8, {COORD_A3, COORD_B3, COORD_C3, COORD_D3, COORD_E3, COORD_F3, COORD_G3, COORD_H3, COORD_NO, COORD_NO}},
    {8, {COORD_C1, COORD_C2, COORD_C3, COORD_C4, COORD_C5, COORD_C6, COORD_C7, COORD_C8, COORD_NO, COORD_NO}},
    {8, {COORD_A6, COORD_B6, COORD_C6, COORD_D6, COORD_E6, COORD_F6, COORD_G6, COORD_H6, COORD_NO, COORD_NO}},
    {8, {COORD_F1, COORD_F2, COORD_F3, COORD_F4, COORD_F5, COORD_F6, COORD_F7, COORD_F8, COORD_NO, COORD_NO}},

    
    {9, {COORD_A1, COORD_B1, COORD_C2, COORD_D3, COORD_E4, COORD_F5, COORD_G6, COORD_H7, COORD_H8, COORD_NO}},
    {9, {COORD_H1, COORD_H2, COORD_G3, COORD_F4, COORD_E5, COORD_D6, COORD_C7, COORD_B8, COORD_A8, COORD_NO}},
    {9, {COORD_H8, COORD_G8, COORD_F7, COORD_E6, COORD_D5, COORD_C4, COORD_B3, COORD_A2, COORD_A1, COORD_NO}},
    {9, {COORD_A8, COORD_A7, COORD_B6, COORD_C5, COORD_D4, COORD_E3, COORD_F2, COORD_G1, COORD_H1, COORD_NO}},

    
    {8, {COORD_A4, COORD_B4, COORD_C4, COORD_D4, COORD_E4, COORD_F4, COORD_G4, COORD_H4, COORD_NO, COORD_NO}},
    {8, {COORD_D1, COORD_D2, COORD_D3, COORD_D4, COORD_D5, COORD_D6, COORD_D7, COORD_D8, COORD_NO, COORD_NO}},
    {8, {COORD_A5, COORD_B5, COORD_C5, COORD_D5, COORD_E5, COORD_F5, COORD_G5, COORD_H5, COORD_NO, COORD_NO}},
    {8, {COORD_E1, COORD_E2, COORD_E3, COORD_E4, COORD_E5, COORD_E6, COORD_E7, COORD_E8, COORD_NO, COORD_NO}},

    
    {9, {COORD_A1, COORD_B1, COORD_C1, COORD_A2, COORD_B2, COORD_C2, COORD_A3, COORD_B3, COORD_C3, COORD_NO}},
    {9, {COORD_H1, COORD_G1, COORD_F1, COORD_H2, COORD_G2, COORD_F2, COORD_H3, COORD_G3, COORD_F3, COORD_NO}},
    {9, {COORD_A8, COORD_B8, COORD_C8, COORD_A7, COORD_B7, COORD_C7, COORD_A6, COORD_B6, COORD_C6, COORD_NO}},
    {9, {COORD_H8, COORD_G8, COORD_F8, COORD_H7, COORD_G7, COORD_F7, COORD_H6, COORD_G6, COORD_F6, COORD_NO}},

    
    {7, {COORD_B2, COORD_D1, COORD_E2, COORD_F3, COORD_G4, COORD_H5, COORD_G7, COORD_NO, COORD_NO, COORD_NO}},
    {7, {COORD_G2, COORD_H4, COORD_G5, COORD_F6, COORD_E7, COORD_D8, COORD_B7, COORD_NO, COORD_NO, COORD_NO}},
    {7, {COORD_G7, COORD_E8, COORD_D7, COORD_C6, COORD_B5, COORD_A4, COORD_B2, COORD_NO, COORD_NO, COORD_NO}},
    {7, {COORD_B7, COORD_A5, COORD_B4, COORD_C3, COORD_D2, COORD_E1, COORD_G2, COORD_NO, COORD_NO, COORD_NO}},

    
    {10, {COORD_A1, COORD_B2, COORD_C3, COORD_D4, COORD_E5, COORD_F6, COORD_G7, COORD_H8, COORD_A2, COORD_B1}},
    {10, {COORD_H8, COORD_G7, COORD_F6, COORD_E5, COORD_D4, COORD_C3, COORD_B2, COORD_A1, COORD_H7, COORD_G8}},
    {10, {COORD_H1, COORD_G2, COORD_F3, COORD_E4, COORD_D5, COORD_C6, COORD_B7, COORD_A8, COORD_H2, COORD_G1}},
    {10, {COORD_A8, COORD_B7, COORD_C6, COORD_D5, COORD_E4, COORD_F3, COORD_G2, COORD_H1, COORD_A7, COORD_B8}},
 
    
    {10, {COORD_B2, COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_G1, COORD_H1, COORD_G2}},
    {10, {COORD_B2, COORD_A1, COORD_A2, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A7, COORD_A8, COORD_B7}},
    {10, {COORD_B7, COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_G8, COORD_H8, COORD_G7}},
    {10, {COORD_G2, COORD_H1, COORD_H2, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H7, COORD_H8, COORD_G7}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_A2, COORD_B2, COORD_C2, COORD_A3, COORD_B3, COORD_A4}},
    {10, {COORD_H1, COORD_G1, COORD_F1, COORD_E1, COORD_H2, COORD_G2, COORD_F2, COORD_H3, COORD_G3, COORD_H4}},
    {10, {COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_A7, COORD_B7, COORD_C7, COORD_A6, COORD_B6, COORD_A5}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_E8, COORD_H7, COORD_G7, COORD_F7, COORD_H6, COORD_G6, COORD_H5}},

    
    {10, {COORD_A1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_H1, COORD_C2, COORD_D2, COORD_E2, COORD_F2}},
    {10, {COORD_A1, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A8, COORD_B3, COORD_B4, COORD_B5, COORD_B6}},
    {10, {COORD_A8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_H8, COORD_C7, COORD_D7, COORD_E7, COORD_F7}},
    {10, {COORD_H1, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H8, COORD_G3, COORD_G4, COORD_G5, COORD_G6}},

    
    {10, {COORD_A1, COORD_B2, COORD_C3, COORD_D4, COORD_B1, COORD_C2, COORD_D3, COORD_A2, COORD_B3, COORD_C4}},
    {10, {COORD_H1, COORD_G2, COORD_F3, COORD_E4, COORD_G1, COORD_F2, COORD_E3, COORD_H2, COORD_G3, COORD_F4}},
    {10, {COORD_A8, COORD_B7, COORD_C6, COORD_D5, COORD_B8, COORD_C7, COORD_D6, COORD_A7, COORD_B6, COORD_C5}},
    {10, {COORD_H8, COORD_G7, COORD_F6, COORD_E5, COORD_G8, COORD_F7, COORD_E6, COORD_H7, COORD_G6, COORD_F5}},

    
    {10, {COORD_C2, COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_G1, COORD_H1, COORD_F2}},
    {10, {COORD_B3, COORD_A1, COORD_A2, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A7, COORD_A8, COORD_B6}},
    {10, {COORD_C7, COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_G8, COORD_H8, COORD_F7}},
    {10, {COORD_G3, COORD_H1, COORD_H2, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H7, COORD_H8, COORD_G6}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_A2, COORD_B2, COORD_A3, COORD_A4, COORD_A5}},
    {10, {COORD_H1, COORD_G1, COORD_F1, COORD_E1, COORD_D1, COORD_H2, COORD_G2, COORD_H3, COORD_H4, COORD_H5}},
    {10, {COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_A7, COORD_B7, COORD_A6, COORD_A5, COORD_A4}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_E8, COORD_D8, COORD_H7, COORD_G7, COORD_H6, COORD_H5, COORD_H4}},

    
    {10, {COORD_A1, COORD_B1, COORD_A2, COORD_B2, COORD_C2, COORD_D2, COORD_B3, COORD_C3, COORD_B4, COORD_D4}},
    {10, {COORD_H1, COORD_G1, COORD_H2, COORD_G2, COORD_F2, COORD_E2, COORD_G3, COORD_F3, COORD_G4, COORD_E4}},
    {10, {COORD_A8, COORD_B8, COORD_A7, COORD_B7, COORD_C7, COORD_D7, COORD_B6, COORD_C6, COORD_B5, COORD_D5}},
    {10, {COORD_H8, COORD_G8, COORD_H7, COORD_G7, COORD_F7, COORD_E7, COORD_G6, COORD_F6, COORD_G5, COORD_E5}},

    
    {10, {COORD_C6, COORD_D6, COORD_D7, COORD_D8, COORD_C8, COORD_F8, COORD_E8, COORD_E7, COORD_E6, COORD_F6}},
    {10, {COORD_C3, COORD_C4, COORD_B4, COORD_A4, COORD_A3, COORD_A6, COORD_A5, COORD_B5, COORD_C5, COORD_C6}},
    {10, {COORD_F3, COORD_E3, COORD_E2, COORD_E1, COORD_F1, COORD_C1, COORD_D1, COORD_D2, COORD_D3, COORD_C3}},
    {10, {COORD_F6, COORD_F5, COORD_G5, COORD_H5, COORD_H6, COORD_H3, COORD_H4, COORD_G4, COORD_F4, COORD_F3}}
};

constexpr Coord_to_feature coord_to_feature[HW2] = {
    {15, {{12, P30}, {14, P38}, {23, P38}, {28, P32}, {29, P39}, {34, P31}, {35, P31}, {39, P39}, {42, P34}, {43, P34}, {47, P39}, {50, P31}, {51, P31}, {55, P39}, {59, P39}}}, 
    {11, {{ 3, P30}, { 6, P38}, {14, P37}, {23, P37}, {29, P30}, {34, P32}, {39, P38}, {47, P35}, {50, P32}, {55, P38}, {59, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 6, P37}, {11, P30}, {23, P36}, {34, P33}, {39, P37}, {42, P35}, {50, P33}, {55, P37}, {60, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{19, P30}, {26, P35}, {34, P34}, {39, P36}, {42, P36}, {50, P34}, {54, P35}, {55, P36}, {60, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{17, P30}, {25, P31}, {34, P35}, {38, P36}, {42, P37}, {50, P35}, {54, P36}, {55, P35}, {60, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 5, P31}, { 9, P30}, {22, P36}, {34, P36}, {38, P37}, {42, P38}, {50, P36}, {54, P37}, {60, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 1, P30}, { 5, P30}, {13, P31}, {22, P37}, {31, P30}, {34, P37}, {38, P38}, {46, P35}, {50, P37}, {54, P38}, {58, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {15, {{13, P30}, {15, P38}, {22, P38}, {30, P32}, {31, P39}, {33, P31}, {34, P38}, {38, P39}, {41, P34}, {42, P39}, {46, P39}, {49, P31}, {50, P38}, {54, P39}, {58, P39}}}, 
    {11, {{ 2, P30}, { 4, P30}, {12, P31}, {23, P35}, {29, P31}, {35, P32}, {39, P35}, {47, P32}, {51, P32}, {55, P34}, {59, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {14, {{ 2, P31}, { 3, P31}, { 5, P34}, {23, P34}, {24, P30}, {26, P36}, {28, P33}, {29, P38}, {34, P30}, {35, P30}, {39, P34}, {47, P38}, {55, P33}, {59, P36}, { 0, PNO}}}, 
    { 9, {{ 2, P32}, {11, P31}, {14, P36}, {23, P33}, {39, P33}, {42, P30}, {47, P34}, {50, P30}, {59, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 2, P33}, { 6, P36}, {19, P31}, {25, P32}, {42, P31}, {59, P34}, {60, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 2, P34}, { 5, P32}, {17, P31}, {26, P34}, {42, P32}, {58, P34}, {60, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 2, P35}, { 9, P31}, {13, P32}, {22, P33}, {38, P33}, {42, P33}, {46, P34}, {50, P39}, {58, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {14, {{ 1, P31}, { 2, P36}, { 6, P34}, {22, P34}, {25, P30}, {27, P36}, {30, P33}, {31, P38}, {33, P30}, {34, P39}, {38, P34}, {46, P38}, {54, P33}, {58, P36}, { 0, PNO}}}, 
    {11, {{ 2, P37}, { 7, P38}, {15, P37}, {22, P35}, {31, P31}, {33, P32}, {38, P35}, {46, P32}, {49, P32}, {54, P34}, {58, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 4, P31}, {10, P30}, {23, P32}, {35, P33}, {39, P32}, {43, P35}, {51, P33}, {55, P32}, {63, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 3, P32}, {10, P31}, {12, P32}, {23, P31}, {39, P31}, {43, P30}, {47, P31}, {51, P30}, {59, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{10, P32}, {11, P32}, {23, P30}, {25, P33}, {28, P34}, {29, P37}, {47, P37}, {59, P32}, {60, P30}, {63, P39}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 5, P33}, {10, P33}, {14, P35}, {19, P32}, {47, P33}, {60, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 6, P35}, {10, P34}, {13, P33}, {17, P32}, {46, P33}, {60, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 9, P32}, {10, P35}, {22, P30}, {26, P33}, {30, P34}, {31, P37}, {46, P37}, {58, P32}, {60, P39}, {61, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 1, P32}, {10, P36}, {15, P36}, {22, P31}, {38, P31}, {41, P30}, {46, P31}, {49, P30}, {58, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 7, P37}, {10, P37}, {22, P32}, {33, P33}, {38, P32}, {41, P35}, {49, P33}, {54, P32}, {61, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{18, P30}, {24, P31}, {35, P34}, {39, P30}, {43, P36}, {51, P34}, {53, P30}, {55, P31}, {63, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 3, P33}, { 4, P32}, {18, P31}, {25, P34}, {43, P31}, {59, P31}, {63, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 5, P35}, {11, P33}, {12, P33}, {18, P32}, {47, P30}, {63, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{13, P34}, {18, P33}, {19, P33}, {28, P35}, {29, P36}, {47, P36}, {59, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{14, P34}, {17, P33}, {18, P34}, {30, P35}, {31, P36}, {46, P36}, {58, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 6, P33}, { 9, P33}, {15, P35}, {18, P35}, {46, P30}, {61, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 1, P33}, { 7, P36}, {18, P36}, {26, P32}, {41, P31}, {58, P31}, {61, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{18, P37}, {27, P35}, {33, P34}, {38, P30}, {41, P36}, {49, P34}, {52, P30}, {54, P31}, {61, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{16, P30}, {25, P35}, {35, P35}, {37, P30}, {43, P37}, {51, P35}, {53, P31}, {55, P30}, {63, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 3, P34}, { 5, P36}, {16, P31}, {24, P32}, {43, P32}, {57, P31}, {63, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 4, P33}, {11, P34}, {13, P35}, {16, P32}, {45, P30}, {63, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{12, P34}, {16, P33}, {19, P34}, {30, P36}, {31, P35}, {45, P36}, {57, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{15, P34}, {16, P34}, {17, P34}, {28, P36}, {29, P35}, {44, P36}, {56, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 7, P35}, { 9, P34}, {14, P33}, {16, P35}, {44, P30}, {61, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 1, P34}, { 6, P32}, {16, P36}, {27, P34}, {41, P32}, {56, P31}, {61, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{16, P37}, {26, P31}, {33, P35}, {36, P30}, {41, P37}, {49, P35}, {52, P31}, {54, P30}, {61, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 5, P37}, { 8, P30}, {21, P32}, {35, P36}, {37, P32}, {43, P38}, {51, P36}, {53, P32}, {63, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 3, P35}, { 8, P31}, {13, P36}, {21, P31}, {37, P31}, {43, P33}, {45, P31}, {51, P39}, {57, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 8, P32}, {11, P35}, {21, P30}, {24, P33}, {30, P37}, {31, P34}, {45, P37}, {57, P32}, {62, P39}, {63, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 4, P35}, { 8, P33}, {15, P33}, {19, P35}, {45, P33}, {62, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 7, P33}, { 8, P34}, {12, P35}, {17, P35}, {44, P33}, {62, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 8, P35}, { 9, P35}, {20, P30}, {27, P33}, {28, P37}, {29, P34}, {44, P37}, {56, P32}, {61, P39}, {62, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 1, P35}, { 8, P36}, {14, P32}, {20, P31}, {36, P31}, {41, P33}, {44, P31}, {49, P39}, {56, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 6, P31}, { 8, P37}, {20, P32}, {33, P36}, {36, P32}, {41, P38}, {49, P36}, {52, P32}, {61, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 0, P30}, { 5, P38}, {13, P37}, {21, P35}, {30, P31}, {35, P37}, {37, P35}, {45, P32}, {51, P37}, {53, P34}, {57, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {14, {{ 0, P31}, { 3, P36}, { 4, P34}, {21, P34}, {25, P36}, {27, P30}, {30, P38}, {31, P33}, {32, P30}, {35, P39}, {37, P34}, {45, P38}, {53, P33}, {57, P36}, { 0, PNO}}}, 
    { 9, {{ 0, P32}, {11, P36}, {15, P32}, {21, P33}, {37, P33}, {40, P30}, {45, P34}, {48, P30}, {57, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 0, P33}, { 7, P32}, {19, P36}, {24, P34}, {40, P31}, {57, P34}, {62, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 0, P34}, { 4, P36}, {17, P36}, {27, P32}, {40, P32}, {56, P34}, {62, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 0, P35}, { 9, P36}, {12, P36}, {20, P33}, {36, P33}, {40, P33}, {44, P34}, {48, P39}, {56, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {14, {{ 0, P36}, { 1, P36}, { 7, P34}, {20, P34}, {24, P36}, {26, P30}, {28, P38}, {29, P33}, {32, P39}, {33, P39}, {36, P34}, {44, P38}, {52, P33}, {56, P36}, { 0, PNO}}}, 
    {11, {{ 0, P37}, { 6, P30}, {14, P31}, {20, P35}, {28, P31}, {33, P37}, {36, P35}, {44, P32}, {49, P37}, {52, P34}, {56, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {15, {{13, P38}, {15, P30}, {21, P38}, {30, P39}, {31, P32}, {32, P31}, {35, P38}, {37, P39}, {40, P34}, {43, P39}, {45, P39}, {48, P31}, {51, P38}, {53, P39}, {57, P39}}}, 
    {11, {{ 3, P37}, { 7, P30}, {15, P31}, {21, P37}, {30, P30}, {32, P32}, {37, P38}, {45, P35}, {48, P32}, {53, P38}, {57, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 7, P31}, {11, P37}, {21, P36}, {32, P33}, {37, P37}, {40, P35}, {48, P33}, {53, P37}, {62, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{19, P37}, {27, P31}, {32, P34}, {37, P36}, {40, P36}, {48, P34}, {52, P35}, {53, P36}, {62, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{17, P37}, {24, P35}, {32, P35}, {36, P36}, {40, P37}, {48, P35}, {52, P36}, {53, P35}, {62, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 4, P37}, { 9, P37}, {20, P36}, {32, P36}, {36, P37}, {40, P38}, {48, P36}, {52, P37}, {62, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 1, P37}, { 4, P38}, {12, P37}, {20, P37}, {28, P30}, {32, P37}, {36, P38}, {44, P35}, {48, P37}, {52, P38}, {56, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {15, {{12, P38}, {14, P30}, {20, P38}, {28, P39}, {29, P32}, {32, P38}, {33, P38}, {36, P39}, {40, P39}, {41, P39}, {44, P39}, {48, P38}, {49, P38}, {52, P39}, {56, P39}}}  
};

constexpr Coord_to_feature coord_to_feature_move_ordering_end[HW2] = {
    { 6, {{ 2, P31}, { 3, P31}, { 7, P39}, {10, P34}, {11, P34}, {15, P39}}}, 
    { 3, {{ 2, P32}, { 7, P38}, {15, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P33}, { 7, P37}, {10, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P34}, { 7, P36}, {10, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P35}, { 6, P36}, {10, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P36}, { 6, P37}, {10, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 2, P37}, { 6, P38}, {14, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 1, P31}, { 2, P38}, { 6, P39}, { 9, P34}, {10, P39}, {14, P39}}}, 
    { 3, {{ 3, P32}, { 7, P35}, {15, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 4, {{ 2, P30}, { 3, P30}, { 7, P34}, {15, P38}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 7, P33}, {10, P30}, {15, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{10, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{10, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 6, P33}, {10, P33}, {14, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 4, {{ 1, P30}, { 2, P39}, { 6, P34}, {14, P38}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P32}, { 6, P35}, {14, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P33}, { 7, P32}, {11, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 7, P31}, {11, P30}, {15, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{15, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{15, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{14, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{14, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 6, P31}, { 9, P30}, {14, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P33}, { 6, P32}, { 9, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P34}, { 7, P30}, {11, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{11, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{15, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{15, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{14, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{14, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{ 9, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P34}, { 6, P30}, { 9, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P35}, { 5, P30}, {11, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{11, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{13, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{13, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{12, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{12, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{ 9, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P35}, { 4, P30}, { 9, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P36}, { 5, P32}, {11, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 5, P31}, {11, P33}, {13, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{13, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{13, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{12, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{12, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 4, P31}, { 9, P33}, {12, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P36}, { 4, P32}, { 9, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 3, P37}, { 5, P35}, {13, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 4, {{ 0, P30}, { 3, P39}, { 5, P34}, {13, P38}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 5, P33}, { 8, P30}, {13, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{ 8, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 1, {{ 8, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 4, P33}, { 8, P33}, {12, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 4, {{ 0, P39}, { 1, P39}, { 4, P34}, {12, P38}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 1, P37}, { 4, P35}, {12, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 0, P31}, { 3, P38}, { 5, P39}, { 8, P34}, {11, P39}, {13, P39}}}, 
    { 3, {{ 0, P32}, { 5, P38}, {13, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P33}, { 5, P37}, { 8, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P34}, { 5, P36}, { 8, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P35}, { 4, P36}, { 8, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P36}, { 4, P37}, { 8, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 3, {{ 0, P37}, { 4, P38}, {12, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 0, P38}, { 1, P38}, { 4, P39}, { 8, P39}, { 9, P39}, {12, P39}}}  
};

constexpr int pattern_sizes[N_PATTERNS] = {
    8, 9, 8, 9,
    8, 9, 7, 10, 
    10, 10, 10, 10, 
    10, 10, 10, 10
};


constexpr int feature_to_pattern[N_PATTERN_FEATURES] = {
    0, 0, 0, 0,
    1, 1, 1, 1,
    2, 2, 2, 2,
    3, 3, 3, 3,
    4, 4, 4, 4,
    5, 5, 5, 5,
    6, 6, 6, 6,
    7, 7, 7, 7,
    8, 8, 8, 8,
    9, 9, 9, 9,
    10, 10, 10, 10,
    11, 11, 11, 11,
    12, 12, 12, 12,
    13, 13, 13, 13,
    14, 14, 14, 14,
    15, 15, 15, 15
};


int16_t pattern_arr[2][N_PHASES][N_PATTERNS][MAX_EVALUATE_IDX];
int16_t eval_num_arr[N_PHASES][MAX_STONE_NUM];
int16_t pattern_arr_move_ordering_end[2][N_PATTERNS][MAX_EVALUATE_IDX];


inline int swap_player_idx(int i, int pattern_size) {
    int j, ri = i;
    for (j = 0; j < pattern_size; ++j) {
        if ((i / pow3[j]) % 3 == 0) {
            ri += pow3[j];
        } else if ((i / pow3[j]) % 3 == 1) {
            ri -= pow3[j];
        }
    }
    return ri;
}


void init_pattern_arr_rev(int phase_idx, int pattern_idx, int siz) {
    for (int i = 0; i < (int)pow3[siz]; ++i) {
        int ri = swap_player_idx(i, siz);
        pattern_arr[1][phase_idx][pattern_idx][ri] = pattern_arr[0][phase_idx][pattern_idx][i];
    }
}


inline bool load_eval_file(const char* file, bool show_log) {
    if (show_log) {
        std::cerr << "evaluation file " << file << std::endl;
    }
    bool failed = false;
    std::vector<int16_t> unzipped_params = load_unzip_egev2(file, show_log, &failed);
    if (failed) {
        return false;
    }
    size_t param_idx = 0;
    for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
        for (int pattern_idx = 0; pattern_idx < N_PATTERNS; ++pattern_idx) {
            std::memcpy(pattern_arr[0][phase_idx][pattern_idx], &unzipped_params[param_idx], sizeof(short) * pow3[pattern_sizes[pattern_idx]]);
            param_idx += pow3[pattern_sizes[pattern_idx]];
        }
        std::memcpy(eval_num_arr[phase_idx], &unzipped_params[param_idx], sizeof(short) * MAX_STONE_NUM);
        param_idx += MAX_STONE_NUM;
    }
    if (thread_pool.size() >= 2) {
        std::future<void> tasks[N_PHASES * N_PATTERNS];
        int i = 0;
        for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
            for (int pattern_idx = 0; pattern_idx < N_PATTERNS; ++pattern_idx) {
                bool pushed = false;
                while (!pushed) {
                    tasks[i] = thread_pool.push(&pushed, std::bind(init_pattern_arr_rev, phase_idx, pattern_idx, pattern_sizes[pattern_idx]));
                }
                ++i;
            }
        }
        for (std::future<void> &task: tasks) {
            task.get();
        }
    } else{
        for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
            for (int pattern_idx = 0; pattern_idx < N_PATTERNS; ++pattern_idx) {
                init_pattern_arr_rev(phase_idx, pattern_idx, pattern_sizes[pattern_idx]);
            }
        }
    }
    return true;
}

inline bool load_eval_move_ordering_end_file(const char* file, bool show_log) {
    if (show_log) {
        std::cerr << "evaluation for move ordering end file " << file << std::endl;
    }
    FILE* fp;
    if (!file_open(&fp, file, "rb")) {
        std::cerr << "[ERROR] [FATAL] can't open eval " << file << std::endl;
        return false;
    }
    constexpr int pattern_sizes[N_PATTERNS_MO_END] = {10, 10, 10, 10};
    for (int pattern_idx = 0; pattern_idx < N_PATTERNS_MO_END; ++pattern_idx) {
        if (fread(pattern_arr_move_ordering_end[0][pattern_idx], 2, pow3[pattern_sizes[pattern_idx]], fp) < pow3[pattern_sizes[pattern_idx]]) {
            std::cerr << "[ERROR] [FATAL] evaluation file file for move ordering broken" << std::endl;
            fclose(fp);
            return false;
        }
    }
    for (int pattern_idx = 0; pattern_idx < N_PATTERNS_MO_END; ++pattern_idx) {
        for (int i = 0; i < (int)pow3[pattern_sizes[pattern_idx]]; ++i) {
            int ri = swap_player_idx(i, pattern_sizes[pattern_idx]);
            pattern_arr_move_ordering_end[1][pattern_idx][ri] = pattern_arr_move_ordering_end[0][pattern_idx][i];
        }
    }
    return true;
}


inline bool evaluate_init(const char* file, const char* mo_end_nws_file, bool show_log) {
    bool eval_loaded = load_eval_file(file, show_log);
    if (!eval_loaded) {
        std::cerr << "[ERROR] [FATAL] evaluation file not loaded" << std::endl;
        return false;
    }
    bool eval_move_ordering_end_nws_loaded = load_eval_move_ordering_end_file(mo_end_nws_file, show_log);
    if (!eval_move_ordering_end_nws_loaded) {
        std::cerr << "[ERROR] [FATAL] evaluation file for move ordering end not loaded" << std::endl;
        return false;
    }
    if (show_log) {
        std::cerr << "evaluation function initialized" << std::endl;
    }
    return true;
}


bool evaluate_init(const std::string file, std::string mo_end_nws_file, bool show_log) {
    return evaluate_init(file.c_str(), mo_end_nws_file.c_str(), show_log);
}


bool evaluate_init(bool show_log) {
    return evaluate_init(EXE_DIRECTORY_PATH + "resources/eval.egev2", EXE_DIRECTORY_PATH + "resources/eval_move_ordering_end.egev", show_log);
}


inline int calc_pattern(const int phase_idx, Eval_search *eval) {
    int res = 0;
    for (int i = 0; i < N_PATTERN_FEATURES; ++i) {
        res += pattern_arr[eval->reversed[eval->feature_idx]][phase_idx][feature_to_pattern[i]][eval->features[eval->feature_idx][i]];
    }
    return res;
}


inline int calc_pattern_move_ordering_end(Eval_search *eval) {
    int res = 0;
    for (int i = EVAL_IDX_START_MOVE_ORDERING_END; i < EVAL_IDX_END_MOVE_ORDERING_END; ++i) {
        res += pattern_arr_move_ordering_end[eval->reversed[eval->feature_idx]][feature_to_pattern[i] - EVAL_FEATURE_START_MOVE_ORDERING_END][eval->features[eval->feature_idx][i]];
    }
    return res;
}

inline void calc_eval_features(Board *board, Eval_search *eval);


inline int mid_evaluate(Board *board) {
    Search search(board);
    calc_eval_features(board, &search.eval);
    int phase_idx, num0;
    phase_idx = search.phase();
    num0 = pop_count_ull(search.board.player);
    int res = calc_pattern(phase_idx, &search.eval) + eval_num_arr[phase_idx][num0];
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    res = std::clamp(res, -SCORE_MAX, SCORE_MAX);
    return res;
}


inline int mid_evaluate_diff(Search *search) {
    int phase_idx, num0;
    phase_idx = search->phase();
    num0 = pop_count_ull(search->board.player);
    int res = calc_pattern(phase_idx, &search->eval) + eval_num_arr[phase_idx][num0];
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    res = std::clamp(res, -SCORE_MAX, SCORE_MAX);
    return res;
}


inline int mid_evaluate_move_ordering_end(Search *search) {
    int res = calc_pattern_move_ordering_end(&search->eval);
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    return res;
}

inline uint_fast16_t pick_pattern_idx(const uint_fast8_t b_arr[], const Feature_to_coord *f) {
    uint_fast16_t res = 0;
    for (int i = 0; i < f->n_cells; ++i) {
        res *= 3;
        res += b_arr[HW2_M1 - f->cells[i]];
    }
    return res;
}

inline void calc_eval_features(Board *board, Eval_search *eval) {
    uint_fast8_t b_arr[HW2];
    board->translate_to_arr_player(b_arr);
    for (int i = 0; i < N_PATTERN_FEATURES; ++i) {
        eval->features[0][i] = pick_pattern_idx(b_arr, &feature_to_coord[i]);
    }
    eval->reversed[0] = 0;
    eval->feature_idx = 0;
}

inline void eval_move(Eval_search *eval, const Flip *flip) {
    uint_fast8_t i, cell;
    uint64_t f;
    for (i = 0; i < N_PATTERN_FEATURES; ++i) {
        eval->features[eval->feature_idx + 1][i] = eval->features[eval->feature_idx][i];
    }
    if (eval->reversed[eval->feature_idx]) {
        for (i = 0; i < MAX_CELL_PATTERNS && coord_to_feature[flip->pos].features[i].x; ++i) {
            eval->features[eval->feature_idx + 1][coord_to_feature[flip->pos].features[i].feature] -= coord_to_feature[flip->pos].features[i].x;
        }
        f = flip->flip;
        for (cell = first_bit(&f); f; cell = next_bit(&f)) {
            for (i = 0; i < MAX_CELL_PATTERNS && coord_to_feature[cell].features[i].x; ++i) {
                eval->features[eval->feature_idx + 1][coord_to_feature[cell].features[i].feature] += coord_to_feature[cell].features[i].x;
            }
        }
    } else{
        for (i = 0; i < MAX_CELL_PATTERNS && coord_to_feature[flip->pos].features[i].x; ++i) {
            eval->features[eval->feature_idx + 1][coord_to_feature[flip->pos].features[i].feature] -= 2 * coord_to_feature[flip->pos].features[i].x;
        }
        f = flip->flip;
        for (cell = first_bit(&f); f; cell = next_bit(&f)) {
            for (i = 0; i < MAX_CELL_PATTERNS && coord_to_feature[cell].features[i].x; ++i) {
                eval->features[eval->feature_idx + 1][coord_to_feature[cell].features[i].feature] -= coord_to_feature[cell].features[i].x;
            }
        }
    }
    eval->reversed[eval->feature_idx + 1] = eval->reversed[eval->feature_idx] ^ 1;
    ++eval->feature_idx;
}

inline void eval_undo(Eval_search *eval) {
    --eval->feature_idx;
}


inline void eval_pass(Eval_search *eval) {
    eval->reversed[eval->feature_idx] ^= 1;
}



inline void eval_move_endsearch(Eval_search *eval, const Flip *flip) {
    uint_fast8_t i, cell;
    uint64_t f;
    for (i = EVAL_IDX_START_MOVE_ORDERING_END; i < EVAL_IDX_END_MOVE_ORDERING_END; ++i) {
        eval->features[eval->feature_idx + 1][i] = eval->features[eval->feature_idx][i];
    }
    if (eval->reversed[eval->feature_idx]) {
        for (i = 0; i < MAX_CELL_PATTERNS_MOVE_ORDERING_END && coord_to_feature_move_ordering_end[flip->pos].features[i].x; ++i) {
            eval->features[eval->feature_idx + 1][coord_to_feature_move_ordering_end[flip->pos].features[i].feature + EVAL_IDX_START_MOVE_ORDERING_END] -= coord_to_feature_move_ordering_end[flip->pos].features[i].x;
        }
        f = flip->flip;
        for (cell = first_bit(&f); f; cell = next_bit(&f)) {
            for (i = 0; i < MAX_CELL_PATTERNS_MOVE_ORDERING_END && coord_to_feature_move_ordering_end[cell].features[i].x; ++i) {
                eval->features[eval->feature_idx + 1][coord_to_feature_move_ordering_end[cell].features[i].feature + EVAL_IDX_START_MOVE_ORDERING_END] += coord_to_feature_move_ordering_end[cell].features[i].x;
            }
        }
    } else{
        for (i = 0; i < MAX_CELL_PATTERNS_MOVE_ORDERING_END && coord_to_feature_move_ordering_end[flip->pos].features[i].x; ++i) {
            eval->features[eval->feature_idx + 1][coord_to_feature_move_ordering_end[flip->pos].features[i].feature + EVAL_IDX_START_MOVE_ORDERING_END] -= 2 * coord_to_feature_move_ordering_end[flip->pos].features[i].x;
        }
        f = flip->flip;
        for (cell = first_bit(&f); f; cell = next_bit(&f)) {
            for (i = 0; i < MAX_CELL_PATTERNS_MOVE_ORDERING_END && coord_to_feature_move_ordering_end[cell].features[i].x; ++i) {
                eval->features[eval->feature_idx + 1][coord_to_feature_move_ordering_end[cell].features[i].feature + EVAL_IDX_START_MOVE_ORDERING_END] -= coord_to_feature_move_ordering_end[cell].features[i].x;
            }
        }
    }
    eval->reversed[eval->feature_idx + 1] = eval->reversed[eval->feature_idx] ^ 1;
    ++eval->feature_idx;
}

inline void eval_undo_endsearch(Eval_search *eval) {
    --eval->feature_idx;
}


inline void eval_pass_endsearch(Eval_search *eval) {
    eval->reversed[eval->feature_idx] ^= 1;
}

// ===== FILE: Egaroucid/src/engine/evaluate.hpp =====



#pragma once
#include "setting.hpp"
#if USE_SIMD_EVALUATION
#include "evaluate_simd.hpp"
#else
#include "evaluate_generic.hpp"
#endif

// ===== FILE: Egaroucid/src/engine/evaluate_simd_7_4.hpp =====



#pragma once
#include <iostream>
#include <fstream>
#ifdef _MSC_VER
    #include <intrin.h>
#else
    #include <x86intrin.h>
#endif
#include <cstring>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "search.hpp"
#include "util.hpp"
#include "evaluate_common.hpp"


#define CEIL_N_SYMMETRY_PATTERNS 64         
#define N_PATTERN_PARAMS_RAW 573966
#define N_PATTERN_PARAMS (N_PATTERN_PARAMS_RAW + 1) 
#define FEATURE1_START_IDX 39366            
#define SIMD_EVAL_MAX_VALUE 4092            
#define N_SIMD_EVAL_FEATURES_SIMPLE 2
#define N_SIMD_EVAL_FEATURES_COMP 2
#define N_SIMD_EVAL_FEATURE_CELLS 16
#define N_SIMD_EVAL_FEATURE_GROUP 4


#define MAX_N_CELLS_GROUP0 9
#define MAX_N_CELLS_GROUP1 10
#define MAX_N_CELLS_GROUP2 10
#define MAX_N_CELLS_GROUP3 10



#define N_PATTERN_PARAMS_MO_END (236196 + 1) 
#define SIMD_EVAL_MAX_VALUE_MO_END 16380
#define SHIFT_EVAL_MO_END 101574 

constexpr Feature_to_coord feature_to_coord[CEIL_N_SYMMETRY_PATTERNS] = {
    
    {8, {COORD_A2, COORD_B2, COORD_C2, COORD_D2, COORD_E2, COORD_F2, COORD_G2, COORD_H2, COORD_NO, COORD_NO}},
    {8, {COORD_B1, COORD_B2, COORD_B3, COORD_B4, COORD_B5, COORD_B6, COORD_B7, COORD_B8, COORD_NO, COORD_NO}},
    {8, {COORD_A7, COORD_B7, COORD_C7, COORD_D7, COORD_E7, COORD_F7, COORD_G7, COORD_H7, COORD_NO, COORD_NO}},
    {8, {COORD_G1, COORD_G2, COORD_G3, COORD_G4, COORD_G5, COORD_G6, COORD_G7, COORD_G8, COORD_NO, COORD_NO}},

    
    {8, {COORD_A3, COORD_B3, COORD_C3, COORD_D3, COORD_E3, COORD_F3, COORD_G3, COORD_H3, COORD_NO, COORD_NO}},
    {8, {COORD_C1, COORD_C2, COORD_C3, COORD_C4, COORD_C5, COORD_C6, COORD_C7, COORD_C8, COORD_NO, COORD_NO}},
    {8, {COORD_A6, COORD_B6, COORD_C6, COORD_D6, COORD_E6, COORD_F6, COORD_G6, COORD_H6, COORD_NO, COORD_NO}},
    {8, {COORD_F1, COORD_F2, COORD_F3, COORD_F4, COORD_F5, COORD_F6, COORD_F7, COORD_F8, COORD_NO, COORD_NO}},

    
    {8, {COORD_A4, COORD_B4, COORD_C4, COORD_D4, COORD_E4, COORD_F4, COORD_G4, COORD_H4, COORD_NO, COORD_NO}},
    {8, {COORD_D1, COORD_D2, COORD_D3, COORD_D4, COORD_D5, COORD_D6, COORD_D7, COORD_D8, COORD_NO, COORD_NO}},
    {8, {COORD_A5, COORD_B5, COORD_C5, COORD_D5, COORD_E5, COORD_F5, COORD_G5, COORD_H5, COORD_NO, COORD_NO}},
    {8, {COORD_E1, COORD_E2, COORD_E3, COORD_E4, COORD_E5, COORD_E6, COORD_E7, COORD_E8, COORD_NO, COORD_NO}},

    
    {9, {COORD_A1, COORD_B1, COORD_C1, COORD_A2, COORD_B2, COORD_C2, COORD_A3, COORD_B3, COORD_C3, COORD_NO}},
    {9, {COORD_H1, COORD_G1, COORD_F1, COORD_H2, COORD_G2, COORD_F2, COORD_H3, COORD_G3, COORD_F3, COORD_NO}},
    {9, {COORD_A8, COORD_B8, COORD_C8, COORD_A7, COORD_B7, COORD_C7, COORD_A6, COORD_B6, COORD_C6, COORD_NO}},
    {9, {COORD_H8, COORD_G8, COORD_F8, COORD_H7, COORD_G7, COORD_F7, COORD_H6, COORD_G6, COORD_F6, COORD_NO}},

    
    {5, {COORD_D1, COORD_E2, COORD_F3, COORD_G4, COORD_H5, COORD_NO, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},
    {5, {COORD_E1, COORD_D2, COORD_C3, COORD_B4, COORD_A5, COORD_NO, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},
    {5, {COORD_A4, COORD_B5, COORD_C6, COORD_D7, COORD_E8, COORD_NO, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},
    {5, {COORD_H4, COORD_G5, COORD_F6, COORD_E7, COORD_D8, COORD_NO, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},

    
    {6, {COORD_C1, COORD_D2, COORD_E3, COORD_F4, COORD_G5, COORD_H6, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},
    {6, {COORD_F1, COORD_E2, COORD_D3, COORD_C4, COORD_B5, COORD_A6, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},
    {6, {COORD_A3, COORD_B4, COORD_C5, COORD_D6, COORD_E7, COORD_F8, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},
    {6, {COORD_H3, COORD_G4, COORD_F5, COORD_E6, COORD_D7, COORD_C8, COORD_NO, COORD_NO, COORD_NO, COORD_NO}},

    
    {7, {COORD_B1, COORD_C2, COORD_D3, COORD_E4, COORD_F5, COORD_G6, COORD_H7, COORD_NO, COORD_NO, COORD_NO}},
    {7, {COORD_G1, COORD_F2, COORD_E3, COORD_D4, COORD_C5, COORD_B6, COORD_A7, COORD_NO, COORD_NO, COORD_NO}},
    {7, {COORD_A2, COORD_B3, COORD_C4, COORD_D5, COORD_E6, COORD_F7, COORD_G8, COORD_NO, COORD_NO, COORD_NO}},
    {7, {COORD_H2, COORD_G3, COORD_F4, COORD_E5, COORD_D6, COORD_C7, COORD_B8, COORD_NO, COORD_NO, COORD_NO}},

    
    {10, {COORD_A1, COORD_B2, COORD_C3, COORD_D4, COORD_E5, COORD_F6, COORD_G7, COORD_H8, COORD_A2, COORD_B1}},
    {10, {COORD_H8, COORD_G7, COORD_F6, COORD_E5, COORD_D4, COORD_C3, COORD_B2, COORD_A1, COORD_H7, COORD_G8}},
    {10, {COORD_H1, COORD_G2, COORD_F3, COORD_E4, COORD_D5, COORD_C6, COORD_B7, COORD_A8, COORD_H2, COORD_G1}},
    {10, {COORD_A8, COORD_B7, COORD_C6, COORD_D5, COORD_E4, COORD_F3, COORD_G2, COORD_H1, COORD_A7, COORD_B8}},
 
    
    {10, {COORD_B2, COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_G1, COORD_H1, COORD_G2}},
    {10, {COORD_B2, COORD_A1, COORD_A2, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A7, COORD_A8, COORD_B7}},
    {10, {COORD_B7, COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_G8, COORD_H8, COORD_G7}},
    {10, {COORD_G2, COORD_H1, COORD_H2, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H7, COORD_H8, COORD_G7}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_A2, COORD_B2, COORD_C2, COORD_A3, COORD_B3, COORD_A4}},
    {10, {COORD_H1, COORD_G1, COORD_F1, COORD_E1, COORD_H2, COORD_G2, COORD_F2, COORD_H3, COORD_G3, COORD_H4}},
    {10, {COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_A7, COORD_B7, COORD_C7, COORD_A6, COORD_B6, COORD_A5}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_E8, COORD_H7, COORD_G7, COORD_F7, COORD_H6, COORD_G6, COORD_H5}},

    
    {10, {COORD_A1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_H1, COORD_C2, COORD_D2, COORD_E2, COORD_F2}},
    {10, {COORD_A1, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A8, COORD_B3, COORD_B4, COORD_B5, COORD_B6}},
    {10, {COORD_A8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_H8, COORD_C7, COORD_D7, COORD_E7, COORD_F7}},
    {10, {COORD_H1, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H8, COORD_G3, COORD_G4, COORD_G5, COORD_G6}},

    
    {10, {COORD_A1, COORD_B2, COORD_C3, COORD_D4, COORD_B1, COORD_C2, COORD_D3, COORD_A2, COORD_B3, COORD_C4}},
    {10, {COORD_H1, COORD_G2, COORD_F3, COORD_E4, COORD_G1, COORD_F2, COORD_E3, COORD_H2, COORD_G3, COORD_F4}},
    {10, {COORD_A8, COORD_B7, COORD_C6, COORD_D5, COORD_B8, COORD_C7, COORD_D6, COORD_A7, COORD_B6, COORD_C5}},
    {10, {COORD_H8, COORD_G7, COORD_F6, COORD_E5, COORD_G8, COORD_F7, COORD_E6, COORD_H7, COORD_G6, COORD_F5}},

    
    {10, {COORD_C2, COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_G1, COORD_H1, COORD_F2}},
    {10, {COORD_B3, COORD_A1, COORD_A2, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A7, COORD_A8, COORD_B6}},
    {10, {COORD_C7, COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_G8, COORD_H8, COORD_F7}},
    {10, {COORD_G3, COORD_H1, COORD_H2, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H7, COORD_H8, COORD_G6}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_A2, COORD_B2, COORD_A3, COORD_A4, COORD_A5}},
    {10, {COORD_H1, COORD_G1, COORD_F1, COORD_E1, COORD_D1, COORD_H2, COORD_G2, COORD_H3, COORD_H4, COORD_H5}},
    {10, {COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_A7, COORD_B7, COORD_A6, COORD_A5, COORD_A4}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_E8, COORD_D8, COORD_H7, COORD_G7, COORD_H6, COORD_H5, COORD_H4}},

    
    {10, {COORD_A1, COORD_B1, COORD_A2, COORD_B2, COORD_C2, COORD_D2, COORD_B3, COORD_C3, COORD_B4, COORD_D4}},
    {10, {COORD_H1, COORD_G1, COORD_H2, COORD_G2, COORD_F2, COORD_E2, COORD_G3, COORD_F3, COORD_G4, COORD_E4}},
    {10, {COORD_A8, COORD_B8, COORD_A7, COORD_B7, COORD_C7, COORD_D7, COORD_B6, COORD_C6, COORD_B5, COORD_D5}},
    {10, {COORD_H8, COORD_G8, COORD_H7, COORD_G7, COORD_F7, COORD_E7, COORD_G6, COORD_F6, COORD_G5, COORD_E5}},

    
    {10, {COORD_C6, COORD_D6, COORD_D7, COORD_D8, COORD_C8, COORD_F8, COORD_E8, COORD_E7, COORD_E6, COORD_F6}},
    {10, {COORD_C3, COORD_C4, COORD_B4, COORD_A4, COORD_A3, COORD_A6, COORD_A5, COORD_B5, COORD_C5, COORD_C6}},
    {10, {COORD_F3, COORD_E3, COORD_E2, COORD_E1, COORD_F1, COORD_C1, COORD_D1, COORD_D2, COORD_D3, COORD_C3}},
    {10, {COORD_F6, COORD_F5, COORD_G5, COORD_H5, COORD_H6, COORD_H3, COORD_H4, COORD_G4, COORD_F4, COORD_F3}}
};

constexpr Coord_to_feature coord_to_feature[HW2] = {
    {13, {{15, P38}, {28, P32}, {29, P39}, {34, P31}, {35, P31}, {39, P39}, {42, P34}, {43, P34}, {47, P39}, {50, P31}, {51, P31}, {55, P39}, {59, P39}}}, 
    {10, {{ 3, P30}, {15, P37}, {26, P30}, {29, P30}, {34, P32}, {39, P38}, {47, P35}, {50, P32}, {55, P38}, {59, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 7, P30}, {15, P36}, {22, P30}, {34, P33}, {39, P37}, {42, P35}, {50, P33}, {55, P37}, {60, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{11, P30}, {18, P30}, {34, P34}, {39, P36}, {42, P36}, {50, P34}, {54, P35}, {55, P36}, {60, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 9, P30}, {19, P30}, {34, P35}, {38, P36}, {42, P37}, {50, P35}, {54, P36}, {55, P35}, {60, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 5, P30}, {14, P36}, {23, P30}, {34, P36}, {38, P37}, {42, P38}, {50, P36}, {54, P37}, {60, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 1, P30}, {14, P37}, {27, P30}, {31, P30}, {34, P37}, {38, P38}, {46, P35}, {50, P37}, {54, P38}, {58, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {13, {{14, P38}, {30, P32}, {31, P39}, {33, P31}, {34, P38}, {38, P39}, {41, P34}, {42, P39}, {46, P39}, {49, P31}, {50, P38}, {54, P39}, {58, P39}}}, 
    {10, {{ 2, P30}, {15, P35}, {24, P30}, {29, P31}, {35, P32}, {39, P35}, {47, P32}, {51, P32}, {55, P34}, {59, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 2, P31}, { 3, P31}, {15, P34}, {28, P33}, {29, P38}, {34, P30}, {35, P30}, {39, P34}, {47, P38}, {55, P33}, {59, P36}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 2, P32}, { 7, P31}, {15, P33}, {26, P31}, {39, P33}, {42, P30}, {47, P34}, {50, P30}, {59, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 2, P33}, {11, P31}, {19, P31}, {22, P31}, {42, P31}, {59, P34}, {60, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 2, P34}, { 9, P31}, {18, P31}, {23, P31}, {42, P32}, {58, P34}, {60, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 2, P35}, { 5, P31}, {14, P33}, {27, P31}, {38, P33}, {42, P33}, {46, P34}, {50, P39}, {58, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 1, P31}, { 2, P36}, {14, P34}, {30, P33}, {31, P38}, {33, P30}, {34, P39}, {38, P34}, {46, P38}, {54, P33}, {58, P36}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 2, P37}, {14, P35}, {25, P30}, {31, P31}, {33, P32}, {38, P35}, {46, P32}, {49, P32}, {54, P34}, {58, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 6, P30}, {15, P32}, {20, P30}, {35, P33}, {39, P32}, {43, P35}, {51, P33}, {55, P32}, {63, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 3, P32}, { 6, P31}, {15, P31}, {24, P31}, {39, P31}, {43, P30}, {47, P31}, {51, P30}, {59, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 6, P32}, { 7, P32}, {15, P30}, {19, P32}, {28, P34}, {29, P37}, {47, P37}, {59, P32}, {60, P30}, {63, P39}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 6, P33}, {11, P32}, {23, P32}, {26, P32}, {47, P33}, {60, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 6, P34}, { 9, P32}, {22, P32}, {27, P32}, {46, P33}, {60, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 5, P32}, { 6, P35}, {14, P30}, {18, P32}, {30, P34}, {31, P37}, {46, P37}, {58, P32}, {60, P39}, {61, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 1, P32}, { 6, P36}, {14, P31}, {25, P31}, {38, P31}, {41, P30}, {46, P31}, {49, P30}, {58, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 6, P37}, {14, P32}, {21, P30}, {33, P33}, {38, P32}, {41, P35}, {49, P33}, {54, P32}, {61, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{10, P30}, {16, P30}, {35, P34}, {39, P30}, {43, P36}, {51, P34}, {53, P30}, {55, P31}, {63, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 3, P33}, {10, P31}, {19, P33}, {20, P31}, {43, P31}, {59, P31}, {63, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 7, P33}, {10, P32}, {23, P33}, {24, P32}, {47, P30}, {63, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{10, P33}, {11, P33}, {27, P33}, {28, P35}, {29, P36}, {47, P36}, {59, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 9, P33}, {10, P34}, {26, P33}, {30, P35}, {31, P36}, {46, P36}, {58, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 5, P33}, {10, P35}, {22, P33}, {25, P32}, {46, P30}, {61, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 1, P33}, {10, P36}, {18, P33}, {21, P31}, {41, P31}, {58, P31}, {61, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{10, P37}, {17, P30}, {33, P34}, {38, P30}, {41, P36}, {49, P34}, {52, P30}, {54, P31}, {61, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 8, P30}, {19, P34}, {35, P35}, {37, P30}, {43, P37}, {51, P35}, {53, P31}, {55, P30}, {63, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 3, P34}, { 8, P31}, {16, P31}, {23, P34}, {43, P32}, {57, P31}, {63, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 7, P34}, { 8, P32}, {20, P32}, {27, P34}, {45, P30}, {63, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 8, P33}, {11, P34}, {24, P33}, {30, P36}, {31, P35}, {45, P36}, {57, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 8, P34}, { 9, P34}, {25, P33}, {28, P36}, {29, P35}, {44, P36}, {56, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 5, P34}, { 8, P35}, {21, P32}, {26, P34}, {44, P30}, {61, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 1, P34}, { 8, P36}, {17, P31}, {22, P34}, {41, P32}, {56, P31}, {61, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 8, P37}, {18, P34}, {33, P35}, {36, P30}, {41, P37}, {49, P35}, {52, P31}, {54, P30}, {61, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 4, P30}, {13, P32}, {23, P35}, {35, P36}, {37, P32}, {43, P38}, {51, P36}, {53, P32}, {63, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 3, P35}, { 4, P31}, {13, P31}, {27, P35}, {37, P31}, {43, P33}, {45, P31}, {51, P39}, {57, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 4, P32}, { 7, P35}, {13, P30}, {16, P32}, {30, P37}, {31, P34}, {45, P37}, {57, P32}, {62, P39}, {63, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 4, P33}, {11, P35}, {20, P33}, {25, P34}, {45, P33}, {62, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 4, P34}, { 9, P35}, {21, P33}, {24, P34}, {44, P33}, {62, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 4, P35}, { 5, P35}, {12, P30}, {17, P32}, {28, P37}, {29, P34}, {44, P37}, {56, P32}, {61, P39}, {62, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 1, P35}, { 4, P36}, {12, P31}, {26, P35}, {36, P31}, {41, P33}, {44, P31}, {49, P39}, {56, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 4, P37}, {12, P32}, {22, P35}, {33, P36}, {36, P32}, {41, P38}, {49, P36}, {52, P32}, {61, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 0, P30}, {13, P35}, {27, P36}, {30, P31}, {35, P37}, {37, P35}, {45, P32}, {51, P37}, {53, P34}, {57, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 0, P31}, { 3, P36}, {13, P34}, {30, P38}, {31, P33}, {32, P30}, {35, P39}, {37, P34}, {45, P38}, {53, P33}, {57, P36}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 0, P32}, { 7, P36}, {13, P33}, {25, P35}, {37, P33}, {40, P30}, {45, P34}, {48, P30}, {57, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 0, P33}, {11, P36}, {16, P33}, {21, P34}, {40, P31}, {57, P34}, {62, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 0, P34}, { 9, P36}, {17, P33}, {20, P34}, {40, P32}, {56, P34}, {62, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 0, P35}, { 5, P36}, {12, P33}, {24, P35}, {36, P33}, {40, P33}, {44, P34}, {48, P39}, {56, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 0, P36}, { 1, P36}, {12, P34}, {28, P38}, {29, P33}, {32, P39}, {33, P39}, {36, P34}, {44, P38}, {52, P33}, {56, P36}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 0, P37}, {12, P35}, {26, P36}, {28, P31}, {33, P37}, {36, P35}, {44, P32}, {49, P37}, {52, P34}, {56, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {13, {{13, P38}, {30, P39}, {31, P32}, {32, P31}, {35, P38}, {37, P39}, {40, P34}, {43, P39}, {45, P39}, {48, P31}, {51, P38}, {53, P39}, {57, P39}}}, 
    {10, {{ 3, P37}, {13, P37}, {25, P36}, {30, P30}, {32, P32}, {37, P38}, {45, P35}, {48, P32}, {53, P38}, {57, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 7, P37}, {13, P36}, {21, P35}, {32, P33}, {37, P37}, {40, P35}, {48, P33}, {53, P37}, {62, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{11, P37}, {17, P34}, {32, P34}, {37, P36}, {40, P36}, {48, P34}, {52, P35}, {53, P36}, {62, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 9, P37}, {16, P34}, {32, P35}, {36, P36}, {40, P37}, {48, P35}, {52, P36}, {53, P35}, {62, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 5, P37}, {12, P36}, {20, P35}, {32, P36}, {36, P37}, {40, P38}, {48, P36}, {52, P37}, {62, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 1, P37}, {12, P37}, {24, P36}, {28, P30}, {32, P37}, {36, P38}, {44, P35}, {48, P37}, {52, P38}, {56, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {13, {{12, P38}, {28, P39}, {29, P32}, {32, P38}, {33, P38}, {36, P39}, {40, P39}, {41, P39}, {44, P39}, {48, P38}, {49, P38}, {52, P39}, {56, P39}}}  
};


__m256i eval_lower_mask;
__m256i feature_to_coord_simd_mul[N_SIMD_EVAL_FEATURES][MAX_PATTERN_CELLS - 1];
__m256i feature_to_coord_simd_cell[N_SIMD_EVAL_FEATURES][MAX_PATTERN_CELLS][2];
__m256i coord_to_feature_simd[HW2][N_SIMD_EVAL_FEATURES];
__m256i eval_move_unflipped_16bit[N_16BIT][N_SIMD_EVAL_FEATURE_GROUP][N_SIMD_EVAL_FEATURES];
__m256i eval_simd_offsets_simple[N_SIMD_EVAL_FEATURES_SIMPLE]; 
__m256i eval_simd_offsets_comp[N_SIMD_EVAL_FEATURES_COMP * 2]; 

__m256i eval_surround_mask;
__m256i eval_surround_shift1879;



int16_t pattern_arr[N_PHASES][N_PATTERN_PARAMS];
int16_t eval_num_arr[N_PHASES][MAX_STONE_NUM];
int16_t eval_sur0_sur1_arr[N_PHASES][MAX_SURROUND][MAX_SURROUND];

int16_t pattern_move_ordering_end_arr[N_PATTERN_PARAMS_MO_END];

inline bool load_eval_file(const char* file, bool show_log) {
    if (show_log)
        std::cerr << "evaluation file " << file << std::endl;
    bool failed = false;
    std::vector<int16_t> unzipped_params = load_unzip_egev2(file, show_log, &failed);
    if (failed) {
        return false;
    }
    size_t param_idx = 0;
    for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
        pattern_arr[phase_idx][0] = 0; 
        std::memcpy(pattern_arr[phase_idx] + 1, &unzipped_params[param_idx], sizeof(short) * N_PATTERN_PARAMS_RAW);
        param_idx += N_PATTERN_PARAMS_RAW;
        std::memcpy(eval_num_arr[phase_idx], &unzipped_params[param_idx], sizeof(short) * MAX_STONE_NUM);
        param_idx += MAX_STONE_NUM;
        std::memcpy(eval_sur0_sur1_arr[phase_idx], &unzipped_params[param_idx], sizeof(short) * MAX_SURROUND * MAX_SURROUND);
        param_idx += MAX_SURROUND * MAX_SURROUND;
    }
    
    for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
        for (int i = 1; i < N_PATTERN_PARAMS; ++i) {
            if (pattern_arr[phase_idx][i] < -SIMD_EVAL_MAX_VALUE) {
                std::cerr << "[ERROR] evaluation value too low. you can ignore this error. phase " << phase_idx << " index " << i << " found " << pattern_arr[phase_idx][i] << std::endl;
                pattern_arr[phase_idx][i] = -SIMD_EVAL_MAX_VALUE;
            }
            if (pattern_arr[phase_idx][i] > SIMD_EVAL_MAX_VALUE) {
                std::cerr << "[ERROR] evaluation value too high. you can ignore this error. phase " << phase_idx << " index " << i << " found " << pattern_arr[phase_idx][i] << std::endl;
                pattern_arr[phase_idx][i] = SIMD_EVAL_MAX_VALUE;
            }
            pattern_arr[phase_idx][i] += SIMD_EVAL_MAX_VALUE;
        }
    }
    return true;
}

inline bool load_eval_move_ordering_end_file(const char* file, bool show_log) {
    if (show_log)
        std::cerr << "evaluation for move ordering end file " << file << std::endl;
    FILE* fp;
    if (!file_open(&fp, file, "rb")) {
        std::cerr << "[ERROR] [FATAL] can't open eval " << file << std::endl;
        return false;
    }
    pattern_move_ordering_end_arr[0] = 0; 
    if (fread(pattern_move_ordering_end_arr + 1, 2, N_PATTERN_PARAMS_MO_END - 1, fp) < N_PATTERN_PARAMS_MO_END - 1) {
        std::cerr << "[ERROR] [FATAL] evaluation file for move ordering end broken" << std::endl;
        fclose(fp);
        return false;
    }
    
    for (int i = 1; i < N_PATTERN_PARAMS_MO_END; ++i) {
        if (pattern_move_ordering_end_arr[i] < -SIMD_EVAL_MAX_VALUE_MO_END) {
            std::cerr << "[ERROR] evaluation value too low. you can ignore this error. index " << i << " found " << pattern_move_ordering_end_arr[i] << std::endl;
            pattern_move_ordering_end_arr[i] = -SIMD_EVAL_MAX_VALUE_MO_END;
        }
        if (pattern_move_ordering_end_arr[i] > SIMD_EVAL_MAX_VALUE_MO_END) {
            std::cerr << "[ERROR] evaluation value too high. you can ignore this error. index " << i << " found " << pattern_move_ordering_end_arr[i] << std::endl;
            pattern_move_ordering_end_arr[i] = SIMD_EVAL_MAX_VALUE_MO_END;
        }
        pattern_move_ordering_end_arr[i] += SIMD_EVAL_MAX_VALUE_MO_END;
    }
    return true;
}

inline void pre_calculate_eval_constant() {
    constexpr int pattern_starts[N_PATTERNS] = {
        1, 6562, 13123, 19684, 
        1, 244, 973, 3160, 
        
        101575, 160624, 219673, 278722, 
        337771, 396820, 455869, 514918 
    };
    { 
        int16_t f2c[16];
        for (int i = 0; i < N_SIMD_EVAL_FEATURES; ++i) {
            for (int j = 0; j < MAX_PATTERN_CELLS - 1; ++j) {
                for (int k = 0; k < 16; ++k) {
                    f2c[k] = (j < feature_to_coord[i * 16 + k].n_cells - 1) ? 3 : 1;
                }
                feature_to_coord_simd_mul[i][j] = _mm256_set_epi16(
                    f2c[0], f2c[1], f2c[2], f2c[3], 
                    f2c[4], f2c[5], f2c[6], f2c[7], 
                    f2c[8], f2c[9], f2c[10], f2c[11], 
                    f2c[12], f2c[13], f2c[14], f2c[15]
                );
            }
        }
        int32_t f2c32[8];
        for (int i = 0; i < N_SIMD_EVAL_FEATURES; ++i) {
            for (int j = 0; j < MAX_PATTERN_CELLS; ++j) {
                for (int k = 0; k < 8; ++k)
                    f2c32[k] = feature_to_coord[i * 16 + k * 2 + 1].cells[j];
                feature_to_coord_simd_cell[i][j][0] = _mm256_set_epi32(
                    f2c32[0], f2c32[1], f2c32[2], f2c32[3], 
                    f2c32[4], f2c32[5], f2c32[6], f2c32[7]
                );
                for (int k = 0; k < 8; ++k)
                    f2c32[k] = feature_to_coord[i * 16 + k * 2].cells[j];
                feature_to_coord_simd_cell[i][j][1] = _mm256_set_epi32(
                    f2c32[0], f2c32[1], f2c32[2], f2c32[3], 
                    f2c32[4], f2c32[5], f2c32[6], f2c32[7]
                );
            }
        }
        eval_simd_offsets_simple[0] = _mm256_set_epi16(
            (int16_t)pattern_starts[0], (int16_t)pattern_starts[0], (int16_t)pattern_starts[0], (int16_t)pattern_starts[0], 
            (int16_t)pattern_starts[1], (int16_t)pattern_starts[1], (int16_t)pattern_starts[1], (int16_t)pattern_starts[1], 
            (int16_t)pattern_starts[2], (int16_t)pattern_starts[2], (int16_t)pattern_starts[2], (int16_t)pattern_starts[2], 
            (int16_t)pattern_starts[3], (int16_t)pattern_starts[3], (int16_t)pattern_starts[3], (int16_t)pattern_starts[3]
        );
        eval_simd_offsets_simple[1] = _mm256_set_epi16(
            (int16_t)pattern_starts[4], (int16_t)pattern_starts[4], (int16_t)pattern_starts[4], (int16_t)pattern_starts[4], 
            (int16_t)pattern_starts[5], (int16_t)pattern_starts[5], (int16_t)pattern_starts[5], (int16_t)pattern_starts[5], 
            (int16_t)pattern_starts[6], (int16_t)pattern_starts[6], (int16_t)pattern_starts[6], (int16_t)pattern_starts[6], 
            (int16_t)pattern_starts[7], (int16_t)pattern_starts[7], (int16_t)pattern_starts[7], (int16_t)pattern_starts[7]
        );
    }
    { 
        uint16_t c2f[CEIL_N_SYMMETRY_PATTERNS];
        for (int cell = 0; cell < HW2; ++cell) { 
            for (int i = 0; i < CEIL_N_SYMMETRY_PATTERNS; ++i)
                c2f[i] = 0;
            for (int i = 0; i < coord_to_feature[cell].n_features; ++i)
                c2f[coord_to_feature[cell].features[i].feature] = coord_to_feature[cell].features[i].x;
            for (int i = 0; i < N_SIMD_EVAL_FEATURES; ++i) {
                int idx = i * 16;
                coord_to_feature_simd[cell][i] = _mm256_set_epi16(
                    c2f[idx], c2f[idx + 1], c2f[idx + 2], c2f[idx + 3], 
                    c2f[idx + 4], c2f[idx + 5], c2f[idx + 6], c2f[idx + 7], 
                    c2f[idx + 8], c2f[idx + 9], c2f[idx + 10], c2f[idx + 11], 
                    c2f[idx + 12], c2f[idx + 13], c2f[idx + 14], c2f[idx + 15]
                );
            }
        }
        for (int bits = 0; bits < N_16BIT; ++bits) { 
            for (int group = 0; group < N_SIMD_EVAL_FEATURE_GROUP; ++group) { 
                for (int i = 0; i < CEIL_N_SYMMETRY_PATTERNS; ++i)
                    c2f[i] = 0;
                for (int cell = 0; cell < N_SIMD_EVAL_FEATURE_CELLS; ++cell) {
                    if (1 & (bits >> cell)) {
                        int global_cell = group * N_SIMD_EVAL_FEATURE_CELLS + cell;
                        for (int i = 0; i < coord_to_feature[global_cell].n_features; ++i) {
                            c2f[coord_to_feature[global_cell].features[i].feature] += coord_to_feature[global_cell].features[i].x;
                        }
                    }
                }
                for (int simd_feature_idx = 0; simd_feature_idx < N_SIMD_EVAL_FEATURES; ++simd_feature_idx) {
                    int idx = simd_feature_idx * 16;
                    eval_move_unflipped_16bit[bits][group][simd_feature_idx] = _mm256_set_epi16(
                        c2f[idx], c2f[idx + 1], c2f[idx + 2], c2f[idx + 3], 
                        c2f[idx + 4], c2f[idx + 5], c2f[idx + 6], c2f[idx + 7], 
                        c2f[idx + 8], c2f[idx + 9], c2f[idx + 10], c2f[idx + 11], 
                        c2f[idx + 12], c2f[idx + 13], c2f[idx + 14], c2f[idx + 15]
                    );
                }
            }
        }
        for (int i = 0; i < N_SIMD_EVAL_FEATURES_COMP; ++i) {
            int i4 = i * 4;
            eval_simd_offsets_comp[i * 2] = _mm256_set_epi32(
                pattern_starts[10 + i4], pattern_starts[10 + i4], pattern_starts[10 + i4], pattern_starts[10 + i4], 
                pattern_starts[11 + i4], pattern_starts[11 + i4], pattern_starts[11 + i4], pattern_starts[11 + i4]
            );
            eval_simd_offsets_comp[i * 2 + 1] = _mm256_set_epi32(
                pattern_starts[8 + i4], pattern_starts[8 + i4], pattern_starts[8 + i4], pattern_starts[8 + i4], 
                pattern_starts[9 + i4], pattern_starts[9 + i4], pattern_starts[9 + i4], pattern_starts[9 + i4]
            );
        }
        eval_lower_mask = _mm256_set1_epi32(0x0000FFFF);
    }
    { 
        eval_surround_mask = _mm256_set_epi64x(0x7E7E7E7E7E7E7E7EULL, 0x00FFFFFFFFFFFF00ULL, 0x007E7E7E7E7E7E00ULL, 0x007E7E7E7E7E7E00ULL);
        eval_surround_shift1879 = _mm256_set_epi64x(1, HW, HW_M1, HW_P1);
    }
}


inline bool evaluate_init(const char* file, const char* mo_end_nws_file, bool show_log) {
    bool eval_loaded = load_eval_file(file, show_log);
    if (!eval_loaded) {
        std::cerr << "[ERROR] [FATAL] evaluation file not loaded" << std::endl;
        return false;
    }
    bool eval_move_ordering_end_nws_loaded = load_eval_move_ordering_end_file(mo_end_nws_file, show_log);
    if (!eval_move_ordering_end_nws_loaded) {
        std::cerr << "[ERROR] [FATAL] evaluation file for move ordering end not loaded" << std::endl;
        return false;
    }
    pre_calculate_eval_constant();
    if (show_log)
        std::cerr << "evaluation function initialized" << std::endl;
    return true;
}


bool evaluate_init(const std::string file, std::string mo_end_nws_file, bool show_log) {
    return evaluate_init(file.c_str(), mo_end_nws_file.c_str(), show_log);
}


bool evaluate_init(bool show_log) {
    return evaluate_init(EXE_DIRECTORY_PATH + "resources/eval.egev2", EXE_DIRECTORY_PATH + "resources/eval_move_ordering_end.egev", show_log);
}

inline int calc_surround(const uint64_t discs, const uint64_t empties) {
    __m256i pl = _mm256_set1_epi64x(discs);
    pl = _mm256_and_si256(pl, eval_surround_mask);
    pl = _mm256_or_si256(_mm256_sllv_epi64(pl, eval_surround_shift1879), _mm256_srlv_epi64(pl, eval_surround_shift1879));
    __m128i res = _mm_or_si128(_mm256_castsi256_si128(pl), _mm256_extracti128_si256(pl, 1));
    res = _mm_or_si128(res, _mm_shuffle_epi32(res, 0x4e));
    return pop_count_ull(_mm_cvtsi128_si64(res) & empties);
}
#define CALC_SURROUND_FUNCTION


inline __m256i calc_idx8_comp(const __m128i feature, const int i) {
    return _mm256_add_epi32(_mm256_cvtepu16_epi32(feature), eval_simd_offsets_comp[i]);
}

inline __m256i gather_eval(const int *start_addr, const __m256i idx8) {
    return _mm256_i32gather_epi32(start_addr, idx8, 2); 
    
}

inline int calc_pattern(const int phase_idx, Eval_features *features) {
    const int *start_addr = (int*)pattern_arr[phase_idx];
    const int *start_addr2 = (int*)&pattern_arr[phase_idx][FEATURE1_START_IDX];
    __m256i res256 =                  gather_eval(start_addr, _mm256_cvtepu16_epi32(features->f128[0]));    
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, _mm256_cvtepu16_epi32(features->f128[1])));   
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr2, _mm256_cvtepu16_epi32(features->f128[2])));  
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr2, _mm256_cvtepu16_epi32(features->f128[3])));  
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[4], 0)));       
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[5], 1)));       
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[6], 2)));       
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[7], 3)));       
    res256 = _mm256_and_si256(res256, eval_lower_mask);
    __m128i res128 = _mm_add_epi32(_mm256_castsi256_si128(res256), _mm256_extracti128_si256(res256, 1));
    res128 = _mm_hadd_epi32(res128, res128);
    return _mm_cvtsi128_si32(res128) + _mm_extract_epi32(res128, 1) - SIMD_EVAL_MAX_VALUE * N_SYMMETRY_PATTERNS;
}

inline int calc_pattern_move_ordering_end(Eval_features *features) {
    const int *start_addr = (int*)(pattern_move_ordering_end_arr - SHIFT_EVAL_MO_END);
    __m256i res256 =                  gather_eval(start_addr, calc_idx8_comp(features->f128[4], 0));        
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[5], 1)));       
    res256 = _mm256_and_si256(res256, eval_lower_mask);
    __m128i res128 = _mm_add_epi32(_mm256_castsi256_si128(res256), _mm256_extracti128_si256(res256, 1));
    res128 = _mm_hadd_epi32(res128, res128);
    return _mm_cvtsi128_si32(res128) + _mm_extract_epi32(res128, 1) - SIMD_EVAL_MAX_VALUE_MO_END * N_SYMMETRY_PATTERNS_MO_END;
}

inline void calc_eval_features(Board *board, Eval_search *eval);


inline int mid_evaluate(Board *board) {
    Search search(board);
    calc_eval_features(&(search.board), &(search.eval));
    int phase_idx, sur0, sur1, num0;
    uint64_t empties;
    phase_idx = search.phase();
    empties = ~(search.board.player | search.board.opponent);
    sur0 = calc_surround(search.board.player, empties);
    sur1 = calc_surround(search.board.opponent, empties);
    num0 = pop_count_ull(search.board.player);
    int res = calc_pattern(phase_idx, &search.eval.features[search.eval.feature_idx]) + 
        eval_num_arr[phase_idx][num0] + 
        eval_sur0_sur1_arr[phase_idx][sur0][sur1];
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    res = std::clamp(res, -SCORE_MAX, SCORE_MAX);
    return res;
}


inline int mid_evaluate_diff(Search *search) {
    int phase_idx, sur0, sur1, num0;
    uint64_t empties;
    phase_idx = search->phase();
    empties = ~(search->board.player | search->board.opponent);
    sur0 = calc_surround(search->board.player, empties);
    sur1 = calc_surround(search->board.opponent, empties);
    num0 = pop_count_ull(search->board.player);
    int res = calc_pattern(phase_idx, &search->eval.features[search->eval.feature_idx]) + 
        eval_num_arr[phase_idx][num0] + 
        eval_sur0_sur1_arr[phase_idx][sur0][sur1];
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    res = std::clamp(res, -SCORE_MAX, SCORE_MAX);
    return res;
}


inline int mid_evaluate_move_ordering_end(Search *search) {
    int res = calc_pattern_move_ordering_end(&search->eval.features[search->eval.feature_idx]);
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    return res;
}

inline void calc_feature_vector(__m256i &f, const int *b_arr_int, const int i, const int n) {
    f = _mm256_set1_epi16(0);
    for (int j = 0; j < n; ++j) { 
        f = _mm256_add_epi16(f, _mm256_i32gather_epi32(b_arr_int, feature_to_coord_simd_cell[i][j][0], 4));
        f = _mm256_add_epi16(f, _mm256_slli_epi32(_mm256_i32gather_epi32(b_arr_int, feature_to_coord_simd_cell[i][j][1], 4), 16));
        f = _mm256_mullo_epi16(f, feature_to_coord_simd_mul[i][j]);
    }
    f = _mm256_add_epi16(f, _mm256_i32gather_epi32(b_arr_int, feature_to_coord_simd_cell[i][n][0], 4));
    f = _mm256_add_epi16(f, _mm256_slli_epi32(_mm256_i32gather_epi32(b_arr_int, feature_to_coord_simd_cell[i][n][1], 4), 16));
}


inline void calc_eval_features(Board *board, Eval_search *eval) {
    int b_arr_int[HW2 + 1];
    board->translate_to_arr_player_rev(b_arr_int);
    b_arr_int[COORD_NO] = 0;
    calc_feature_vector(eval->features[0].f256[0], b_arr_int, 0, MAX_N_CELLS_GROUP0 - 1);
    calc_feature_vector(eval->features[0].f256[1], b_arr_int, 1, MAX_N_CELLS_GROUP1 - 1);
    calc_feature_vector(eval->features[0].f256[2], b_arr_int, 2, MAX_N_CELLS_GROUP2 - 1);
    calc_feature_vector(eval->features[0].f256[3], b_arr_int, 3, MAX_N_CELLS_GROUP3 - 1);
    eval->feature_idx = 0;
    eval->features[eval->feature_idx].f256[0] = _mm256_add_epi16(eval->features[eval->feature_idx].f256[0], eval_simd_offsets_simple[0]); 
    eval->features[eval->feature_idx].f256[1] = _mm256_add_epi16(eval->features[eval->feature_idx].f256[1], eval_simd_offsets_simple[1]); 
}


inline void eval_move(Eval_search *eval, const Flip *flip, const Board *board) {
    const uint16_t *flipped_group = (uint16_t*)&(flip->flip);
    const uint16_t *player_group = (uint16_t*)&(board->player);
    const uint16_t *opponent_group = (uint16_t*)&(board->opponent);
    __m256i f0, f1, f2, f3;
    uint16_t unflipped_p;
    uint16_t unflipped_o;
    
    f0 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[0], coord_to_feature_simd[flip->pos][0]);
    f1 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[1], coord_to_feature_simd[flip->pos][1]);
    f2 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[2], coord_to_feature_simd[flip->pos][2]);
    f3 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[3], coord_to_feature_simd[flip->pos][3]);
    for (int i = 0; i < N_SIMD_EVAL_FEATURE_GROUP; ++i) {
        
        unflipped_p = ~flipped_group[i] & player_group[i];
        f0 = _mm256_add_epi16(f0, eval_move_unflipped_16bit[unflipped_p][i][0]);
        f1 = _mm256_add_epi16(f1, eval_move_unflipped_16bit[unflipped_p][i][1]);
        f2 = _mm256_add_epi16(f2, eval_move_unflipped_16bit[unflipped_p][i][2]);
        f3 = _mm256_add_epi16(f3, eval_move_unflipped_16bit[unflipped_p][i][3]);
        
        unflipped_o = ~flipped_group[i] & opponent_group[i];
        f0 = _mm256_sub_epi16(f0, eval_move_unflipped_16bit[unflipped_o][i][0]);
        f1 = _mm256_sub_epi16(f1, eval_move_unflipped_16bit[unflipped_o][i][1]);
        f2 = _mm256_sub_epi16(f2, eval_move_unflipped_16bit[unflipped_o][i][2]);
        f3 = _mm256_sub_epi16(f3, eval_move_unflipped_16bit[unflipped_o][i][3]);
    }
    ++eval->feature_idx;
    eval->features[eval->feature_idx].f256[0] = f0;
    eval->features[eval->feature_idx].f256[1] = f1;
    eval->features[eval->feature_idx].f256[2] = f2;
    eval->features[eval->feature_idx].f256[3] = f3;
}


inline void eval_undo(Eval_search *eval) {
    --eval->feature_idx;
}


inline void eval_pass(Eval_search *eval, const Board *board) {
    const uint16_t *player_group = (uint16_t*)&(board->player);
    const uint16_t *opponent_group = (uint16_t*)&(board->opponent);
    __m256i f0, f1, f2, f3;
    f0 = eval->features[eval->feature_idx].f256[0];
    f1 = eval->features[eval->feature_idx].f256[1];
    f2 = eval->features[eval->feature_idx].f256[2];
    f3 = eval->features[eval->feature_idx].f256[3];
    for (int i = 0; i < N_SIMD_EVAL_FEATURE_GROUP; ++i) {
        f0 = _mm256_add_epi16(f0, eval_move_unflipped_16bit[player_group[i]][i][0]);
        f1 = _mm256_add_epi16(f1, eval_move_unflipped_16bit[player_group[i]][i][1]);
        f2 = _mm256_add_epi16(f2, eval_move_unflipped_16bit[player_group[i]][i][2]);
        f3 = _mm256_add_epi16(f3, eval_move_unflipped_16bit[player_group[i]][i][3]);
        f0 = _mm256_sub_epi16(f0, eval_move_unflipped_16bit[opponent_group[i]][i][0]);
        f1 = _mm256_sub_epi16(f1, eval_move_unflipped_16bit[opponent_group[i]][i][1]);
        f2 = _mm256_sub_epi16(f2, eval_move_unflipped_16bit[opponent_group[i]][i][2]);
        f3 = _mm256_sub_epi16(f3, eval_move_unflipped_16bit[opponent_group[i]][i][3]);
    }
    eval->features[eval->feature_idx].f256[0] = f0;
    eval->features[eval->feature_idx].f256[1] = f1;
    eval->features[eval->feature_idx].f256[2] = f2;
    eval->features[eval->feature_idx].f256[3] = f3;
}





inline void eval_move_endsearch(Eval_search *eval, const Flip *flip, const Board *board) {
    const uint16_t *flipped_group = (uint16_t*)&(flip->flip);
    const uint16_t *player_group = (uint16_t*)&(board->player);
    const uint16_t *opponent_group = (uint16_t*)&(board->opponent);
    
    __m256i f2 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[2], coord_to_feature_simd[flip->pos][2]);
    for (int i = 0; i < N_SIMD_EVAL_FEATURE_GROUP; ++i) {
        
        f2 = _mm256_add_epi16(f2, eval_move_unflipped_16bit[~flipped_group[i] & player_group[i]][i][2]);
        
        f2 = _mm256_sub_epi16(f2, eval_move_unflipped_16bit[~flipped_group[i] & opponent_group[i]][i][2]);
    }
    ++eval->feature_idx;
    eval->features[eval->feature_idx].f256[2] = f2;
}

inline void eval_undo_endsearch(Eval_search *eval) {
    --eval->feature_idx;
}

inline void eval_pass_endsearch(Eval_search *eval, const Board *board) {
    const uint16_t *player_group = (uint16_t*)&(board->player);
    const uint16_t *opponent_group = (uint16_t*)&(board->opponent);
    __m256i f2 = eval->features[eval->feature_idx].f256[2];
    for (int i = 0; i < N_SIMD_EVAL_FEATURE_GROUP; ++i) {
        f2 = _mm256_add_epi16(f2, eval_move_unflipped_16bit[player_group[i]][i][2]);
        f2 = _mm256_sub_epi16(f2, eval_move_unflipped_16bit[opponent_group[i]][i][2]);
    }
    eval->features[eval->feature_idx].f256[2] = f2;
}

// ===== FILE: Egaroucid/src/engine/evaluate_simd_7_7_beta.hpp =====



#pragma once
#include <iostream>
#include <fstream>
#ifdef _MSC_VER
    #include <intrin.h>
#else
    #include <x86intrin.h>
#endif
#include <cstring>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "search.hpp"
#include "util.hpp"
#include "evaluate_common.hpp"


constexpr int CEIL_N_PATTERN_FEATURES = 64;     
constexpr int N_PATTERN_PARAMS_RAW = 944784;    
constexpr int N_PATTERN_PARAMS = N_PATTERN_PARAMS_RAW + 1; 
constexpr int SIMD_EVAL_MAX_VALUE = 4092;       
constexpr int N_SIMD_EVAL_FEATURE_CELLS = 16;
constexpr int N_SIMD_EVAL_FEATURE_GROUP = 4;



constexpr int N_PATTERN_PARAMS_MO_END = 236196 + 1; 
constexpr int SIMD_EVAL_MAX_VALUE_MO_END = 16380;
constexpr int SHIFT_EVAL_MO_END = 472392; 

constexpr Feature_to_coord feature_to_coord[CEIL_N_PATTERN_FEATURES] = {
    
    {10, {COORD_A1, COORD_A2, COORD_B2, COORD_C2, COORD_D2, COORD_E2, COORD_F2, COORD_G2, COORD_H2, COORD_H1}},
    {10, {COORD_H1, COORD_G1, COORD_G2, COORD_G3, COORD_G4, COORD_G5, COORD_G6, COORD_G7, COORD_G8, COORD_H8}},
    {10, {COORD_H8, COORD_H7, COORD_G7, COORD_F7, COORD_E7, COORD_D7, COORD_C7, COORD_B7, COORD_A7, COORD_A8}},
    {10, {COORD_A8, COORD_B8, COORD_B7, COORD_B6, COORD_B5, COORD_B4, COORD_B3, COORD_B2, COORD_B1, COORD_A1}},
    
    
    {10, {COORD_B2, COORD_A3, COORD_B3, COORD_C3, COORD_D3, COORD_E3, COORD_F3, COORD_G3, COORD_H3, COORD_G2}},
    {10, {COORD_G2, COORD_F1, COORD_F2, COORD_F3, COORD_F4, COORD_F5, COORD_F6, COORD_F7, COORD_F8, COORD_G7}},
    {10, {COORD_G7, COORD_H6, COORD_G6, COORD_F6, COORD_E6, COORD_D6, COORD_C6, COORD_B6, COORD_A6, COORD_B7}},
    {10, {COORD_B7, COORD_C8, COORD_C7, COORD_C6, COORD_C5, COORD_C4, COORD_C3, COORD_C2, COORD_C1, COORD_B2}},

    
    {10, {COORD_D3, COORD_A4, COORD_B4, COORD_C4, COORD_D4, COORD_E4, COORD_F4, COORD_G4, COORD_H4, COORD_E3}},
    {10, {COORD_F4, COORD_E1, COORD_E2, COORD_E3, COORD_E4, COORD_E5, COORD_E6, COORD_E7, COORD_E8, COORD_F5}},
    {10, {COORD_E6, COORD_H5, COORD_G5, COORD_F5, COORD_E5, COORD_D5, COORD_C5, COORD_B5, COORD_A5, COORD_D6}},
    {10, {COORD_C5, COORD_D8, COORD_D7, COORD_D6, COORD_D5, COORD_D4, COORD_D3, COORD_D2, COORD_D1, COORD_C4}},

    
    {10, {COORD_B2, COORD_C1, COORD_D1, COORD_E2, COORD_F3, COORD_G4, COORD_H5, COORD_H6, COORD_G7, COORD_G2}},
    {10, {COORD_G2, COORD_H3, COORD_H4, COORD_G5, COORD_F6, COORD_E7, COORD_D8, COORD_C8, COORD_B7, COORD_G7}},
    {10, {COORD_G7, COORD_F8, COORD_E8, COORD_D7, COORD_C6, COORD_B5, COORD_A4, COORD_A3, COORD_B2, COORD_B7}},
    {10, {COORD_B7, COORD_A6, COORD_A5, COORD_B4, COORD_C3, COORD_D2, COORD_E1, COORD_F1, COORD_G2, COORD_B2}},
    
    
    {10, {COORD_B1, COORD_C1, COORD_D2, COORD_E3, COORD_F2, COORD_G3, COORD_F4, COORD_G5, COORD_H6, COORD_H7}},
    {10, {COORD_H2, COORD_H3, COORD_G4, COORD_F5, COORD_G6, COORD_F7, COORD_E6, COORD_D7, COORD_C8, COORD_B8}},
    {10, {COORD_G8, COORD_F8, COORD_E7, COORD_D6, COORD_C7, COORD_B6, COORD_C5, COORD_B4, COORD_A3, COORD_A2}},
    {10, {COORD_A7, COORD_A6, COORD_B5, COORD_C4, COORD_B3, COORD_C2, COORD_D3, COORD_E2, COORD_F1, COORD_G1}},

    
    {10, {COORD_A1, COORD_B1, COORD_C2, COORD_D3, COORD_E4, COORD_F5, COORD_G6, COORD_H7, COORD_H8, COORD_D5}},
    {10, {COORD_H1, COORD_H2, COORD_G3, COORD_F4, COORD_E5, COORD_D6, COORD_C7, COORD_B8, COORD_A8, COORD_D4}},
    {10, {COORD_H8, COORD_G8, COORD_F7, COORD_E6, COORD_D5, COORD_C4, COORD_B3, COORD_A2, COORD_A1, COORD_E4}},
    {10, {COORD_A8, COORD_A7, COORD_B6, COORD_C5, COORD_D4, COORD_E3, COORD_F2, COORD_G1, COORD_H1, COORD_E5}},

    
    {10, {COORD_A1, COORD_B2, COORD_C3, COORD_D4, COORD_E5, COORD_F6, COORD_G7, COORD_H8, COORD_A2, COORD_B1}},
    {10, {COORD_H8, COORD_G7, COORD_F6, COORD_E5, COORD_D4, COORD_C3, COORD_B2, COORD_A1, COORD_H7, COORD_G8}},
    {10, {COORD_H1, COORD_G2, COORD_F3, COORD_E4, COORD_D5, COORD_C6, COORD_B7, COORD_A8, COORD_H2, COORD_G1}},
    {10, {COORD_A8, COORD_B7, COORD_C6, COORD_D5, COORD_E4, COORD_F3, COORD_G2, COORD_H1, COORD_A7, COORD_B8}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_A2, COORD_B2, COORD_C2, COORD_A3, COORD_B3, COORD_C3, COORD_D4}},
    {10, {COORD_H1, COORD_H2, COORD_H3, COORD_G1, COORD_G2, COORD_G3, COORD_F1, COORD_F2, COORD_F3, COORD_E4}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_H7, COORD_G7, COORD_F7, COORD_H6, COORD_G6, COORD_F6, COORD_E5}},
    {10, {COORD_A8, COORD_A7, COORD_A6, COORD_B8, COORD_B7, COORD_B6, COORD_C8, COORD_C7, COORD_C6, COORD_D5}},
    
    
    {10, {COORD_B2, COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_G1, COORD_H1, COORD_G2}},
    {10, {COORD_B2, COORD_A1, COORD_A2, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A7, COORD_A8, COORD_B7}},
    {10, {COORD_B7, COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_G8, COORD_H8, COORD_G7}},
    {10, {COORD_G2, COORD_H1, COORD_H2, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H7, COORD_H8, COORD_G7}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_A2, COORD_B2, COORD_C2, COORD_A3, COORD_B3, COORD_A4}},
    {10, {COORD_H1, COORD_G1, COORD_F1, COORD_E1, COORD_H2, COORD_G2, COORD_F2, COORD_H3, COORD_G3, COORD_H4}},
    {10, {COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_A7, COORD_B7, COORD_C7, COORD_A6, COORD_B6, COORD_A5}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_E8, COORD_H7, COORD_G7, COORD_F7, COORD_H6, COORD_G6, COORD_H5}},

    
    {10, {COORD_A1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_H1, COORD_C2, COORD_D2, COORD_E2, COORD_F2}},
    {10, {COORD_A1, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A8, COORD_B3, COORD_B4, COORD_B5, COORD_B6}},
    {10, {COORD_A8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_H8, COORD_C7, COORD_D7, COORD_E7, COORD_F7}},
    {10, {COORD_H1, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H8, COORD_G3, COORD_G4, COORD_G5, COORD_G6}},

    
    {10, {COORD_A1, COORD_B2, COORD_C3, COORD_D4, COORD_B1, COORD_C2, COORD_D3, COORD_A2, COORD_B3, COORD_C4}},
    {10, {COORD_H1, COORD_G2, COORD_F3, COORD_E4, COORD_G1, COORD_F2, COORD_E3, COORD_H2, COORD_G3, COORD_F4}},
    {10, {COORD_A8, COORD_B7, COORD_C6, COORD_D5, COORD_B8, COORD_C7, COORD_D6, COORD_A7, COORD_B6, COORD_C5}},
    {10, {COORD_H8, COORD_G7, COORD_F6, COORD_E5, COORD_G8, COORD_F7, COORD_E6, COORD_H7, COORD_G6, COORD_F5}},

    
    {10, {COORD_C2, COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_G1, COORD_H1, COORD_F2}},
    {10, {COORD_B3, COORD_A1, COORD_A2, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A7, COORD_A8, COORD_B6}},
    {10, {COORD_C7, COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_G8, COORD_H8, COORD_F7}},
    {10, {COORD_G3, COORD_H1, COORD_H2, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H7, COORD_H8, COORD_G6}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_A2, COORD_B2, COORD_A3, COORD_A4, COORD_A5}},
    {10, {COORD_H1, COORD_G1, COORD_F1, COORD_E1, COORD_D1, COORD_H2, COORD_G2, COORD_H3, COORD_H4, COORD_H5}},
    {10, {COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_A7, COORD_B7, COORD_A6, COORD_A5, COORD_A4}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_E8, COORD_D8, COORD_H7, COORD_G7, COORD_H6, COORD_H5, COORD_H4}},

    
    {10, {COORD_A1, COORD_B1, COORD_A2, COORD_B2, COORD_C2, COORD_D2, COORD_B3, COORD_C3, COORD_B4, COORD_D4}},
    {10, {COORD_H1, COORD_G1, COORD_H2, COORD_G2, COORD_F2, COORD_E2, COORD_G3, COORD_F3, COORD_G4, COORD_E4}},
    {10, {COORD_A8, COORD_B8, COORD_A7, COORD_B7, COORD_C7, COORD_D7, COORD_B6, COORD_C6, COORD_B5, COORD_D5}},
    {10, {COORD_H8, COORD_G8, COORD_H7, COORD_G7, COORD_F7, COORD_E7, COORD_G6, COORD_F6, COORD_G5, COORD_E5}},

    
    {10, {COORD_F3, COORD_E3, COORD_E2, COORD_E1, COORD_F1, COORD_C1, COORD_D1, COORD_D2, COORD_D3, COORD_C3}},
    {10, {COORD_C6, COORD_D6, COORD_D7, COORD_D8, COORD_C8, COORD_F8, COORD_E8, COORD_E7, COORD_E6, COORD_F6}},
    {10, {COORD_C3, COORD_C4, COORD_B4, COORD_A4, COORD_A3, COORD_A6, COORD_A5, COORD_B5, COORD_C5, COORD_C6}},
    {10, {COORD_F6, COORD_F5, COORD_G5, COORD_H5, COORD_H6, COORD_H3, COORD_H4, COORD_G4, COORD_F4, COORD_F3}}
};

constexpr Coord_to_feature coord_to_feature[HW2] = {
    {17, {{ 1, P30}, { 2, P39}, {20, P31}, {22, P39}, {24, P32}, {25, P39}, {30, P39}, {34, P31}, {35, P31}, {39, P39}, {42, P34}, {43, P34}, {47, P39}, {50, P31}, {51, P31}, {55, P39}, {59, P39}}}, 
    {11, {{ 1, P31}, {18, P39}, {22, P38}, {25, P30}, {30, P38}, {34, P32}, {39, P38}, {47, P35}, {50, P32}, {55, P38}, {59, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 5, P31}, {14, P38}, {18, P38}, {30, P37}, {34, P33}, {39, P37}, {42, P35}, {50, P33}, {55, P37}, {61, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 9, P31}, {14, P37}, {34, P34}, {39, P36}, {42, P36}, {50, P34}, {54, P35}, {55, P36}, {61, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{11, P38}, {13, P33}, {34, P35}, {38, P36}, {42, P37}, {50, P35}, {54, P36}, {55, P35}, {61, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 7, P38}, {13, P32}, {17, P31}, {31, P33}, {34, P36}, {38, P37}, {42, P38}, {50, P36}, {54, P37}, {61, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 3, P38}, {17, P30}, {21, P32}, {27, P30}, {31, P36}, {34, P37}, {38, P38}, {46, P35}, {50, P37}, {54, P38}, {58, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {17, {{ 2, P30}, { 3, P39}, {21, P31}, {23, P39}, {26, P32}, {27, P39}, {31, P39}, {33, P31}, {34, P38}, {38, P39}, {41, P34}, {42, P39}, {46, P39}, {49, P31}, {50, P38}, {54, P39}, {58, P39}}}, 
    {11, {{ 2, P38}, {16, P30}, {20, P32}, {25, P31}, {30, P36}, {35, P32}, {39, P35}, {47, P32}, {51, P32}, {55, P34}, {59, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {16, {{ 1, P32}, { 2, P37}, { 5, P30}, { 6, P39}, {12, P31}, {13, P30}, {14, P39}, {24, P33}, {25, P38}, {30, P35}, {34, P30}, {35, P30}, {39, P34}, {47, P38}, {55, P33}, {59, P36}, { 0, PNO}}}, 
    {10, {{ 2, P36}, { 5, P32}, {17, P34}, {22, P37}, {30, P34}, {39, P33}, {42, P30}, {47, P34}, {50, P30}, {59, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 2, P35}, { 9, P32}, {13, P34}, {18, P37}, {42, P31}, {59, P34}, {61, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 2, P34}, {11, P37}, {14, P36}, {17, P32}, {42, P32}, {58, P34}, {61, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 2, P33}, { 7, P37}, {18, P35}, {21, P33}, {31, P32}, {38, P33}, {42, P33}, {46, P34}, {50, P39}, {58, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {16, {{ 2, P32}, { 3, P37}, { 6, P30}, { 7, P39}, {13, P31}, {14, P30}, {15, P39}, {26, P33}, {27, P38}, {31, P35}, {33, P30}, {34, P39}, {38, P34}, {46, P38}, {54, P33}, {58, P36}, { 0, PNO}}}, 
    {11, {{ 2, P31}, {19, P39}, {23, P38}, {27, P31}, {31, P38}, {33, P32}, {38, P35}, {46, P32}, {49, P32}, {54, P34}, {58, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 6, P38}, {12, P32}, {16, P31}, {30, P33}, {35, P33}, {39, P32}, {43, P35}, {51, P33}, {55, P32}, {63, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 1, P33}, { 6, P37}, {17, P35}, {20, P33}, {30, P32}, {39, P31}, {43, P30}, {47, P31}, {51, P30}, {59, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 5, P33}, { 6, P36}, {13, P35}, {24, P34}, {25, P37}, {30, P31}, {47, P37}, {59, P32}, {61, P30}, {63, P39}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 6, P35}, { 9, P33}, {10, P39}, {17, P33}, {22, P36}, {47, P33}, {61, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 6, P34}, {10, P30}, {11, P36}, {18, P36}, {21, P34}, {46, P33}, {61, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 6, P33}, { 7, P36}, {14, P35}, {26, P34}, {27, P37}, {31, P31}, {46, P37}, {58, P32}, {61, P39}, {62, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 3, P36}, { 6, P32}, {18, P34}, {23, P37}, {31, P34}, {38, P31}, {41, P30}, {46, P31}, {49, P30}, {58, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 6, P31}, {15, P38}, {19, P38}, {31, P37}, {33, P33}, {38, P32}, {41, P35}, {49, P33}, {54, P32}, {62, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{10, P38}, {12, P33}, {35, P34}, {39, P30}, {43, P36}, {51, P34}, {53, P30}, {55, P31}, {63, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 1, P34}, {10, P37}, {13, P36}, {16, P32}, {43, P31}, {59, P31}, {63, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 5, P34}, { 9, P30}, {10, P36}, {17, P36}, {20, P34}, {47, P30}, {63, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 9, P34}, {10, P35}, {21, P35}, {23, P30}, {24, P35}, {25, P36}, {30, P30}, {47, P36}, {59, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{10, P34}, {11, P35}, {20, P30}, {22, P35}, {26, P35}, {27, P36}, {31, P30}, {46, P36}, {58, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 7, P35}, {10, P33}, {11, P39}, {18, P33}, {23, P36}, {46, P30}, {62, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 3, P35}, {10, P32}, {14, P34}, {19, P37}, {41, P31}, {58, P31}, {62, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{10, P31}, {15, P37}, {33, P34}, {38, P30}, {41, P36}, {49, P34}, {52, P30}, {54, P31}, {62, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 8, P31}, {13, P37}, {35, P35}, {37, P30}, {43, P37}, {51, P35}, {53, P31}, {55, P30}, {63, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 1, P35}, { 8, P32}, {12, P34}, {17, P37}, {43, P32}, {57, P31}, {63, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 5, P35}, { 8, P33}, { 9, P39}, {16, P33}, {21, P36}, {45, P30}, {63, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 8, P34}, { 9, P35}, {20, P35}, {22, P30}, {26, P36}, {27, P35}, {29, P30}, {45, P36}, {57, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 8, P35}, {11, P34}, {21, P30}, {23, P35}, {24, P36}, {25, P35}, {28, P30}, {44, P36}, {56, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 7, P34}, { 8, P36}, {11, P30}, {19, P36}, {22, P34}, {44, P30}, {62, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 3, P34}, { 8, P37}, {15, P36}, {18, P32}, {41, P32}, {56, P31}, {62, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 8, P38}, {14, P33}, {33, P35}, {36, P30}, {41, P37}, {49, P35}, {52, P31}, {54, P30}, {62, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 4, P31}, {13, P38}, {17, P38}, {29, P37}, {35, P36}, {37, P32}, {43, P38}, {51, P36}, {53, P32}, {63, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 1, P36}, { 4, P32}, {16, P34}, {21, P37}, {29, P34}, {37, P31}, {43, P33}, {45, P31}, {51, P39}, {57, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 4, P33}, { 5, P36}, {12, P35}, {26, P37}, {27, P34}, {29, P31}, {45, P37}, {57, P32}, {60, P39}, {63, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 4, P34}, { 8, P30}, { 9, P36}, {16, P36}, {23, P34}, {45, P33}, {60, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 4, P35}, { 8, P39}, {11, P33}, {19, P33}, {20, P36}, {44, P33}, {60, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 4, P36}, { 7, P33}, {15, P35}, {24, P37}, {25, P34}, {28, P31}, {44, P37}, {56, P32}, {60, P30}, {62, P39}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 3, P33}, { 4, P37}, {19, P35}, {22, P33}, {28, P32}, {36, P31}, {41, P33}, {44, P31}, {49, P39}, {56, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 4, P38}, {14, P32}, {18, P31}, {28, P33}, {33, P36}, {36, P32}, {41, P38}, {49, P36}, {52, P32}, {62, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 0, P31}, {17, P39}, {21, P38}, {26, P31}, {29, P38}, {35, P37}, {37, P35}, {45, P32}, {51, P37}, {53, P34}, {57, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {16, {{ 0, P32}, { 1, P37}, { 4, P30}, { 5, P39}, {12, P30}, {13, P39}, {15, P31}, {26, P38}, {27, P33}, {29, P35}, {32, P30}, {35, P39}, {37, P34}, {45, P38}, {53, P33}, {57, P36}, { 0, PNO}}}, 
    {10, {{ 0, P33}, { 5, P37}, {16, P35}, {23, P33}, {29, P32}, {37, P33}, {40, P30}, {45, P34}, {48, P30}, {57, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 0, P34}, { 9, P37}, {12, P36}, {19, P32}, {40, P31}, {57, P34}, {60, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 0, P35}, {11, P32}, {15, P34}, {16, P37}, {40, P32}, {56, P34}, {60, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 0, P36}, { 7, P32}, {19, P34}, {20, P37}, {28, P34}, {36, P33}, {40, P33}, {44, P34}, {48, P39}, {56, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {16, {{ 0, P37}, { 3, P32}, { 4, P39}, { 7, P30}, {12, P39}, {14, P31}, {15, P30}, {24, P38}, {25, P33}, {28, P35}, {32, P39}, {33, P39}, {36, P34}, {44, P38}, {52, P33}, {56, P36}, { 0, PNO}}}, 
    {11, {{ 0, P38}, {18, P30}, {22, P32}, {24, P31}, {28, P36}, {33, P37}, {36, P35}, {44, P32}, {49, P37}, {52, P34}, {56, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {17, {{ 0, P30}, { 1, P39}, {21, P39}, {23, P31}, {26, P39}, {27, P32}, {29, P39}, {32, P31}, {35, P38}, {37, P39}, {40, P34}, {43, P39}, {45, P39}, {48, P31}, {51, P38}, {53, P39}, {57, P39}}}, 
    {11, {{ 1, P38}, {19, P30}, {23, P32}, {26, P30}, {29, P36}, {32, P32}, {37, P38}, {45, P35}, {48, P32}, {53, P38}, {57, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 5, P38}, {15, P32}, {19, P31}, {29, P33}, {32, P33}, {37, P37}, {40, P35}, {48, P33}, {53, P37}, {60, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 9, P38}, {15, P33}, {32, P34}, {37, P36}, {40, P36}, {48, P34}, {52, P35}, {53, P36}, {60, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{11, P31}, {12, P37}, {32, P35}, {36, P36}, {40, P37}, {48, P35}, {52, P36}, {53, P35}, {60, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 7, P31}, {12, P38}, {16, P38}, {28, P37}, {32, P36}, {36, P37}, {40, P38}, {48, P36}, {52, P37}, {60, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 3, P31}, {16, P39}, {20, P38}, {24, P30}, {28, P38}, {32, P37}, {36, P38}, {44, P35}, {48, P37}, {52, P38}, {56, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {17, {{ 0, P39}, { 3, P30}, {20, P39}, {22, P31}, {24, P39}, {25, P32}, {28, P39}, {32, P38}, {33, P38}, {36, P39}, {40, P39}, {41, P39}, {44, P39}, {48, P38}, {49, P38}, {52, P39}, {56, P39}}}, 
};

constexpr int pattern_starts[N_PATTERNS] = {
    1, 59050, 118099, 177148,           
    236197, 295246, 354295, 413344,     
    472393, 531442, 590491, 649540,     
    708589, 767638, 826687, 885736      
};


__m256i eval_lower_mask;
__m256i feature_to_coord_simd_mul[N_EVAL_VECTORS][MAX_PATTERN_CELLS - 1];
__m256i feature_to_coord_simd_cell[N_EVAL_VECTORS][MAX_PATTERN_CELLS][2];
__m256i coord_to_feature_simd[HW2][N_EVAL_VECTORS];
__m256i eval_move_unflipped_16bit[N_16BIT][N_SIMD_EVAL_FEATURE_GROUP][N_EVAL_VECTORS];
__m256i eval_simd_offsets[N_EVAL_VECTORS * 2]; 




int16_t pattern_arr[N_PHASES][N_PATTERN_PARAMS];
int16_t eval_num_arr[N_PHASES][MAX_STONE_NUM];

int16_t pattern_move_ordering_end_arr[N_PATTERN_PARAMS_MO_END];

inline bool load_eval_file(const char* file, bool show_log) {
    if (show_log) {
        std::cerr << "evaluation file " << file << std::endl;
    }
    bool failed = false;
    std::vector<int16_t> unzipped_params = load_unzip_egev2(file, show_log, &failed);
    if (failed) {
        return false;
    }
    size_t param_idx = 0;
    for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
        pattern_arr[phase_idx][0] = 0; 
        std::memcpy(pattern_arr[phase_idx] + 1, &unzipped_params[param_idx], sizeof(short) * N_PATTERN_PARAMS_RAW);
        param_idx += N_PATTERN_PARAMS_RAW;
        std::memcpy(eval_num_arr[phase_idx], &unzipped_params[param_idx], sizeof(short) * MAX_STONE_NUM);
        param_idx += MAX_STONE_NUM;
    }
    
    for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
        for (int i = 1; i < N_PATTERN_PARAMS; ++i) {
            if (pattern_arr[phase_idx][i] < -SIMD_EVAL_MAX_VALUE) {
                std::cerr << "[ERROR] evaluation value too low. you can ignore this error. phase " << phase_idx << " index " << i << " found " << pattern_arr[phase_idx][i] << std::endl;
                pattern_arr[phase_idx][i] = -SIMD_EVAL_MAX_VALUE;
            }
            if (pattern_arr[phase_idx][i] > SIMD_EVAL_MAX_VALUE) {
                std::cerr << "[ERROR] evaluation value too high. you can ignore this error. phase " << phase_idx << " index " << i << " found " << pattern_arr[phase_idx][i] << std::endl;
                pattern_arr[phase_idx][i] = SIMD_EVAL_MAX_VALUE;
            }
            pattern_arr[phase_idx][i] += SIMD_EVAL_MAX_VALUE;
        }
    }
    return true;
}

inline bool load_eval_move_ordering_end_file(const char* file, bool show_log) {
    if (show_log) {
        std::cerr << "evaluation for move ordering end file " << file << std::endl;
    }
    FILE* fp;
    if (!file_open(&fp, file, "rb")) {
        std::cerr << "[ERROR] [FATAL] can't open eval " << file << std::endl;
        return false;
    }
    pattern_move_ordering_end_arr[0] = 0; 
    if (fread(pattern_move_ordering_end_arr + 1, 2, N_PATTERN_PARAMS_MO_END - 1, fp) < N_PATTERN_PARAMS_MO_END - 1) {
        std::cerr << "[ERROR] [FATAL] evaluation file for move ordering end broken" << std::endl;
        fclose(fp);
        return false;
    }
    
    for (int i = 1; i < N_PATTERN_PARAMS_MO_END; ++i) {
        if (pattern_move_ordering_end_arr[i] < -SIMD_EVAL_MAX_VALUE_MO_END) {
            std::cerr << "[ERROR] evaluation value too low. you can ignore this error. index " << i << " found " << pattern_move_ordering_end_arr[i] << std::endl;
            pattern_move_ordering_end_arr[i] = -SIMD_EVAL_MAX_VALUE_MO_END;
        }
        if (pattern_move_ordering_end_arr[i] > SIMD_EVAL_MAX_VALUE_MO_END) {
            std::cerr << "[ERROR] evaluation value too high. you can ignore this error. index " << i << " found " << pattern_move_ordering_end_arr[i] << std::endl;
            pattern_move_ordering_end_arr[i] = SIMD_EVAL_MAX_VALUE_MO_END;
        }
        pattern_move_ordering_end_arr[i] += SIMD_EVAL_MAX_VALUE_MO_END;
    }
    return true;
}

inline void pre_calculate_eval_constant() {
    { 
        int16_t f2c[16];
        for (int i = 0; i < N_EVAL_VECTORS; ++i) {
            for (int j = 0; j < MAX_PATTERN_CELLS - 1; ++j) {
                for (int k = 0; k < 16; ++k) {
                    f2c[k] = (j < feature_to_coord[i * 16 + k].n_cells - 1) ? 3 : 1;
                }
                feature_to_coord_simd_mul[i][j] = _mm256_set_epi16(
                    f2c[0], f2c[1], f2c[2], f2c[3], 
                    f2c[4], f2c[5], f2c[6], f2c[7], 
                    f2c[8], f2c[9], f2c[10], f2c[11], 
                    f2c[12], f2c[13], f2c[14], f2c[15]
                );
            }
        }
        int32_t f2c32[8];
        for (int i = 0; i < N_EVAL_VECTORS; ++i) {
            for (int j = 0; j < MAX_PATTERN_CELLS; ++j) {
                for (int k = 0; k < 8; ++k) {
                    f2c32[k] = feature_to_coord[i * 16 + k * 2 + 1].cells[j];
                }
                feature_to_coord_simd_cell[i][j][0] = _mm256_set_epi32(
                    f2c32[0], f2c32[1], f2c32[2], f2c32[3], 
                    f2c32[4], f2c32[5], f2c32[6], f2c32[7]
                );
                for (int k = 0; k < 8; ++k) {
                    f2c32[k] = feature_to_coord[i * 16 + k * 2].cells[j];
                }
                feature_to_coord_simd_cell[i][j][1] = _mm256_set_epi32(
                    f2c32[0], f2c32[1], f2c32[2], f2c32[3], 
                    f2c32[4], f2c32[5], f2c32[6], f2c32[7]
                );
            }
        }
    }
    { 
        uint16_t c2f[CEIL_N_PATTERN_FEATURES];
        for (int cell = 0; cell < HW2; ++cell) { 
            for (int i = 0; i < CEIL_N_PATTERN_FEATURES; ++i) {
                c2f[i] = 0;
            }
            for (int i = 0; i < coord_to_feature[cell].n_features; ++i) {
                c2f[coord_to_feature[cell].features[i].feature] = coord_to_feature[cell].features[i].x;
            }
            for (int i = 0; i < N_EVAL_VECTORS; ++i) {
                int idx = i * 16;
                coord_to_feature_simd[cell][i] = _mm256_set_epi16(
                    c2f[idx], c2f[idx + 1], c2f[idx + 2], c2f[idx + 3], 
                    c2f[idx + 4], c2f[idx + 5], c2f[idx + 6], c2f[idx + 7], 
                    c2f[idx + 8], c2f[idx + 9], c2f[idx + 10], c2f[idx + 11], 
                    c2f[idx + 12], c2f[idx + 13], c2f[idx + 14], c2f[idx + 15]
                );
            }
        }
        for (int bits = 0; bits < N_16BIT; ++bits) { 
            for (int group = 0; group < N_SIMD_EVAL_FEATURE_GROUP; ++group) { 
                for (int i = 0; i < CEIL_N_PATTERN_FEATURES; ++i) {
                    c2f[i] = 0;
                }
                for (int cell = 0; cell < N_SIMD_EVAL_FEATURE_CELLS; ++cell) {
                    if (1 & (bits >> cell)) {
                        int global_cell = group * N_SIMD_EVAL_FEATURE_CELLS + cell;
                        for (int i = 0; i < coord_to_feature[global_cell].n_features; ++i) {
                            c2f[coord_to_feature[global_cell].features[i].feature] += coord_to_feature[global_cell].features[i].x;
                        }
                    }
                }
                for (int simd_feature_idx = 0; simd_feature_idx < N_EVAL_VECTORS; ++simd_feature_idx) {
                    int idx = simd_feature_idx * 16;
                    eval_move_unflipped_16bit[bits][group][simd_feature_idx] = _mm256_set_epi16(
                        c2f[idx], c2f[idx + 1], c2f[idx + 2], c2f[idx + 3], 
                        c2f[idx + 4], c2f[idx + 5], c2f[idx + 6], c2f[idx + 7], 
                        c2f[idx + 8], c2f[idx + 9], c2f[idx + 10], c2f[idx + 11], 
                        c2f[idx + 12], c2f[idx + 13], c2f[idx + 14], c2f[idx + 15]
                    );
                }
            }
        }
        for (int i = 0; i < N_EVAL_VECTORS; ++i) {
            int i4 = i * 4;
            eval_simd_offsets[i * 2] = _mm256_set_epi32(
                pattern_starts[2 + i4], pattern_starts[2 + i4], pattern_starts[2 + i4], pattern_starts[2 + i4], 
                pattern_starts[3 + i4], pattern_starts[3 + i4], pattern_starts[3 + i4], pattern_starts[3 + i4]
            );
            eval_simd_offsets[i * 2 + 1] = _mm256_set_epi32(
                pattern_starts[i4], pattern_starts[i4], pattern_starts[i4], pattern_starts[i4], 
                pattern_starts[1 + i4], pattern_starts[1 + i4], pattern_starts[1 + i4], pattern_starts[1 + i4]
            );
        }
        eval_lower_mask = _mm256_set1_epi32(0x0000FFFF);
    }
}


inline bool evaluate_init(const char* file, const char* mo_end_nws_file, bool show_log) {
    bool eval_loaded = load_eval_file(file, show_log);
    if (!eval_loaded) {
        std::cerr << "[ERROR] [FATAL] evaluation file not loaded" << std::endl;
        return false;
    }
    bool eval_move_ordering_end_nws_loaded = load_eval_move_ordering_end_file(mo_end_nws_file, show_log);
    if (!eval_move_ordering_end_nws_loaded) {
        std::cerr << "[ERROR] [FATAL] evaluation file for move ordering end not loaded" << std::endl;
        return false;
    }
    pre_calculate_eval_constant();
    if (show_log) {
        std::cerr << "evaluation function initialized" << std::endl;
    }
    return true;
}


bool evaluate_init(const std::string file, std::string mo_end_nws_file, bool show_log) {
    return evaluate_init(file.c_str(), mo_end_nws_file.c_str(), show_log);
}


bool evaluate_init(bool show_log) {
    return evaluate_init(EXE_DIRECTORY_PATH + "resources/eval.egev2", EXE_DIRECTORY_PATH + "resources/eval_move_ordering_end.egev", show_log);
}


inline __m256i calc_idx8_comp(const __m128i feature, const int i) {
    return _mm256_add_epi32(_mm256_cvtepu16_epi32(feature), eval_simd_offsets[i]);
}

inline __m256i gather_eval(const int *start_addr, const __m256i idx8) {
    return _mm256_i32gather_epi32(start_addr, idx8, 2); 
    
}

inline int calc_pattern(const int phase_idx, Eval_features *features) {
    const int *start_addr = (int*)pattern_arr[phase_idx];
    __m256i res256 =                  gather_eval(start_addr, calc_idx8_comp(features->f128[0], 0));
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[1], 1)));
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[2], 2)));
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[3], 3)));
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[4], 4)));
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[5], 5)));
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[6], 6)));
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[7], 7)));
    res256 = _mm256_and_si256(res256, eval_lower_mask);
    __m128i res128 = _mm_add_epi32(_mm256_castsi256_si128(res256), _mm256_extracti128_si256(res256, 1));
    res128 = _mm_hadd_epi32(res128, res128);
    return _mm_cvtsi128_si32(res128) + _mm_extract_epi32(res128, 1) - SIMD_EVAL_MAX_VALUE * N_PATTERN_FEATURES;
}

inline int calc_pattern_move_ordering_end(Eval_features *features) {
    const int *start_addr = (int*)(pattern_move_ordering_end_arr - SHIFT_EVAL_MO_END);
    __m256i res256 =                  gather_eval(start_addr, calc_idx8_comp(features->f128[4], 4));        
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[5], 5)));       
    res256 = _mm256_and_si256(res256, eval_lower_mask);
    __m128i res128 = _mm_add_epi32(_mm256_castsi256_si128(res256), _mm256_extracti128_si256(res256, 1));
    res128 = _mm_hadd_epi32(res128, res128);
    return _mm_cvtsi128_si32(res128) + _mm_extract_epi32(res128, 1) - SIMD_EVAL_MAX_VALUE_MO_END * N_PATTERN_FEATURES_MO_END;
}

inline void calc_eval_features(Board *board, Eval_search *eval);


inline int mid_evaluate(Board *board) {
    Search search(board);
    calc_eval_features(&(search.board), &(search.eval));
    int phase_idx, num0;
    phase_idx = search.phase();
    num0 = pop_count_ull(search.board.player);
    int res = calc_pattern(phase_idx, &search.eval.features[search.eval.feature_idx]) + eval_num_arr[phase_idx][num0];
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    res = std::clamp(res, -SCORE_MAX, SCORE_MAX);
    return res;
}


inline int mid_evaluate_diff(Search *search) {
    int phase_idx, num0;
    phase_idx = search->phase();
    num0 = pop_count_ull(search->board.player);
    int res = calc_pattern(phase_idx, &search->eval.features[search->eval.feature_idx]) + eval_num_arr[phase_idx][num0];
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    res = std::clamp(res, -SCORE_MAX, SCORE_MAX);
    return res;
}


inline int mid_evaluate_move_ordering_end(Search *search) {
    int res = calc_pattern_move_ordering_end(&search->eval.features[search->eval.feature_idx]);
    res += res >= 0 ? STEP_2_MO_END : -STEP_2_MO_END;
    res /= STEP_MO_END;
    return res;
}

inline void calc_feature_vector(__m256i &f, const int *b_arr_int, const int i, const int n) {
    f = _mm256_set1_epi16(0);
    for (int j = 0; j < n; ++j) { 
        f = _mm256_add_epi16(f, _mm256_i32gather_epi32(b_arr_int, feature_to_coord_simd_cell[i][j][0], 4));
        f = _mm256_add_epi16(f, _mm256_slli_epi32(_mm256_i32gather_epi32(b_arr_int, feature_to_coord_simd_cell[i][j][1], 4), 16));
        f = _mm256_mullo_epi16(f, feature_to_coord_simd_mul[i][j]);
    }
    f = _mm256_add_epi16(f, _mm256_i32gather_epi32(b_arr_int, feature_to_coord_simd_cell[i][n][0], 4));
    f = _mm256_add_epi16(f, _mm256_slli_epi32(_mm256_i32gather_epi32(b_arr_int, feature_to_coord_simd_cell[i][n][1], 4), 16));
}


inline void calc_eval_features(Board *board, Eval_search *eval) {
    int b_arr_int[HW2 + 1];
    board->translate_to_arr_player_rev(b_arr_int);
    b_arr_int[COORD_NO] = 0;
    calc_feature_vector(eval->features[0].f256[0], b_arr_int, 0, MAX_PATTERN_CELLS - 1);
    calc_feature_vector(eval->features[0].f256[1], b_arr_int, 1, MAX_PATTERN_CELLS - 1);
    calc_feature_vector(eval->features[0].f256[2], b_arr_int, 2, MAX_PATTERN_CELLS - 1);
    calc_feature_vector(eval->features[0].f256[3], b_arr_int, 3, MAX_PATTERN_CELLS - 1);
    eval->feature_idx = 0;
}


inline void eval_move(Eval_search *eval, const Flip *flip, const Board *board) {
    const uint16_t *flipped_group = (uint16_t*)&(flip->flip);
    const uint16_t *player_group = (uint16_t*)&(board->player);
    const uint16_t *opponent_group = (uint16_t*)&(board->opponent);
    __m256i f0, f1, f2, f3;
    uint16_t unflipped_p;
    uint16_t unflipped_o;
    
    f0 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[0], coord_to_feature_simd[flip->pos][0]);
    f1 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[1], coord_to_feature_simd[flip->pos][1]);
    f2 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[2], coord_to_feature_simd[flip->pos][2]);
    f3 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[3], coord_to_feature_simd[flip->pos][3]);
    for (int i = 0; i < HW2 / 16; ++i) { 
        
        unflipped_p = ~flipped_group[i] & player_group[i];
        f0 = _mm256_add_epi16(f0, eval_move_unflipped_16bit[unflipped_p][i][0]);
        f1 = _mm256_add_epi16(f1, eval_move_unflipped_16bit[unflipped_p][i][1]);
        f2 = _mm256_add_epi16(f2, eval_move_unflipped_16bit[unflipped_p][i][2]);
        f3 = _mm256_add_epi16(f3, eval_move_unflipped_16bit[unflipped_p][i][3]);
        
        unflipped_o = ~flipped_group[i] & opponent_group[i];
        f0 = _mm256_sub_epi16(f0, eval_move_unflipped_16bit[unflipped_o][i][0]);
        f1 = _mm256_sub_epi16(f1, eval_move_unflipped_16bit[unflipped_o][i][1]);
        f2 = _mm256_sub_epi16(f2, eval_move_unflipped_16bit[unflipped_o][i][2]);
        f3 = _mm256_sub_epi16(f3, eval_move_unflipped_16bit[unflipped_o][i][3]);
    }
    ++eval->feature_idx;
    eval->features[eval->feature_idx].f256[0] = f0;
    eval->features[eval->feature_idx].f256[1] = f1;
    eval->features[eval->feature_idx].f256[2] = f2;
    eval->features[eval->feature_idx].f256[3] = f3;
}


inline void eval_undo(Eval_search *eval) {
    --eval->feature_idx;
}


inline void eval_pass(Eval_search *eval, const Board *board) {
    const uint16_t *player_group = (uint16_t*)&(board->player);
    const uint16_t *opponent_group = (uint16_t*)&(board->opponent);
    __m256i f0, f1, f2, f3;
    f0 = eval->features[eval->feature_idx].f256[0];
    f1 = eval->features[eval->feature_idx].f256[1];
    f2 = eval->features[eval->feature_idx].f256[2];
    f3 = eval->features[eval->feature_idx].f256[3];
    for (int i = 0; i < HW2 / 16; ++i) { 
        f0 = _mm256_add_epi16(f0, eval_move_unflipped_16bit[player_group[i]][i][0]);
        f1 = _mm256_add_epi16(f1, eval_move_unflipped_16bit[player_group[i]][i][1]);
        f2 = _mm256_add_epi16(f2, eval_move_unflipped_16bit[player_group[i]][i][2]);
        f3 = _mm256_add_epi16(f3, eval_move_unflipped_16bit[player_group[i]][i][3]);
        f0 = _mm256_sub_epi16(f0, eval_move_unflipped_16bit[opponent_group[i]][i][0]);
        f1 = _mm256_sub_epi16(f1, eval_move_unflipped_16bit[opponent_group[i]][i][1]);
        f2 = _mm256_sub_epi16(f2, eval_move_unflipped_16bit[opponent_group[i]][i][2]);
        f3 = _mm256_sub_epi16(f3, eval_move_unflipped_16bit[opponent_group[i]][i][3]);
    }
    eval->features[eval->feature_idx].f256[0] = f0;
    eval->features[eval->feature_idx].f256[1] = f1;
    eval->features[eval->feature_idx].f256[2] = f2;
    eval->features[eval->feature_idx].f256[3] = f3;
}





inline void eval_move_endsearch(Eval_search *eval, const Flip *flip, const Board *board) {
    const uint16_t *flipped_group = (uint16_t*)&(flip->flip);
    const uint16_t *player_group = (uint16_t*)&(board->player);
    const uint16_t *opponent_group = (uint16_t*)&(board->opponent);
    
    __m256i f2 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[2], coord_to_feature_simd[flip->pos][2]);
    for (int i = 0; i < N_SIMD_EVAL_FEATURE_GROUP; ++i) {
        
        f2 = _mm256_add_epi16(f2, eval_move_unflipped_16bit[~flipped_group[i] & player_group[i]][i][2]);
        
        f2 = _mm256_sub_epi16(f2, eval_move_unflipped_16bit[~flipped_group[i] & opponent_group[i]][i][2]);
    }
    ++eval->feature_idx;
    eval->features[eval->feature_idx].f256[2] = f2;
}

inline void eval_undo_endsearch(Eval_search *eval) {
    --eval->feature_idx;
}

inline void eval_pass_endsearch(Eval_search *eval, const Board *board) {
    const uint16_t *player_group = (uint16_t*)&(board->player);
    const uint16_t *opponent_group = (uint16_t*)&(board->opponent);
    __m256i f2 = eval->features[eval->feature_idx].f256[2];
    for (int i = 0; i < N_SIMD_EVAL_FEATURE_GROUP; ++i) {
        f2 = _mm256_add_epi16(f2, eval_move_unflipped_16bit[player_group[i]][i][2]);
        f2 = _mm256_sub_epi16(f2, eval_move_unflipped_16bit[opponent_group[i]][i][2]);
    }
    eval->features[eval->feature_idx].f256[2] = f2;
}

// ===== FILE: Egaroucid/src/engine/evaluate_simd.hpp =====



#pragma once
#include <iostream>
#include <fstream>
#ifdef _MSC_VER
    #include <intrin.h>
#else
    #include <x86intrin.h>
#endif
#include <cstring>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "search.hpp"
#include "util.hpp"
#include "evaluate_common.hpp"


constexpr int CEIL_N_PATTERN_FEATURES = 64;     
constexpr int N_PATTERN_PARAMS_RAW = 612360;    
constexpr int N_PATTERN_PARAMS = N_PATTERN_PARAMS_RAW + 1; 
constexpr int PATTERN4_START_IDX = 52488;       
constexpr int PATTERN6_START_IDX = 78732;       
constexpr int SIMD_EVAL_MAX_VALUE = 4092;       
constexpr int N_EVAL_VECTORS_SIMPLE = 2;
constexpr int N_EVAL_VECTORS_COMP = 2;
constexpr int N_SIMD_EVAL_FEATURE_CELLS = 16;
constexpr int N_SIMD_EVAL_FEATURE_GROUP = 4;
constexpr int MAX_N_CELLS_GROUP[4] = {9, 10, 10, 10}; 



constexpr int N_PATTERN_PARAMS_MO_END = 236196 + 1; 
constexpr int SIMD_EVAL_MAX_VALUE_MO_END = 16380;
constexpr int SHIFT_EVAL_MO_END = 139968; 

constexpr Feature_to_coord feature_to_coord[CEIL_N_PATTERN_FEATURES] = {
    
    {8, {COORD_A2, COORD_B2, COORD_C2, COORD_D2, COORD_E2, COORD_F2, COORD_G2, COORD_H2, COORD_NO, COORD_NO}},
    {8, {COORD_B1, COORD_B2, COORD_B3, COORD_B4, COORD_B5, COORD_B6, COORD_B7, COORD_B8, COORD_NO, COORD_NO}},
    {8, {COORD_A7, COORD_B7, COORD_C7, COORD_D7, COORD_E7, COORD_F7, COORD_G7, COORD_H7, COORD_NO, COORD_NO}},
    {8, {COORD_G1, COORD_G2, COORD_G3, COORD_G4, COORD_G5, COORD_G6, COORD_G7, COORD_G8, COORD_NO, COORD_NO}},
    
    
    {9, {COORD_B1, COORD_C1, COORD_D2, COORD_E3, COORD_G2, COORD_F4, COORD_G5, COORD_H6, COORD_H7, COORD_NO}},
    {9, {COORD_H2, COORD_H3, COORD_G4, COORD_F5, COORD_G7, COORD_E6, COORD_D7, COORD_C8, COORD_B8, COORD_NO}},
    {9, {COORD_G8, COORD_F8, COORD_E7, COORD_D6, COORD_B7, COORD_C5, COORD_B4, COORD_A3, COORD_A2, COORD_NO}},
    {9, {COORD_A7, COORD_A6, COORD_B5, COORD_C4, COORD_B2, COORD_D3, COORD_E2, COORD_F1, COORD_G1, COORD_NO}},

    
    {8, {COORD_A3, COORD_B3, COORD_C3, COORD_D3, COORD_E3, COORD_F3, COORD_G3, COORD_H3, COORD_NO, COORD_NO}},
    {8, {COORD_C1, COORD_C2, COORD_C3, COORD_C4, COORD_C5, COORD_C6, COORD_C7, COORD_C8, COORD_NO, COORD_NO}},
    {8, {COORD_A6, COORD_B6, COORD_C6, COORD_D6, COORD_E6, COORD_F6, COORD_G6, COORD_H6, COORD_NO, COORD_NO}},
    {8, {COORD_F1, COORD_F2, COORD_F3, COORD_F4, COORD_F5, COORD_F6, COORD_F7, COORD_F8, COORD_NO, COORD_NO}},

    
    {9, {COORD_A1, COORD_B1, COORD_C2, COORD_D3, COORD_E4, COORD_F5, COORD_G6, COORD_H7, COORD_H8, COORD_NO}},
    {9, {COORD_H1, COORD_H2, COORD_G3, COORD_F4, COORD_E5, COORD_D6, COORD_C7, COORD_B8, COORD_A8, COORD_NO}},
    {9, {COORD_H8, COORD_G8, COORD_F7, COORD_E6, COORD_D5, COORD_C4, COORD_B3, COORD_A2, COORD_A1, COORD_NO}},
    {9, {COORD_A8, COORD_A7, COORD_B6, COORD_C5, COORD_D4, COORD_E3, COORD_F2, COORD_G1, COORD_H1, COORD_NO}},

    
    {8, {COORD_A4, COORD_B4, COORD_C4, COORD_D4, COORD_E4, COORD_F4, COORD_G4, COORD_H4, COORD_NO, COORD_NO}},
    {8, {COORD_D1, COORD_D2, COORD_D3, COORD_D4, COORD_D5, COORD_D6, COORD_D7, COORD_D8, COORD_NO, COORD_NO}},
    {8, {COORD_A5, COORD_B5, COORD_C5, COORD_D5, COORD_E5, COORD_F5, COORD_G5, COORD_H5, COORD_NO, COORD_NO}},
    {8, {COORD_E1, COORD_E2, COORD_E3, COORD_E4, COORD_E5, COORD_E6, COORD_E7, COORD_E8, COORD_NO, COORD_NO}},

    
    {9, {COORD_A1, COORD_B1, COORD_C1, COORD_A2, COORD_B2, COORD_C2, COORD_A3, COORD_B3, COORD_C3, COORD_NO}},
    {9, {COORD_H1, COORD_G1, COORD_F1, COORD_H2, COORD_G2, COORD_F2, COORD_H3, COORD_G3, COORD_F3, COORD_NO}},
    {9, {COORD_A8, COORD_B8, COORD_C8, COORD_A7, COORD_B7, COORD_C7, COORD_A6, COORD_B6, COORD_C6, COORD_NO}},
    {9, {COORD_H8, COORD_G8, COORD_F8, COORD_H7, COORD_G7, COORD_F7, COORD_H6, COORD_G6, COORD_F6, COORD_NO}},

    
    {7, {COORD_B2, COORD_D1, COORD_E2, COORD_F3, COORD_G4, COORD_H5, COORD_G7, COORD_NO, COORD_NO, COORD_NO}},
    {7, {COORD_G2, COORD_H4, COORD_G5, COORD_F6, COORD_E7, COORD_D8, COORD_B7, COORD_NO, COORD_NO, COORD_NO}},
    {7, {COORD_G7, COORD_E8, COORD_D7, COORD_C6, COORD_B5, COORD_A4, COORD_B2, COORD_NO, COORD_NO, COORD_NO}},
    {7, {COORD_B7, COORD_A5, COORD_B4, COORD_C3, COORD_D2, COORD_E1, COORD_G2, COORD_NO, COORD_NO, COORD_NO}},

    
    {10, {COORD_A1, COORD_B2, COORD_C3, COORD_D4, COORD_E5, COORD_F6, COORD_G7, COORD_H8, COORD_A2, COORD_B1}},
    {10, {COORD_H8, COORD_G7, COORD_F6, COORD_E5, COORD_D4, COORD_C3, COORD_B2, COORD_A1, COORD_H7, COORD_G8}},
    {10, {COORD_H1, COORD_G2, COORD_F3, COORD_E4, COORD_D5, COORD_C6, COORD_B7, COORD_A8, COORD_H2, COORD_G1}},
    {10, {COORD_A8, COORD_B7, COORD_C6, COORD_D5, COORD_E4, COORD_F3, COORD_G2, COORD_H1, COORD_A7, COORD_B8}},
 
    
    {10, {COORD_B2, COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_G1, COORD_H1, COORD_G2}},
    {10, {COORD_B2, COORD_A1, COORD_A2, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A7, COORD_A8, COORD_B7}},
    {10, {COORD_B7, COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_G8, COORD_H8, COORD_G7}},
    {10, {COORD_G2, COORD_H1, COORD_H2, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H7, COORD_H8, COORD_G7}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_A2, COORD_B2, COORD_C2, COORD_A3, COORD_B3, COORD_A4}},
    {10, {COORD_H1, COORD_G1, COORD_F1, COORD_E1, COORD_H2, COORD_G2, COORD_F2, COORD_H3, COORD_G3, COORD_H4}},
    {10, {COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_A7, COORD_B7, COORD_C7, COORD_A6, COORD_B6, COORD_A5}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_E8, COORD_H7, COORD_G7, COORD_F7, COORD_H6, COORD_G6, COORD_H5}},

    
    {10, {COORD_A1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_H1, COORD_C2, COORD_D2, COORD_E2, COORD_F2}},
    {10, {COORD_A1, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A8, COORD_B3, COORD_B4, COORD_B5, COORD_B6}},
    {10, {COORD_A8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_H8, COORD_C7, COORD_D7, COORD_E7, COORD_F7}},
    {10, {COORD_H1, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H8, COORD_G3, COORD_G4, COORD_G5, COORD_G6}},

    
    {10, {COORD_A1, COORD_B2, COORD_C3, COORD_D4, COORD_B1, COORD_C2, COORD_D3, COORD_A2, COORD_B3, COORD_C4}},
    {10, {COORD_H1, COORD_G2, COORD_F3, COORD_E4, COORD_G1, COORD_F2, COORD_E3, COORD_H2, COORD_G3, COORD_F4}},
    {10, {COORD_A8, COORD_B7, COORD_C6, COORD_D5, COORD_B8, COORD_C7, COORD_D6, COORD_A7, COORD_B6, COORD_C5}},
    {10, {COORD_H8, COORD_G7, COORD_F6, COORD_E5, COORD_G8, COORD_F7, COORD_E6, COORD_H7, COORD_G6, COORD_F5}},

    
    {10, {COORD_C2, COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_F1, COORD_G1, COORD_H1, COORD_F2}},
    {10, {COORD_B3, COORD_A1, COORD_A2, COORD_A3, COORD_A4, COORD_A5, COORD_A6, COORD_A7, COORD_A8, COORD_B6}},
    {10, {COORD_C7, COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_F8, COORD_G8, COORD_H8, COORD_F7}},
    {10, {COORD_G3, COORD_H1, COORD_H2, COORD_H3, COORD_H4, COORD_H5, COORD_H6, COORD_H7, COORD_H8, COORD_G6}},

    
    {10, {COORD_A1, COORD_B1, COORD_C1, COORD_D1, COORD_E1, COORD_A2, COORD_B2, COORD_A3, COORD_A4, COORD_A5}},
    {10, {COORD_H1, COORD_G1, COORD_F1, COORD_E1, COORD_D1, COORD_H2, COORD_G2, COORD_H3, COORD_H4, COORD_H5}},
    {10, {COORD_A8, COORD_B8, COORD_C8, COORD_D8, COORD_E8, COORD_A7, COORD_B7, COORD_A6, COORD_A5, COORD_A4}},
    {10, {COORD_H8, COORD_G8, COORD_F8, COORD_E8, COORD_D8, COORD_H7, COORD_G7, COORD_H6, COORD_H5, COORD_H4}},

    
    {10, {COORD_A1, COORD_B1, COORD_A2, COORD_B2, COORD_C2, COORD_D2, COORD_B3, COORD_C3, COORD_B4, COORD_D4}},
    {10, {COORD_H1, COORD_G1, COORD_H2, COORD_G2, COORD_F2, COORD_E2, COORD_G3, COORD_F3, COORD_G4, COORD_E4}},
    {10, {COORD_A8, COORD_B8, COORD_A7, COORD_B7, COORD_C7, COORD_D7, COORD_B6, COORD_C6, COORD_B5, COORD_D5}},
    {10, {COORD_H8, COORD_G8, COORD_H7, COORD_G7, COORD_F7, COORD_E7, COORD_G6, COORD_F6, COORD_G5, COORD_E5}},

    
    {10, {COORD_C6, COORD_D6, COORD_D7, COORD_D8, COORD_C8, COORD_F8, COORD_E8, COORD_E7, COORD_E6, COORD_F6}},
    {10, {COORD_C3, COORD_C4, COORD_B4, COORD_A4, COORD_A3, COORD_A6, COORD_A5, COORD_B5, COORD_C5, COORD_C6}},
    {10, {COORD_F3, COORD_E3, COORD_E2, COORD_E1, COORD_F1, COORD_C1, COORD_D1, COORD_D2, COORD_D3, COORD_C3}},
    {10, {COORD_F6, COORD_F5, COORD_G5, COORD_H5, COORD_H6, COORD_H3, COORD_H4, COORD_G4, COORD_F4, COORD_F3}}
};

constexpr Coord_to_feature coord_to_feature[HW2] = {
    {15, {{12, P30}, {14, P38}, {23, P38}, {28, P32}, {29, P39}, {34, P31}, {35, P31}, {39, P39}, {42, P34}, {43, P34}, {47, P39}, {50, P31}, {51, P31}, {55, P39}, {59, P39}}}, 
    {11, {{ 3, P30}, { 6, P38}, {14, P37}, {23, P37}, {29, P30}, {34, P32}, {39, P38}, {47, P35}, {50, P32}, {55, P38}, {59, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 6, P37}, {11, P30}, {23, P36}, {34, P33}, {39, P37}, {42, P35}, {50, P33}, {55, P37}, {60, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{19, P30}, {26, P35}, {34, P34}, {39, P36}, {42, P36}, {50, P34}, {54, P35}, {55, P36}, {60, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{17, P30}, {25, P31}, {34, P35}, {38, P36}, {42, P37}, {50, P35}, {54, P36}, {55, P35}, {60, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 5, P31}, { 9, P30}, {22, P36}, {34, P36}, {38, P37}, {42, P38}, {50, P36}, {54, P37}, {60, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 1, P30}, { 5, P30}, {13, P31}, {22, P37}, {31, P30}, {34, P37}, {38, P38}, {46, P35}, {50, P37}, {54, P38}, {58, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {15, {{13, P30}, {15, P38}, {22, P38}, {30, P32}, {31, P39}, {33, P31}, {34, P38}, {38, P39}, {41, P34}, {42, P39}, {46, P39}, {49, P31}, {50, P38}, {54, P39}, {58, P39}}}, 
    {11, {{ 2, P30}, { 4, P30}, {12, P31}, {23, P35}, {29, P31}, {35, P32}, {39, P35}, {47, P32}, {51, P32}, {55, P34}, {59, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {14, {{ 2, P31}, { 3, P31}, { 5, P34}, {23, P34}, {24, P30}, {26, P36}, {28, P33}, {29, P38}, {34, P30}, {35, P30}, {39, P34}, {47, P38}, {55, P33}, {59, P36}, { 0, PNO}}}, 
    { 9, {{ 2, P32}, {11, P31}, {14, P36}, {23, P33}, {39, P33}, {42, P30}, {47, P34}, {50, P30}, {59, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 2, P33}, { 6, P36}, {19, P31}, {25, P32}, {42, P31}, {59, P34}, {60, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 2, P34}, { 5, P32}, {17, P31}, {26, P34}, {42, P32}, {58, P34}, {60, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 2, P35}, { 9, P31}, {13, P32}, {22, P33}, {38, P33}, {42, P33}, {46, P34}, {50, P39}, {58, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {14, {{ 1, P31}, { 2, P36}, { 6, P34}, {22, P34}, {25, P30}, {27, P36}, {30, P33}, {31, P38}, {33, P30}, {34, P39}, {38, P34}, {46, P38}, {54, P33}, {58, P36}, { 0, PNO}}}, 
    {11, {{ 2, P37}, { 7, P38}, {15, P37}, {22, P35}, {31, P31}, {33, P32}, {38, P35}, {46, P32}, {49, P32}, {54, P34}, {58, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 4, P31}, {10, P30}, {23, P32}, {35, P33}, {39, P32}, {43, P35}, {51, P33}, {55, P32}, {63, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 3, P32}, {10, P31}, {12, P32}, {23, P31}, {39, P31}, {43, P30}, {47, P31}, {51, P30}, {59, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{10, P32}, {11, P32}, {23, P30}, {25, P33}, {28, P34}, {29, P37}, {47, P37}, {59, P32}, {60, P30}, {63, P39}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 5, P33}, {10, P33}, {14, P35}, {19, P32}, {47, P33}, {60, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 6, P35}, {10, P34}, {13, P33}, {17, P32}, {46, P33}, {60, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 9, P32}, {10, P35}, {22, P30}, {26, P33}, {30, P34}, {31, P37}, {46, P37}, {58, P32}, {60, P39}, {61, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 1, P32}, {10, P36}, {15, P36}, {22, P31}, {38, P31}, {41, P30}, {46, P31}, {49, P30}, {58, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 7, P37}, {10, P37}, {22, P32}, {33, P33}, {38, P32}, {41, P35}, {49, P33}, {54, P32}, {61, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{18, P30}, {24, P31}, {35, P34}, {39, P30}, {43, P36}, {51, P34}, {53, P30}, {55, P31}, {63, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 3, P33}, { 4, P32}, {18, P31}, {25, P34}, {43, P31}, {59, P31}, {63, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 5, P35}, {11, P33}, {12, P33}, {18, P32}, {47, P30}, {63, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{13, P34}, {18, P33}, {19, P33}, {28, P35}, {29, P36}, {47, P36}, {59, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{14, P34}, {17, P33}, {18, P34}, {30, P35}, {31, P36}, {46, P36}, {58, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 6, P33}, { 9, P33}, {15, P35}, {18, P35}, {46, P30}, {61, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 1, P33}, { 7, P36}, {18, P36}, {26, P32}, {41, P31}, {58, P31}, {61, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{18, P37}, {27, P35}, {33, P34}, {38, P30}, {41, P36}, {49, P34}, {52, P30}, {54, P31}, {61, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{16, P30}, {25, P35}, {35, P35}, {37, P30}, {43, P37}, {51, P35}, {53, P31}, {55, P30}, {63, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 3, P34}, { 5, P36}, {16, P31}, {24, P32}, {43, P32}, {57, P31}, {63, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 4, P33}, {11, P34}, {13, P35}, {16, P32}, {45, P30}, {63, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{12, P34}, {16, P33}, {19, P34}, {30, P36}, {31, P35}, {45, P36}, {57, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{15, P34}, {16, P34}, {17, P34}, {28, P36}, {29, P35}, {44, P36}, {56, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 7, P35}, { 9, P34}, {14, P33}, {16, P35}, {44, P30}, {61, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 1, P34}, { 6, P32}, {16, P36}, {27, P34}, {41, P32}, {56, P31}, {61, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{16, P37}, {26, P31}, {33, P35}, {36, P30}, {41, P37}, {49, P35}, {52, P31}, {54, P30}, {61, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 5, P37}, { 8, P30}, {21, P32}, {35, P36}, {37, P32}, {43, P38}, {51, P36}, {53, P32}, {63, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 3, P35}, { 8, P31}, {13, P36}, {21, P31}, {37, P31}, {43, P33}, {45, P31}, {51, P39}, {57, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 8, P32}, {11, P35}, {21, P30}, {24, P33}, {30, P37}, {31, P34}, {45, P37}, {57, P32}, {62, P39}, {63, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 4, P35}, { 8, P33}, {15, P33}, {19, P35}, {45, P33}, {62, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 6, {{ 7, P33}, { 8, P34}, {12, P35}, {17, P35}, {44, P33}, {62, P31}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {10, {{ 8, P35}, { 9, P35}, {20, P30}, {27, P33}, {28, P37}, {29, P34}, {44, P37}, {56, P32}, {61, P39}, {62, P30}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 1, P35}, { 8, P36}, {14, P32}, {20, P31}, {36, P31}, {41, P33}, {44, P31}, {49, P39}, {56, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 6, P31}, { 8, P37}, {20, P32}, {33, P36}, {36, P32}, {41, P38}, {49, P36}, {52, P32}, {61, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 0, P30}, { 5, P38}, {13, P37}, {21, P35}, {30, P31}, {35, P37}, {37, P35}, {45, P32}, {51, P37}, {53, P34}, {57, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {14, {{ 0, P31}, { 3, P36}, { 4, P34}, {21, P34}, {25, P36}, {27, P30}, {30, P38}, {31, P33}, {32, P30}, {35, P39}, {37, P34}, {45, P38}, {53, P33}, {57, P36}, { 0, PNO}}}, 
    { 9, {{ 0, P32}, {11, P36}, {15, P32}, {21, P33}, {37, P33}, {40, P30}, {45, P34}, {48, P30}, {57, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 0, P33}, { 7, P32}, {19, P36}, {24, P34}, {40, P31}, {57, P34}, {62, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 7, {{ 0, P34}, { 4, P36}, {17, P36}, {27, P32}, {40, P32}, {56, P34}, {62, P32}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 0, P35}, { 9, P36}, {12, P36}, {20, P33}, {36, P33}, {40, P33}, {44, P34}, {48, P39}, {56, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {14, {{ 0, P36}, { 1, P36}, { 7, P34}, {20, P34}, {24, P36}, {26, P30}, {28, P38}, {29, P33}, {32, P39}, {33, P39}, {36, P34}, {44, P38}, {52, P33}, {56, P36}, { 0, PNO}}}, 
    {11, {{ 0, P37}, { 6, P30}, {14, P31}, {20, P35}, {28, P31}, {33, P37}, {36, P35}, {44, P32}, {49, P37}, {52, P34}, {56, P37}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {15, {{13, P38}, {15, P30}, {21, P38}, {30, P39}, {31, P32}, {32, P31}, {35, P38}, {37, P39}, {40, P34}, {43, P39}, {45, P39}, {48, P31}, {51, P38}, {53, P39}, {57, P39}}}, 
    {11, {{ 3, P37}, { 7, P30}, {15, P31}, {21, P37}, {30, P30}, {32, P32}, {37, P38}, {45, P35}, {48, P32}, {53, P38}, {57, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 7, P31}, {11, P37}, {21, P36}, {32, P33}, {37, P37}, {40, P35}, {48, P33}, {53, P37}, {62, P35}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{19, P37}, {27, P31}, {32, P34}, {37, P36}, {40, P36}, {48, P34}, {52, P35}, {53, P36}, {62, P36}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{17, P37}, {24, P35}, {32, P35}, {36, P36}, {40, P37}, {48, P35}, {52, P36}, {53, P35}, {62, P33}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    { 9, {{ 4, P37}, { 9, P37}, {20, P36}, {32, P36}, {36, P37}, {40, P38}, {48, P36}, {52, P37}, {62, P34}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {11, {{ 1, P37}, { 4, P38}, {12, P37}, {20, P37}, {28, P30}, {32, P37}, {36, P38}, {44, P35}, {48, P37}, {52, P38}, {56, P38}, { 0, PNO}, { 0, PNO}, { 0, PNO}, { 0, PNO}}}, 
    {15, {{12, P38}, {14, P30}, {20, P38}, {28, P39}, {29, P32}, {32, P38}, {33, P38}, {36, P39}, {40, P39}, {41, P39}, {44, P39}, {48, P38}, {49, P38}, {52, P39}, {56, P39}}}  
};

constexpr int pattern_starts[N_PATTERNS] = {
    1, 6562, 26245, 32806,              
    1, 6562,                            
    1, 2188,                            
    139969, 199018, 258067, 317116,     
    376165, 435214, 494263, 553312      
};


__m256i eval_lower_mask;
__m256i feature_to_coord_simd_mul[N_EVAL_VECTORS][MAX_PATTERN_CELLS - 1];
__m256i feature_to_coord_simd_cell[N_EVAL_VECTORS][MAX_PATTERN_CELLS][2];
__m256i coord_to_feature_simd[HW2][N_EVAL_VECTORS];
__m256i eval_move_unflipped_16bit[N_16BIT][N_SIMD_EVAL_FEATURE_GROUP][N_EVAL_VECTORS];
__m256i eval_simd_offsets_simple[N_EVAL_VECTORS_SIMPLE]; 
__m256i eval_simd_offsets_comp[N_EVAL_VECTORS_COMP * 2]; 




int16_t pattern_arr[N_PHASES][N_PATTERN_PARAMS];
int16_t eval_num_arr[N_PHASES][MAX_STONE_NUM];

int16_t pattern_move_ordering_end_arr[N_PATTERN_PARAMS_MO_END];

inline bool load_eval_file(const char* file, bool show_log) {
    if (show_log) {
        std::cerr << "evaluation file " << file << std::endl;
    }
    bool failed = false;
    std::vector<int16_t> unzipped_params = load_unzip_egev2(file, show_log, &failed);
    if (failed) {
        return false;
    }
    size_t param_idx = 0;
    for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
        pattern_arr[phase_idx][0] = 0; 
        std::memcpy(pattern_arr[phase_idx] + 1, &unzipped_params[param_idx], sizeof(short) * N_PATTERN_PARAMS_RAW);
        param_idx += N_PATTERN_PARAMS_RAW;
        std::memcpy(eval_num_arr[phase_idx], &unzipped_params[param_idx], sizeof(short) * MAX_STONE_NUM);
        param_idx += MAX_STONE_NUM;
    }
    
    for (int phase_idx = 0; phase_idx < N_PHASES; ++phase_idx) {
        for (int i = 1; i < N_PATTERN_PARAMS; ++i) {
            if (pattern_arr[phase_idx][i] < -SIMD_EVAL_MAX_VALUE) {
                std::cerr << "[ERROR] evaluation value too low. you can ignore this error. phase " << phase_idx << " index " << i << " found " << pattern_arr[phase_idx][i] << std::endl;
                pattern_arr[phase_idx][i] = -SIMD_EVAL_MAX_VALUE;
            }
            if (pattern_arr[phase_idx][i] > SIMD_EVAL_MAX_VALUE) {
                std::cerr << "[ERROR] evaluation value too high. you can ignore this error. phase " << phase_idx << " index " << i << " found " << pattern_arr[phase_idx][i] << std::endl;
                pattern_arr[phase_idx][i] = SIMD_EVAL_MAX_VALUE;
            }
            pattern_arr[phase_idx][i] += SIMD_EVAL_MAX_VALUE;
        }
    }
    return true;
}

inline bool load_eval_move_ordering_end_file(const char* file, bool show_log) {
    if (show_log) {
        std::cerr << "evaluation for move ordering end file " << file << std::endl;
    }
    FILE* fp;
    if (!file_open(&fp, file, "rb")) {
        std::cerr << "[ERROR] [FATAL] can't open eval " << file << std::endl;
        return false;
    }
    pattern_move_ordering_end_arr[0] = 0; 
    if (fread(pattern_move_ordering_end_arr + 1, 2, N_PATTERN_PARAMS_MO_END - 1, fp) < N_PATTERN_PARAMS_MO_END - 1) {
        std::cerr << "[ERROR] [FATAL] evaluation file for move ordering end broken" << std::endl;
        fclose(fp);
        return false;
    }
    
    for (int i = 1; i < N_PATTERN_PARAMS_MO_END; ++i) {
        if (pattern_move_ordering_end_arr[i] < -SIMD_EVAL_MAX_VALUE_MO_END) {
            std::cerr << "[ERROR] evaluation value too low. you can ignore this error. index " << i << " found " << pattern_move_ordering_end_arr[i] << std::endl;
            pattern_move_ordering_end_arr[i] = -SIMD_EVAL_MAX_VALUE_MO_END;
        }
        if (pattern_move_ordering_end_arr[i] > SIMD_EVAL_MAX_VALUE_MO_END) {
            std::cerr << "[ERROR] evaluation value too high. you can ignore this error. index " << i << " found " << pattern_move_ordering_end_arr[i] << std::endl;
            pattern_move_ordering_end_arr[i] = SIMD_EVAL_MAX_VALUE_MO_END;
        }
        pattern_move_ordering_end_arr[i] += SIMD_EVAL_MAX_VALUE_MO_END;
    }
    return true;
}

inline void pre_calculate_eval_constant() {
    { 
        int16_t f2c[16];
        for (int i = 0; i < N_EVAL_VECTORS; ++i) {
            for (int j = 0; j < MAX_PATTERN_CELLS - 1; ++j) {
                for (int k = 0; k < 16; ++k) {
                    f2c[k] = (j < feature_to_coord[i * 16 + k].n_cells - 1) ? 3 : 1;
                }
                feature_to_coord_simd_mul[i][j] = _mm256_set_epi16(
                    f2c[0], f2c[1], f2c[2], f2c[3], 
                    f2c[4], f2c[5], f2c[6], f2c[7], 
                    f2c[8], f2c[9], f2c[10], f2c[11], 
                    f2c[12], f2c[13], f2c[14], f2c[15]
                );
            }
        }
        int32_t f2c32[8];
        for (int i = 0; i < N_EVAL_VECTORS; ++i) {
            for (int j = 0; j < MAX_PATTERN_CELLS; ++j) {
                for (int k = 0; k < 8; ++k) {
                    f2c32[k] = feature_to_coord[i * 16 + k * 2 + 1].cells[j];
                }
                feature_to_coord_simd_cell[i][j][0] = _mm256_set_epi32(
                    f2c32[0], f2c32[1], f2c32[2], f2c32[3], 
                    f2c32[4], f2c32[5], f2c32[6], f2c32[7]
                );
                for (int k = 0; k < 8; ++k) {
                    f2c32[k] = feature_to_coord[i * 16 + k * 2].cells[j];
                }
                feature_to_coord_simd_cell[i][j][1] = _mm256_set_epi32(
                    f2c32[0], f2c32[1], f2c32[2], f2c32[3], 
                    f2c32[4], f2c32[5], f2c32[6], f2c32[7]
                );
            }
        }
        eval_simd_offsets_simple[0] = _mm256_set_epi16(
            (int16_t)pattern_starts[0], (int16_t)pattern_starts[0], (int16_t)pattern_starts[0], (int16_t)pattern_starts[0], 
            (int16_t)pattern_starts[1], (int16_t)pattern_starts[1], (int16_t)pattern_starts[1], (int16_t)pattern_starts[1], 
            (int16_t)pattern_starts[2], (int16_t)pattern_starts[2], (int16_t)pattern_starts[2], (int16_t)pattern_starts[2], 
            (int16_t)pattern_starts[3], (int16_t)pattern_starts[3], (int16_t)pattern_starts[3], (int16_t)pattern_starts[3]
        );
        eval_simd_offsets_simple[1] = _mm256_set_epi16(
            (int16_t)pattern_starts[4], (int16_t)pattern_starts[4], (int16_t)pattern_starts[4], (int16_t)pattern_starts[4], 
            (int16_t)pattern_starts[5], (int16_t)pattern_starts[5], (int16_t)pattern_starts[5], (int16_t)pattern_starts[5], 
            (int16_t)pattern_starts[6], (int16_t)pattern_starts[6], (int16_t)pattern_starts[6], (int16_t)pattern_starts[6], 
            (int16_t)pattern_starts[7], (int16_t)pattern_starts[7], (int16_t)pattern_starts[7], (int16_t)pattern_starts[7]
        );
    }
    { 
        uint16_t c2f[CEIL_N_PATTERN_FEATURES];
        for (int cell = 0; cell < HW2; ++cell) { 
            for (int i = 0; i < CEIL_N_PATTERN_FEATURES; ++i) {
                c2f[i] = 0;
            }
            for (int i = 0; i < coord_to_feature[cell].n_features; ++i) {
                c2f[coord_to_feature[cell].features[i].feature] = coord_to_feature[cell].features[i].x;
            }
            for (int i = 0; i < N_EVAL_VECTORS; ++i) {
                int idx = i * 16;
                coord_to_feature_simd[cell][i] = _mm256_set_epi16(
                    c2f[idx], c2f[idx + 1], c2f[idx + 2], c2f[idx + 3], 
                    c2f[idx + 4], c2f[idx + 5], c2f[idx + 6], c2f[idx + 7], 
                    c2f[idx + 8], c2f[idx + 9], c2f[idx + 10], c2f[idx + 11], 
                    c2f[idx + 12], c2f[idx + 13], c2f[idx + 14], c2f[idx + 15]
                );
            }
        }
        for (int bits = 0; bits < N_16BIT; ++bits) { 
            for (int group = 0; group < N_SIMD_EVAL_FEATURE_GROUP; ++group) { 
                for (int i = 0; i < CEIL_N_PATTERN_FEATURES; ++i) {
                    c2f[i] = 0;
                }
                for (int cell = 0; cell < N_SIMD_EVAL_FEATURE_CELLS; ++cell) {
                    if (1 & (bits >> cell)) {
                        int global_cell = group * N_SIMD_EVAL_FEATURE_CELLS + cell;
                        for (int i = 0; i < coord_to_feature[global_cell].n_features; ++i) {
                            c2f[coord_to_feature[global_cell].features[i].feature] += coord_to_feature[global_cell].features[i].x;
                        }
                    }
                }
                for (int simd_feature_idx = 0; simd_feature_idx < N_EVAL_VECTORS; ++simd_feature_idx) {
                    int idx = simd_feature_idx * 16;
                    eval_move_unflipped_16bit[bits][group][simd_feature_idx] = _mm256_set_epi16(
                        c2f[idx], c2f[idx + 1], c2f[idx + 2], c2f[idx + 3], 
                        c2f[idx + 4], c2f[idx + 5], c2f[idx + 6], c2f[idx + 7], 
                        c2f[idx + 8], c2f[idx + 9], c2f[idx + 10], c2f[idx + 11], 
                        c2f[idx + 12], c2f[idx + 13], c2f[idx + 14], c2f[idx + 15]
                    );
                }
            }
        }
        for (int i = 0; i < N_EVAL_VECTORS_COMP; ++i) {
            int i4 = i * 4;
            eval_simd_offsets_comp[i * 2] = _mm256_set_epi32(
                pattern_starts[10 + i4], pattern_starts[10 + i4], pattern_starts[10 + i4], pattern_starts[10 + i4], 
                pattern_starts[11 + i4], pattern_starts[11 + i4], pattern_starts[11 + i4], pattern_starts[11 + i4]
            );
            eval_simd_offsets_comp[i * 2 + 1] = _mm256_set_epi32(
                pattern_starts[8 + i4], pattern_starts[8 + i4], pattern_starts[8 + i4], pattern_starts[8 + i4], 
                pattern_starts[9 + i4], pattern_starts[9 + i4], pattern_starts[9 + i4], pattern_starts[9 + i4]
            );
        }
        eval_lower_mask = _mm256_set1_epi32(0x0000FFFF);
    }
}


inline bool evaluate_init(const char* file, const char* mo_end_nws_file, bool show_log) {
    bool eval_loaded = load_eval_file(file, show_log);
    if (!eval_loaded) {
        std::cerr << "[ERROR] [FATAL] evaluation file not loaded" << std::endl;
        return false;
    }
    bool eval_move_ordering_end_nws_loaded = load_eval_move_ordering_end_file(mo_end_nws_file, show_log);
    if (!eval_move_ordering_end_nws_loaded) {
        std::cerr << "[ERROR] [FATAL] evaluation file for move ordering end not loaded" << std::endl;
        return false;
    }
    pre_calculate_eval_constant();
    if (show_log) {
        std::cerr << "evaluation function initialized" << std::endl;
    }
    return true;
}


bool evaluate_init(const std::string file, std::string mo_end_nws_file, bool show_log) {
    return evaluate_init(file.c_str(), mo_end_nws_file.c_str(), show_log);
}


bool evaluate_init(bool show_log) {
    return evaluate_init(EXE_DIRECTORY_PATH + "resources/eval.egev2", EXE_DIRECTORY_PATH + "resources/eval_move_ordering_end.egev", show_log);
}


inline __m256i calc_idx8_comp(const __m128i feature, const int i) {
    return _mm256_add_epi32(_mm256_cvtepu16_epi32(feature), eval_simd_offsets_comp[i]);
}

inline __m256i gather_eval(const int *start_addr, const __m256i idx8) {
    return _mm256_i32gather_epi32(start_addr, idx8, 2); 
    
}

inline int calc_pattern(const int phase_idx, Eval_features *features) {
    const int *start_addr0 = (int*)pattern_arr[phase_idx];
    const int *start_addr4 = (int*)&pattern_arr[phase_idx][PATTERN4_START_IDX];
    const int *start_addr6 = (int*)&pattern_arr[phase_idx][PATTERN6_START_IDX];
    __m256i res256 =                  gather_eval(start_addr0, _mm256_cvtepu16_epi32(features->f128[0]));   
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr0, _mm256_cvtepu16_epi32(features->f128[1])));  
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr6, _mm256_cvtepu16_epi32(features->f128[2])));  
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr4, _mm256_cvtepu16_epi32(features->f128[3])));  
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr0, calc_idx8_comp(features->f128[4], 0)));      
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr0, calc_idx8_comp(features->f128[5], 1)));      
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr0, calc_idx8_comp(features->f128[6], 2)));      
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr0, calc_idx8_comp(features->f128[7], 3)));      
    res256 = _mm256_and_si256(res256, eval_lower_mask);
    __m128i res128 = _mm_add_epi32(_mm256_castsi256_si128(res256), _mm256_extracti128_si256(res256, 1));
    res128 = _mm_hadd_epi32(res128, res128);
    return _mm_cvtsi128_si32(res128) + _mm_extract_epi32(res128, 1) - SIMD_EVAL_MAX_VALUE * N_PATTERN_FEATURES;
}

inline int calc_pattern_move_ordering_end(Eval_features *features) {
    const int *start_addr = (int*)(pattern_move_ordering_end_arr - SHIFT_EVAL_MO_END);
    __m256i res256 =                  gather_eval(start_addr, calc_idx8_comp(features->f128[4], 0));        
    res256 = _mm256_add_epi32(res256, gather_eval(start_addr, calc_idx8_comp(features->f128[5], 1)));       
    res256 = _mm256_and_si256(res256, eval_lower_mask);
    __m128i res128 = _mm_add_epi32(_mm256_castsi256_si128(res256), _mm256_extracti128_si256(res256, 1));
    res128 = _mm_hadd_epi32(res128, res128);
    return _mm_cvtsi128_si32(res128) + _mm_extract_epi32(res128, 1) - SIMD_EVAL_MAX_VALUE_MO_END * N_PATTERN_FEATURES_MO_END;
}

inline void calc_eval_features(Board *board, Eval_search *eval);


inline int mid_evaluate(Board *board) {
    Search search(board);
    calc_eval_features(&(search.board), &(search.eval));
    int phase_idx, num0;
    phase_idx = search.phase();
    num0 = pop_count_ull(search.board.player);
    int res = calc_pattern(phase_idx, &search.eval.features[search.eval.feature_idx]) + eval_num_arr[phase_idx][num0];
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    res = std::clamp(res, -SCORE_MAX, SCORE_MAX);
    return res;
}


inline int mid_evaluate_diff(Search *search) {
    int phase_idx, num0;
    phase_idx = search->phase();
    num0 = pop_count_ull(search->board.player);
    int res = calc_pattern(phase_idx, &search->eval.features[search->eval.feature_idx]) + eval_num_arr[phase_idx][num0];
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    res = std::clamp(res, -SCORE_MAX, SCORE_MAX);
    return res;
}


inline int mid_evaluate_move_ordering_end(Search *search) {
    int res = calc_pattern_move_ordering_end(&search->eval.features[search->eval.feature_idx]);
    res += res >= 0 ? STEP_2 : -STEP_2;
    res /= STEP;
    return res;
}

inline void calc_feature_vector(__m256i &f, const int *b_arr_int, const int i, const int n) {
    f = _mm256_set1_epi16(0);
    for (int j = 0; j < n; ++j) { 
        f = _mm256_add_epi16(f, _mm256_i32gather_epi32(b_arr_int, feature_to_coord_simd_cell[i][j][0], 4));
        f = _mm256_add_epi16(f, _mm256_slli_epi32(_mm256_i32gather_epi32(b_arr_int, feature_to_coord_simd_cell[i][j][1], 4), 16));
        f = _mm256_mullo_epi16(f, feature_to_coord_simd_mul[i][j]);
    }
    f = _mm256_add_epi16(f, _mm256_i32gather_epi32(b_arr_int, feature_to_coord_simd_cell[i][n][0], 4));
    f = _mm256_add_epi16(f, _mm256_slli_epi32(_mm256_i32gather_epi32(b_arr_int, feature_to_coord_simd_cell[i][n][1], 4), 16));
}


inline void calc_eval_features(Board *board, Eval_search *eval) {
    int b_arr_int[HW2 + 1];
    board->translate_to_arr_player_rev(b_arr_int);
    b_arr_int[COORD_NO] = 0;
    calc_feature_vector(eval->features[0].f256[0], b_arr_int, 0, MAX_N_CELLS_GROUP[0] - 1);
    calc_feature_vector(eval->features[0].f256[1], b_arr_int, 1, MAX_N_CELLS_GROUP[1] - 1);
    calc_feature_vector(eval->features[0].f256[2], b_arr_int, 2, MAX_N_CELLS_GROUP[2] - 1);
    calc_feature_vector(eval->features[0].f256[3], b_arr_int, 3, MAX_N_CELLS_GROUP[3] - 1);
    eval->feature_idx = 0;
    eval->features[eval->feature_idx].f256[0] = _mm256_add_epi16(eval->features[eval->feature_idx].f256[0], eval_simd_offsets_simple[0]); 
    eval->features[eval->feature_idx].f256[1] = _mm256_add_epi16(eval->features[eval->feature_idx].f256[1], eval_simd_offsets_simple[1]); 
}


inline void eval_move(Eval_search *eval, const Flip *flip, const Board *board) {
    const uint16_t *flipped_group = (uint16_t*)&(flip->flip);
    const uint16_t *player_group = (uint16_t*)&(board->player);
    const uint16_t *opponent_group = (uint16_t*)&(board->opponent);
    __m256i f0, f1, f2, f3;
    uint16_t unflipped_p;
    uint16_t unflipped_o;
    
    f0 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[0], coord_to_feature_simd[flip->pos][0]);
    f1 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[1], coord_to_feature_simd[flip->pos][1]);
    f2 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[2], coord_to_feature_simd[flip->pos][2]);
    f3 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[3], coord_to_feature_simd[flip->pos][3]);
    for (int i = 0; i < HW2 / 16; ++i) { 
        
        unflipped_p = ~flipped_group[i] & player_group[i];
        f0 = _mm256_add_epi16(f0, eval_move_unflipped_16bit[unflipped_p][i][0]);
        f1 = _mm256_add_epi16(f1, eval_move_unflipped_16bit[unflipped_p][i][1]);
        f2 = _mm256_add_epi16(f2, eval_move_unflipped_16bit[unflipped_p][i][2]);
        f3 = _mm256_add_epi16(f3, eval_move_unflipped_16bit[unflipped_p][i][3]);
        
        unflipped_o = ~flipped_group[i] & opponent_group[i];
        f0 = _mm256_sub_epi16(f0, eval_move_unflipped_16bit[unflipped_o][i][0]);
        f1 = _mm256_sub_epi16(f1, eval_move_unflipped_16bit[unflipped_o][i][1]);
        f2 = _mm256_sub_epi16(f2, eval_move_unflipped_16bit[unflipped_o][i][2]);
        f3 = _mm256_sub_epi16(f3, eval_move_unflipped_16bit[unflipped_o][i][3]);
    }
    ++eval->feature_idx;
    eval->features[eval->feature_idx].f256[0] = f0;
    eval->features[eval->feature_idx].f256[1] = f1;
    eval->features[eval->feature_idx].f256[2] = f2;
    eval->features[eval->feature_idx].f256[3] = f3;
}


inline void eval_undo(Eval_search *eval) {
    --eval->feature_idx;
}


inline void eval_pass(Eval_search *eval, const Board *board) {
    const uint16_t *player_group = (uint16_t*)&(board->player);
    const uint16_t *opponent_group = (uint16_t*)&(board->opponent);
    __m256i f0, f1, f2, f3;
    f0 = eval->features[eval->feature_idx].f256[0];
    f1 = eval->features[eval->feature_idx].f256[1];
    f2 = eval->features[eval->feature_idx].f256[2];
    f3 = eval->features[eval->feature_idx].f256[3];
    for (int i = 0; i < HW2 / 16; ++i) { 
        f0 = _mm256_add_epi16(f0, eval_move_unflipped_16bit[player_group[i]][i][0]);
        f1 = _mm256_add_epi16(f1, eval_move_unflipped_16bit[player_group[i]][i][1]);
        f2 = _mm256_add_epi16(f2, eval_move_unflipped_16bit[player_group[i]][i][2]);
        f3 = _mm256_add_epi16(f3, eval_move_unflipped_16bit[player_group[i]][i][3]);
        f0 = _mm256_sub_epi16(f0, eval_move_unflipped_16bit[opponent_group[i]][i][0]);
        f1 = _mm256_sub_epi16(f1, eval_move_unflipped_16bit[opponent_group[i]][i][1]);
        f2 = _mm256_sub_epi16(f2, eval_move_unflipped_16bit[opponent_group[i]][i][2]);
        f3 = _mm256_sub_epi16(f3, eval_move_unflipped_16bit[opponent_group[i]][i][3]);
    }
    eval->features[eval->feature_idx].f256[0] = f0;
    eval->features[eval->feature_idx].f256[1] = f1;
    eval->features[eval->feature_idx].f256[2] = f2;
    eval->features[eval->feature_idx].f256[3] = f3;
}





inline void eval_move_endsearch(Eval_search *eval, const Flip *flip, const Board *board) {
    const uint16_t *flipped_group = (uint16_t*)&(flip->flip);
    const uint16_t *player_group = (uint16_t*)&(board->player);
    const uint16_t *opponent_group = (uint16_t*)&(board->opponent);
    
    __m256i f2 = _mm256_sub_epi16(eval->features[eval->feature_idx].f256[2], coord_to_feature_simd[flip->pos][2]);
    for (int i = 0; i < N_SIMD_EVAL_FEATURE_GROUP; ++i) {
        
        f2 = _mm256_add_epi16(f2, eval_move_unflipped_16bit[~flipped_group[i] & player_group[i]][i][2]);
        
        f2 = _mm256_sub_epi16(f2, eval_move_unflipped_16bit[~flipped_group[i] & opponent_group[i]][i][2]);
    }
    ++eval->feature_idx;
    eval->features[eval->feature_idx].f256[2] = f2;
}

inline void eval_undo_endsearch(Eval_search *eval) {
    --eval->feature_idx;
}

inline void eval_pass_endsearch(Eval_search *eval, const Board *board) {
    const uint16_t *player_group = (uint16_t*)&(board->player);
    const uint16_t *opponent_group = (uint16_t*)&(board->opponent);
    __m256i f2 = eval->features[eval->feature_idx].f256[2];
    for (int i = 0; i < N_SIMD_EVAL_FEATURE_GROUP; ++i) {
        f2 = _mm256_add_epi16(f2, eval_move_unflipped_16bit[player_group[i]][i][2]);
        f2 = _mm256_sub_epi16(f2, eval_move_unflipped_16bit[opponent_group[i]][i][2]);
    }
    eval->features[eval->feature_idx].f256[2] = f2;
}

// ===== FILE: Egaroucid/src/engine/flip_avx512.hpp =====



#pragma once
#include "setting.hpp"
#include "common_select.hpp"
#include "bit.hpp"

#if AUTO_FLIP_OPT_BY_COMPILER
#ifdef __clang_version__
#define ACEPCK_RIGHT true
#define ACEPCK_LEFT false
#elif defined __GNUC__
#define ACEPCK_RIGHT true
#define ACEPCK_LEFT false
#elif defined _MSC_VER

#define ACEPCK_RIGHT true
#define ACEPCK_LEFT false
#else
#define ACEPCK_RIGHT false
#define ACEPCK_LEFT false
#endif
#else
#define ACEPCK_RIGHT false
#define ACEPCK_LEFT false
#endif

union V8DI {
    uint64_t ull[8];
    __m256i v4[2];
    __m512i v8;
};
V8DI lrmask[HW2];


class Flip {

    public:
        uint_fast8_t pos;
        uint64_t flip;
    
    public:
        
        

        static inline __m128i calc_flip(__m128i OP, const uint_fast8_t place) {
            __m256i PP = _mm256_broadcastq_epi64(OP);
#if USE_AMD
            __m256i OO = _mm256_broadcastq_epi64(_mm_unpackhi_epi64(OP, OP)); 
#else
            __m256i OO = _mm256_permute4x64_epi64(_mm256_castsi128_si256(OP), 0x55); 
#endif
            __m256i rM = lrmask[place].v4[1];
            __m256i lM = lrmask[place].v4[0];
            __m256i lO = _mm256_andnot_si256(OO, lM);

#if ACEPCK_RIGHT
              
            __m256i rP = _mm256_and_si256(PP, rM);
            __m256i t0 = _mm256_srlv_epi64(_mm256_set1_epi64x(-1), _mm256_lzcnt_epi64(rP));
              
            
            __m256i rE = _mm256_ternarylogic_epi64(OO, rM, rP, 0x04);	
            __m256i F4 = _mm256_maskz_andnot_epi64(_mm256_cmpgt_epi64_mask(rP, rE), t0, rM);
#else
              
            __m256i t0 = _mm256_lzcnt_epi64(_mm256_andnot_si256(OO, rM));
            t0 = _mm256_and_si256(_mm256_srlv_epi64(_mm256_set1_epi64x(0x8000000000000000), t0), PP);
              
            
            __m256i F4 = _mm256_ternarylogic_epi64(_mm256_sub_epi64(_mm256_setzero_si256(), t0), t0, rM, 0x28);
#endif

#if ACEPCK_LEFT
            
            
            __m256i t2 = _mm256_ternarylogic_epi64(lM, _mm256_add_epi64(lO, _mm256_set1_epi64x(-1)), lO, 0x60);
              
            
            F4 = _mm256_mask_ternarylogic_epi64(F4, _mm256_test_epi64_mask(PP, t2), PP, t2, 0xf2);
#else
            
            
            lO = _mm256_ternarylogic_epi64(lO, _mm256_sub_epi64(_mm256_setzero_si256(), lO), PP, 0x80);
              
            __m256i lE = _mm256_sub_epi64(_mm256_cmpeq_epi64(lO, _mm256_setzero_si256()), lO);
            
            F4 = _mm256_ternarylogic_epi64(F4, lE, lM, 0xf2);
#endif

            __m128i F2 = _mm_or_si128(_mm256_castsi256_si128(F4), _mm256_extracti128_si256(F4, 1));
            return _mm_or_si128(F2, _mm_shuffle_epi32(F2, 0x4e));	
        }

        inline uint64_t calc_flip(const uint64_t player, const uint64_t opponent, const uint_fast8_t place) {
            pos = place;
            flip = _mm_cvtsi128_si64(calc_flip(_mm_set_epi64x(opponent, player), place));
            return flip;
        }
};


void flip_init() {
    for (int x = 0; x < 8; ++x) {
        __m256i lmask = _mm256_set_epi64x(
            (0x0102040810204080ULL >> ((7 - x) * 8)) & 0xffffffffffffff00ULL,
            (0x8040201008040201ULL >> (x * 8)) & 0xffffffffffffff00ULL,
            (0x0101010101010101ULL << x) & 0xffffffffffffff00ULL,
            (0xfe << x) & 0xff
        );
        __m256i rmask = _mm256_set_epi64x(
            (0x0102040810204080ULL << (x * 8)) & 0x00ffffffffffffffULL,
            (0x8040201008040201ULL << ((7 - x) * 8)) & 0x00ffffffffffffffULL,
            (0x0101010101010101ULL << x) & 0x00ffffffffffffffULL,
            (uint64_t)(0x7f >> (7 - x)) << 56
        );

        for (int y = 0; y < 8; ++y) {
            lrmask[y * 8 + x].v4[0] = lmask;
            lrmask[(7 - y) * 8 + x].v4[1] = rmask;
            lmask = _mm256_slli_epi64(lmask, 8);
            rmask = _mm256_srli_epi64(rmask, 8);
        }
    }
}

// ===== FILE: Egaroucid/src/engine/flip_generic.hpp =====



#pragma once
#include "setting.hpp"
#include "common_select.hpp"
#include "bit.hpp"

constexpr uint64_t bb_vline[8] = {
    0x0101010101010101ULL,
    0x0202020202020202ULL,
    0x0404040404040404ULL,
    0x0808080808080808ULL,
    0x1010101010101010ULL,
    0x2020202020202020ULL,
    0x4040404040404040ULL,
    0x8080808080808080ULL
};

constexpr uint64_t bb_mul16[8] = {
    0x0204081020408100ULL,
    0x0102040810204080ULL,
    0x0081020408102040ULL,
    0x0040810204081020ULL,
    0x0020408102040810ULL,
    0x0010204081020408ULL,
    0x0008102040810204ULL,
    0x0004081020408102ULL
};

constexpr uint64_t bb_dline02[64] = {
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0000000000000002ULL, 0x0000000000000005ULL, 0x000000000000000aULL, 0x0000000000000014ULL, 0x0000000000000028ULL, 0x0000000000000050ULL, 0x00000000000000a0ULL, 0x0000000000000040ULL,
    0x0000000000000204ULL, 0x0000000000000508ULL, 0x0000000000000a11ULL, 0x0000000000001422ULL, 0x0000000000002844ULL, 0x0000000000005088ULL, 0x000000000000a010ULL, 0x0000000000004020ULL,
    0x0000000000020408ULL, 0x0000000000050810ULL, 0x00000000000a1120ULL, 0x0000000000142241ULL, 0x0000000000284482ULL, 0x0000000000508804ULL, 0x0000000000a01008ULL, 0x0000000000402010ULL,
    0x0000000002040810ULL, 0x0000000005081020ULL, 0x000000000a112040ULL, 0x0000000014224180ULL, 0x0000000028448201ULL, 0x0000000050880402ULL, 0x00000000a0100804ULL, 0x0000000040201008ULL,
    0x0000000204081020ULL, 0x0000000508102040ULL, 0x0000000a11204080ULL, 0x0000001422418000ULL, 0x0000002844820100ULL, 0x0000005088040201ULL, 0x000000a010080402ULL, 0x0000004020100804ULL,
    0x0000020408102040ULL, 0x0000050810204080ULL, 0x00000a1120408000ULL, 0x0000142241800000ULL, 0x0000284482010000ULL, 0x0000508804020100ULL, 0x0000a01008040201ULL, 0x0000402010080402ULL,
    0x0002040810204080ULL, 0x0005081020408000ULL, 0x000a112040800000ULL, 0x0014224180000000ULL, 0x0028448201000000ULL, 0x0050880402010000ULL, 0x00a0100804020100ULL, 0x0040201008040201ULL
};

constexpr uint64_t bb_dline57[64] = {
    0x8040201008040200ULL, 0x0080402010080500ULL, 0x0000804020110a00ULL, 0x0000008041221400ULL, 0x0000000182442800ULL, 0x0000010204885000ULL, 0x000102040810a000ULL, 0x0102040810204000ULL,
    0x4020100804020000ULL, 0x8040201008050000ULL, 0x00804020110a0000ULL, 0x0000804122140000ULL, 0x0000018244280000ULL, 0x0001020488500000ULL, 0x0102040810a00000ULL, 0x0204081020400000ULL,
    0x2010080402000000ULL, 0x4020100805000000ULL, 0x804020110a000000ULL, 0x0080412214000000ULL, 0x0001824428000000ULL, 0x0102048850000000ULL, 0x02040810a0000000ULL, 0x0408102040000000ULL,
    0x1008040200000000ULL, 0x2010080500000000ULL, 0x4020110a00000000ULL, 0x8041221400000000ULL, 0x0182442800000000ULL, 0x0204885000000000ULL, 0x040810a000000000ULL, 0x0810204000000000ULL,
    0x0804020000000000ULL, 0x1008050000000000ULL, 0x20110a0000000000ULL, 0x4122140000000000ULL, 0x8244280000000000ULL, 0x0488500000000000ULL, 0x0810a00000000000ULL, 0x1020400000000000ULL,
    0x0402000000000000ULL, 0x0805000000000000ULL, 0x110a000000000000ULL, 0x2214000000000000ULL, 0x4428000000000000ULL, 0x8850000000000000ULL, 0x10a0000000000000ULL, 0x2040000000000000ULL,
    0x0200000000000000ULL, 0x0500000000000000ULL, 0x0a00000000000000ULL, 0x1400000000000000ULL, 0x2800000000000000ULL, 0x5000000000000000ULL, 0xa000000000000000ULL, 0x4000000000000000ULL,
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL
};

constexpr uint8_t bb_seed[64][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00},
    {0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00},
    {0x04, 0x00, 0x11, 0x00, 0x04, 0x00, 0x00, 0x00},
    {0x00, 0x10, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00},
    {0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x20, 0x00, 0x08, 0x00, 0x00},
    {0x04, 0x00, 0x01, 0x20, 0x00, 0x08, 0x00, 0x00},
    {0x00, 0x08, 0x00, 0x22, 0x00, 0x08, 0x00, 0x00},
    {0x08, 0x00, 0x00, 0x21, 0x00, 0x08, 0x00, 0x00},
    {0x00, 0x00, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00},
    {0x04, 0x00, 0x21, 0x00, 0x00, 0x04, 0x00, 0x00},
    {0x00, 0x20, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00},
    {0x20, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x10, 0x00},
    {0x04, 0x00, 0x01, 0x00, 0x40, 0x00, 0x10, 0x00},
    {0x00, 0x08, 0x00, 0x02, 0x40, 0x00, 0x10, 0x00},
    {0x08, 0x00, 0x00, 0x01, 0x40, 0x00, 0x10, 0x00},
    {0x00, 0x00, 0x10, 0x00, 0x44, 0x00, 0x10, 0x00},
    {0x04, 0x00, 0x11, 0x00, 0x44, 0x00, 0x10, 0x00},
    {0x00, 0x10, 0x00, 0x00, 0x42, 0x00, 0x10, 0x00},
    {0x10, 0x00, 0x00, 0x00, 0x41, 0x00, 0x10, 0x00},
    {0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x08, 0x00},
    {0x04, 0x00, 0x01, 0x40, 0x00, 0x00, 0x08, 0x00},
    {0x00, 0x08, 0x00, 0x42, 0x00, 0x00, 0x08, 0x00},
    {0x08, 0x00, 0x00, 0x41, 0x00, 0x00, 0x08, 0x00},
    {0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x04, 0x00},
    {0x04, 0x00, 0x41, 0x00, 0x00, 0x00, 0x04, 0x00},
    {0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00},
    {0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x20},
    {0x04, 0x00, 0x01, 0x00, 0x00, 0x80, 0x00, 0x20},
    {0x00, 0x08, 0x00, 0x02, 0x00, 0x80, 0x00, 0x20},
    {0x08, 0x00, 0x00, 0x01, 0x00, 0x80, 0x00, 0x20},
    {0x00, 0x00, 0x10, 0x00, 0x04, 0x80, 0x00, 0x20},
    {0x04, 0x00, 0x11, 0x00, 0x04, 0x80, 0x00, 0x20},
    {0x00, 0x10, 0x00, 0x00, 0x02, 0x80, 0x00, 0x20},
    {0x10, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x20},
    {0x00, 0x00, 0x00, 0x20, 0x00, 0x88, 0x00, 0x20},
    {0x04, 0x00, 0x01, 0x20, 0x00, 0x88, 0x00, 0x20},
    {0x00, 0x08, 0x00, 0x22, 0x00, 0x88, 0x00, 0x20},
    {0x08, 0x00, 0x00, 0x21, 0x00, 0x88, 0x00, 0x20},
    {0x00, 0x00, 0x20, 0x00, 0x00, 0x84, 0x00, 0x20},
    {0x04, 0x00, 0x21, 0x00, 0x00, 0x84, 0x00, 0x20},
    {0x00, 0x20, 0x00, 0x00, 0x00, 0x82, 0x00, 0x20},
    {0x20, 0x00, 0x00, 0x00, 0x00, 0x81, 0x00, 0x20},
    {0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x10},
    {0x04, 0x00, 0x01, 0x00, 0x80, 0x00, 0x00, 0x10},
    {0x00, 0x08, 0x00, 0x02, 0x80, 0x00, 0x00, 0x10},
    {0x08, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x10},
    {0x00, 0x00, 0x10, 0x00, 0x84, 0x00, 0x00, 0x10},
    {0x04, 0x00, 0x11, 0x00, 0x84, 0x00, 0x00, 0x10},
    {0x00, 0x10, 0x00, 0x00, 0x82, 0x00, 0x00, 0x10},
    {0x10, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x10},
    {0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x08},
    {0x04, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x08},
    {0x00, 0x08, 0x00, 0x82, 0x00, 0x00, 0x00, 0x08},
    {0x08, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x08},
    {0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x04},
    {0x04, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x04},
    {0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
    {0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01}
};

constexpr uint8_t bb_flipped[137][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x02, 0x06, 0x0e, 0x1e, 0x3e, 0x7e},
    {0x00, 0x00, 0x00, 0x04, 0x0c, 0x1c, 0x3c, 0x7c},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x02, 0x00, 0x00, 0x00, 0x08, 0x18, 0x38, 0x78},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x06, 0x04, 0x00, 0x00, 0x00, 0x10, 0x30, 0x70},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x0e, 0x0c, 0x08, 0x00, 0x00, 0x00, 0x20, 0x60},
    {0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x1e, 0x1c, 0x18, 0x10, 0x00, 0x00, 0x00, 0x40},
    {0x00, 0x00, 0x1a, 0x16, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x3e, 0x3c, 0x38, 0x30, 0x20, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x3a, 0x36, 0x2e, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x34, 0x2c, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x7e, 0x7c, 0x78, 0x70, 0x60, 0x40, 0x00, 0x00},
    {0x00, 0x00, 0x7a, 0x76, 0x6e, 0x5e, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x74, 0x6c, 0x5c, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x68, 0x58, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00}
};

constexpr uint64_t bb_h2vline[64] = {
    0x0000000000000000ULL, 0x0000000000000100ULL, 0x0000000000010000ULL, 0x0000000000010100ULL,
    0x0000000001000000ULL, 0x0000000001000100ULL, 0x0000000001010000ULL, 0x0000000001010100ULL,
    0x0000000100000000ULL, 0x0000000000000000ULL, 0x0000000100010000ULL, 0x0000000100010100ULL,
    0x0000000101000000ULL, 0x0000000101000100ULL, 0x0000000101010000ULL, 0x0000000101010100ULL,
    0x0000010000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0000010001000000ULL, 0x0000000000000000ULL, 0x0000010001010000ULL, 0x0000010001010100ULL,
    0x0000010100000000ULL, 0x0000000000000000ULL, 0x0000010100010000ULL, 0x0000010100010100ULL,
    0x0000010101000000ULL, 0x0000010101000100ULL, 0x0000010101010000ULL, 0x0000010101010100ULL,
    0x0001000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0001000100000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0001000101000000ULL, 0x0000000000000000ULL, 0x0001000101010000ULL, 0x0001000101010100ULL,
    0x0001010000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
    0x0001010001000000ULL, 0x0000000000000000ULL, 0x0001010001010000ULL, 0x0001010001010100ULL,
    0x0001010100000000ULL, 0x0000000000000000ULL, 0x0001010100010000ULL, 0x0001010100010100ULL,
    0x0001010101000000ULL, 0x0001010101000100ULL, 0x0001010101010000ULL, 0x0001010101010100ULL
};


class Flip {
    public:
        uint_fast8_t pos;
        uint64_t flip;
    
    public:
        inline uint64_t calc_flip(const uint64_t player, const uint64_t opponent, const int place) {
            pos = place;
            uint32_t x = place & 7;
            uint32_t y = place >> 3;

            auto flip_d = [&](const uint64_t a) {
                uint8_t outflank = bb_seed[((opponent & a) * bb_vline[1]) >> 58][x];
                outflank &= ((player & a) * 0x0101010101010101ULL) >> 56;
                return (bb_flipped[outflank][x] * 0x0101010101010101ULL) & a;
            };

            uint8_t outflank = (((player >> x) & 0x0101010101010101ULL) * 0x0102040810204080ULL) >> 56;
            outflank &= bb_seed[((opponent & bb_vline[x]) * bb_mul16[x]) >> 58][y];
            flip = *((uint64_t *) (((uint32_t *) bb_h2vline) + bb_flipped[outflank][y])) << x;

            outflank = ((uint8_t (*)[4]) bb_seed)[(opponent >> (place & 0x38)) & 0x7e][x];
            outflank &= player >> (place & 0x38);
            flip |= (uint64_t) bb_flipped[outflank][x] << (place & 0x38);

            flip |= flip_d(bb_dline02[place]);
            flip |= flip_d(bb_dline57[place]);

            return flip;
        }
};

void flip_init() {
}

// ===== FILE: Egaroucid/src/engine/flip.hpp =====



#pragma once
#include "setting.hpp"
#if USE_SIMD
#if USE_AVX512
#include "flip_avx512.hpp"
#else
#include "flip_simd.hpp"
#endif
#else
#include "flip_generic.hpp"
#endif

// ===== FILE: Egaroucid/src/engine/flip_simd.hpp =====



#pragma once
#include "setting.hpp"
#include "common_select.hpp"
#include "bit.hpp"

#if AUTO_FLIP_OPT_BY_COMPILER
#ifdef __clang_version__
#define ACEPCK_RIGHT true
#define ACEPCK_LEFT true
#elif defined __GNUC__
#define ACEPCK_RIGHT false
#define ACEPCK_LEFT true
#elif defined _MSC_VER
#define ACEPCK_RIGHT true
#define ACEPCK_LEFT false
#else
#define ACEPCK_RIGHT false
#define ACEPCK_LEFT false
#endif
#else
#define ACEPCK_RIGHT false
#define ACEPCK_LEFT false
#endif

union V8DI {
    uint64_t ull[8];
    __m256i v4[2];
};
V8DI lrmask[HW2];


class Flip {

    public:
        uint_fast8_t pos;
        uint64_t flip;
    
    public:
        
        

        static inline __m128i calc_flip(__m128i OP, const uint_fast8_t place) {
            __m256i PP = _mm256_broadcastq_epi64(OP);
#if USE_AMD
            __m256i OO = _mm256_broadcastq_epi64(_mm_unpackhi_epi64(OP, OP)); 
#else
            __m256i OO = _mm256_permute4x64_epi64(_mm256_castsi128_si256(OP), 0x55); 
#endif
            __m256i mask = lrmask[place].v4[1];
        
#if ACEPCK_RIGHT
              
            __m256i rP = _mm256_and_si256(PP, mask);
            __m256i rS = _mm256_or_si256(rP, _mm256_srlv_epi64(rP, _mm256_set_epi64x(7, 9, 8, 1)));
            rS = _mm256_or_si256(rS, _mm256_srlv_epi64(rS, _mm256_set_epi64x(14, 18, 16, 2)));
            rS = _mm256_or_si256(rS, _mm256_srlv_epi64(rS, _mm256_set_epi64x(28, 36, 32, 4)));
              
            __m256i rE = _mm256_xor_si256(_mm256_andnot_si256(OO, mask), rP);	
            __m256i F4 = _mm256_and_si256(_mm256_andnot_si256(rS, mask), _mm256_cmpgt_epi64(rP, rE));
#else
              
            __m256i eraser = _mm256_andnot_si256(OO, mask);
            __m256i rO = _mm256_sllv_epi64(_mm256_and_si256(PP, mask), _mm256_set_epi64x(7, 9, 8, 1));
            eraser = _mm256_or_si256(eraser, _mm256_srlv_epi64(eraser, _mm256_set_epi64x(7, 9, 8, 1)));
            rO = _mm256_andnot_si256(eraser, rO);
            rO = _mm256_andnot_si256(_mm256_srlv_epi64(eraser, _mm256_set_epi64x(14, 18, 16, 2)), rO);
            rO = _mm256_andnot_si256(_mm256_srlv_epi64(eraser, _mm256_set_epi64x(28, 36, 32, 4)), rO);
              
            __m256i F4 = _mm256_and_si256(mask, _mm256_sub_epi64(_mm256_setzero_si256(), rO));
#endif

            mask = lrmask[place].v4[0];
            __m256i lO = _mm256_andnot_si256(OO, mask);
#if ACEPCK_LEFT
              
            lO = _mm256_and_si256(_mm256_xor_si256(_mm256_add_epi64(lO, _mm256_set1_epi64x(-1)), lO), mask);
              
            __m256i lF = _mm256_andnot_si256(PP, lO);
              
            F4 = _mm256_or_si256(F4, _mm256_andnot_si256(_mm256_cmpeq_epi64(lF, lO), lF));
#else
              
            lO = _mm256_and_si256(lO, _mm256_sub_epi64(_mm256_setzero_si256(), lO));  
            lO = _mm256_and_si256(lO, PP);
              
            __m256i lF = _mm256_sub_epi64(_mm256_cmpeq_epi64(lO, _mm256_setzero_si256()), lO);
            F4 = _mm256_or_si256(F4, _mm256_andnot_si256(lF, mask));
#endif

            __m128i F2 = _mm_or_si128(_mm256_castsi256_si128(F4), _mm256_extracti128_si256(F4, 1));
            return _mm_or_si128(F2, _mm_shuffle_epi32(F2, 0x4e));	
        }

        inline uint64_t calc_flip(const uint64_t player, const uint64_t opponent, const uint_fast8_t place) {
            pos = place;
            flip = _mm_cvtsi128_si64(calc_flip(_mm_set_epi64x(opponent, player), place));
            return flip;
        }
};


void flip_init() {
    for (int x = 0; x < 8; ++x) {
        __m256i lmask = _mm256_set_epi64x(
            (0x0102040810204080ULL >> ((7 - x) * 8)) & 0xffffffffffffff00ULL,
            (0x8040201008040201ULL >> (x * 8)) & 0xffffffffffffff00ULL,
            (0x0101010101010101ULL << x) & 0xffffffffffffff00ULL,
            (0xfe << x) & 0xff
        );
        __m256i rmask = _mm256_set_epi64x(
            (0x0102040810204080ULL << (x * 8)) & 0x00ffffffffffffffULL,
            (0x8040201008040201ULL << ((7 - x) * 8)) & 0x00ffffffffffffffULL,
            (0x0101010101010101ULL << x) & 0x00ffffffffffffffULL,
            (uint64_t)(0x7f >> (7 - x)) << 56
        );

        for (int y = 0; y < 8; ++y) {
            lrmask[y * 8 + x].v4[0] = lmask;
            lrmask[(7 - y) * 8 + x].v4[1] = rmask;
            lmask = _mm256_slli_epi64(lmask, 8);
            rmask = _mm256_srli_epi64(rmask, 8);
        }
    }
}

// ===== FILE: Egaroucid/src/engine/hash.hpp =====



#pragma once
#include <iostream>
#include "common_select.hpp"


constexpr int N_HASH_LEVEL = 33; 
constexpr int DEFAULT_HASH_LEVEL = 25;

#if USE_CHANGEABLE_HASH_LEVEL
int global_hash_level = DEFAULT_HASH_LEVEL;
constexpr int MIN_HASH_LEVEL = 25;
int MAX_HASH_LEVEL = 30; 
#endif


uint32_t hash_rand_player[4][65536];
uint32_t hash_rand_opponent[4][65536];


constexpr size_t hash_sizes[N_HASH_LEVEL] = {
    1,
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    256,
    512,
    1024,
    2048,
    4096,
    8192,
    16384,
    32768,
    65536,
    131072,
    262144,
    524288,
    1048576,
    2097152,
    4194304,
    8388608,
    16777216,
    33554432,
    67108864,
    134217728,
    268435456,
    536870912,
    1073741824,
    2147483648,
    4294967296
};


void hash_init_rand(int hash_level) {
    int i, j;
    for (i = 0; i < 4; ++i) {
        for (j = 0; j < 65536; ++j) {
            hash_rand_player[i][j] = 0;
            while (pop_count_uint(hash_rand_player[i][j]) < hash_level / 6) {
                hash_rand_player[i][j] = myrand_uint_rev() & (hash_sizes[hash_level] - 1);
            }
            hash_rand_opponent[i][j] = 0;
            while (pop_count_uint(hash_rand_opponent[i][j]) < hash_level / 6) {
                hash_rand_opponent[i][j] = myrand_uint_rev() & (hash_sizes[hash_level] - 1);
            }
        }
    }
}


bool hash_init(int hash_level) {
    FILE* fp;
    if (!file_open(&fp, (EXE_DIRECTORY_PATH + "resources/hash/hash" + std::to_string(hash_level) + ".eghs").c_str(), "rb")) {
        std::cerr << "[ERROR] can't open hash" + std::to_string(hash_level) + ".eghs" << std::endl;
        return false;
    }
    for (int i = 0; i < 4; ++i) {
        if (fread(hash_rand_player[i], 4, 65536, fp) < 65536) {
            std::cerr << "[ERROR] hash" + std::to_string(hash_level) + ".eghs broken" << std::endl;
            return false;
        }
    }
    for (int i = 0; i < 4; ++i) {
        if (fread(hash_rand_opponent[i], 4, 65536, fp) < 65536) {
            std::cerr << "[ERROR] hash" + std::to_string(hash_level) + ".eghs broken" << std::endl;
            return false;
        }
    }
    return true;
}


bool hash_init(int hash_level, std::string binary_path) {
    FILE* fp;
    if (!file_open(&fp, (binary_path + "resources/hash/hash" + std::to_string(hash_level) + ".eghs").c_str(), "rb")) {
        std::cerr << "[ERROR] can't open hash" + std::to_string(hash_level) + ".eghs" << std::endl;
        return false;
    }
    for (int i = 0; i < 4; ++i) {
        if (fread(hash_rand_player[i], 4, 65536, fp) < 65536) {
            std::cerr << "[ERROR] hash" + std::to_string(hash_level) + ".eghs broken" << std::endl;
            return false;
        }
    }
    for (int i = 0; i < 4; ++i) {
        if (fread(hash_rand_opponent[i], 4, 65536, fp) < 65536) {
            std::cerr << "[ERROR] hash" + std::to_string(hash_level) + ".eghs broken" << std::endl;
            return false;
        }
    }
    return true;
}

// ===== FILE: Egaroucid/src/engine/human_like_ai.hpp =====



#pragma once
#include <iostream>
#include <future>
#include <random>
#include "level.hpp"
#include "setting.hpp"
#include "util.hpp"
#include "search.hpp"
#include "evaluate.hpp"
#include "move_ordering.hpp"
#include "transposition_table.hpp"

std::random_device seed_gen;
std::mt19937 engine(seed_gen());
std::uniform_int_distribution<uint64_t> dist(0, 0xFFFFFFFFFFFFFFFFULL);

void noise_flip(Flip *flip, int depth) {
    uint64_t mask = flip->flip;
    int n_masked = pop_count_ull(flip->flip);
    for (int i = 0; i < depth + 2; ++i) { 
        uint64_t n_mask = flip->flip & dist(engine);
        int n_n_masked = pop_count_ull(n_mask);
        if (n_n_masked <= n_masked) {
            mask = n_mask;
            n_masked = n_n_masked;
        }
    }
    flip->flip ^= mask; 
}

int nega_alpha_human_like(Search *search, int alpha, int beta, int depth, bool skipped, bool is_end_search, bool *searching) {
    if (!(*searching) || !global_searching) {
        return SCORE_UNDEFINED;
    }
    ++search->n_nodes;
    if (depth == 0) {
        if (is_end_search) {
            return end_evaluate(&search->board);
        } else {
            return mid_evaluate_diff(search);
        }
    }
    uint64_t legal = search->board.get_legal();
    if (legal == 0) {
        if (skipped) {
            return end_evaluate(&search->board);
        }
        search->pass();
            int v = -nega_alpha_human_like(search, -beta, -alpha, depth, true, is_end_search, searching);
        search->pass();
        return v;
    }
    int canput = pop_count_ull(legal);
    std::vector<Flip_value> move_list(canput);
    int idx = 0;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&move_list[idx].flip, &search->board, cell);
        noise_flip(&move_list[idx].flip, depth);
        ++idx;
    }
    uint_fast8_t moves[N_TRANSPOSITION_MOVES] = {MOVE_UNDEFINED, MOVE_UNDEFINED};
    move_list_evaluate(search, move_list, moves, depth, alpha, beta, searching);
    if (beta <= alpha) {
        return alpha;
    }
    int g, v = -SCORE_INF;
    for (int move_idx = 0; move_idx < canput && *searching; ++move_idx) {
        swap_next_best_move(move_list, move_idx, canput);
        search->move(&move_list[move_idx].flip);
            g = -nega_alpha_human_like(search, -beta, -alpha, depth - 1, false, is_end_search, searching);
        search->undo(&move_list[move_idx].flip);
        if (v < g) {
            v = g;
            if (alpha < v) {
                if (beta <= v) {
                    break;
                }
                alpha = v;
            }
        }
    }
    return v;
}

Search_result nega_alpha_human_like_root(Search *search, int alpha, int beta, int depth, bool is_end_search, bool *searching) {
    Search_result res;
    if (!(*searching) || !global_searching || depth <= 0) {
        res.value = SCORE_UNDEFINED;
        res.policy = MOVE_NOMOVE;
        return res;
    }
    uint64_t legal = search->board.get_legal();
    if (legal == 0) {
        res.value = SCORE_UNDEFINED;
        res.policy = MOVE_NOMOVE;
        return res;
    }
    int canput = pop_count_ull(legal);
    std::vector<Flip_value> move_list(canput);
    int idx = 0;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&move_list[idx].flip, &search->board, cell);
        
        ++idx;
    }
    uint_fast8_t moves[N_TRANSPOSITION_MOVES] = {MOVE_UNDEFINED, MOVE_UNDEFINED};
    move_list_evaluate(search, move_list, moves, depth, alpha, beta, searching);
    int g;
    res.value = -SCORE_INF;
    res.policy = MOVE_NOMOVE;
    for (int move_idx = 0; move_idx < canput && *searching; ++move_idx) {
        swap_next_best_move(move_list, move_idx, canput);
        search->move(&move_list[move_idx].flip);
            g = -nega_alpha_human_like(search, -beta, -alpha, depth - 1, false, is_end_search, searching);
        search->undo(&move_list[move_idx].flip);
        std::cerr << "human like ai move " << move_idx + 1 << "/" << canput << " value " << g << " policy " << idx_to_coord(move_list[move_idx].flip.pos) << " window " << "[" << alpha << "," << beta << "] " << std::endl;
        if (res.value < g) {
            res.value = g;
            res.policy = move_list[move_idx].flip.pos;
            if (alpha < res.value) {
                if (beta <= res.value) {
                    break;
                }
                alpha = res.value;
            }
        }
    }
    return res;
}

Search_result human_like_ai(Board board, int level, bool show_log) {
    int value_sign = 1;
    Search_result res;
    if (board.get_legal() == 0ULL) {
        board.pass();
        if (board.get_legal() == 0ULL) {
            res.policy = 64;
            res.value = -board.score_player();
            res.depth = 0;
            res.nps = 0;
            res.is_end_search = true;
            res.probability = 100;
            return res;
        } else {
            value_sign = -1;
        }
    }
    int depth;
    bool is_mid_search;
    uint_fast8_t mpc_level;
    get_level(level, board.n_discs() - 4, &is_mid_search, &depth, &mpc_level);
    Search search(&board, mpc_level, false, false);
    bool searching = true;
    uint64_t strt = tim();
    res = nega_alpha_human_like_root(&search, -SCORE_MAX, SCORE_MAX, depth, !is_mid_search, &searching);
    res.value *= value_sign;
    res.time = tim() - strt;
    res.nps = calc_nps(res.nodes, res.time);
    res.depth = depth;
    res.is_end_search = !is_mid_search;
    res.probability = 100;
    res.clog_nodes = 0;
    res.clog_time = 0;
    if (show_log) {
        std::cerr << "human like ai value " << res.value << " policy " << idx_to_coord(res.policy) << std::endl;
    }
    return res;
}

// ===== FILE: Egaroucid/src/engine/last_flip_generic.hpp =====



#pragma once
#include "setting.hpp"
#include "common_select.hpp"
#include "bit.hpp"



#if LAST_FLIP_PASS_OPT


constexpr uint16_t N_LAST_FLIP_BOTH[N_8BIT][HW] = {
    {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006}, 
    {0x0100, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005}, {0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005}, 
    {0x0001, 0x0100, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003, 0x0004}, {0x0000, 0x0100, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003, 0x0004}, 
    {0x0200, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002, 0x0003, 0x0004}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0003, 0x0004}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002, 0x0003}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002, 0x0003}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001, 0x0002, 0x0003}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0003}, 
    {0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0100, 0x0001, 0x0002}, {0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0100, 0x0001, 0x0002}, 
    {0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100, 0x0001, 0x0002}, {0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0100, 0x0001, 0x0002}, 
    {0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001, 0x0002}, {0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001, 0x0002}, 
    {0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100, 0x0001, 0x0002}, {0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0001, 0x0002}, 
    {0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002}, {0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002}, 
    {0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002}, {0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002}, 
    {0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001, 0x0002}, {0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001, 0x0002}, 
    {0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0001, 0x0002}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002}, 
    {0x0004, 0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0003, 0x0003, 0x0003, 0x0103, 0x0000, 0x0100, 0x0001}, 
    {0x0100, 0x0000, 0x0102, 0x0002, 0x0102, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0100, 0x0001}, 
    {0x0001, 0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100, 0x0001}, 
    {0x0200, 0x0000, 0x0000, 0x0201, 0x0101, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0100, 0x0001}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100, 0x0001}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0001}, 
    {0x0003, 0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0200, 0x0001}, {0x0000, 0x0002, 0x0002, 0x0202, 0x0000, 0x0000, 0x0200, 0x0001}, 
    {0x0100, 0x0000, 0x0101, 0x0201, 0x0000, 0x0000, 0x0200, 0x0001}, {0x0000, 0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0200, 0x0001}, 
    {0x0001, 0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200, 0x0001}, {0x0000, 0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200, 0x0001}, 
    {0x0200, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0200, 0x0001}, {0x0000, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0200, 0x0001}, 
    {0x0002, 0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001}, {0x0000, 0x0001, 0x0301, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001}, 
    {0x0100, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001}, {0x0000, 0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001}, 
    {0x0001, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0001}, {0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0001}, 
    {0x0500, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0500, 0x0001}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001}, 
    {0x0005, 0x0004, 0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0100}, {0x0000, 0x0004, 0x0004, 0x0004, 0x0004, 0x0104, 0x0000, 0x0100}, 
    {0x0100, 0x0000, 0x0103, 0x0003, 0x0003, 0x0103, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0003, 0x0003, 0x0003, 0x0103, 0x0000, 0x0100}, 
    {0x0001, 0x0100, 0x0000, 0x0102, 0x0002, 0x0102, 0x0000, 0x0100}, {0x0000, 0x0100, 0x0000, 0x0102, 0x0002, 0x0102, 0x0000, 0x0100}, 
    {0x0200, 0x0000, 0x0000, 0x0202, 0x0002, 0x0102, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0100}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0201, 0x0101, 0x0000, 0x0100}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0201, 0x0101, 0x0000, 0x0100}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0301, 0x0101, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0100}, 
    {0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100}, {0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0200, 0x0000, 0x0100}, 
    {0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0200, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0200, 0x0000, 0x0100}, 
    {0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0200, 0x0000, 0x0100}, {0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0200, 0x0000, 0x0100}, 
    {0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0200, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100}, 
    {0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100}, {0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100}, 
    {0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100}, 
    {0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0100}, {0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0100}, 
    {0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0500, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100}, 
    {0x0004, 0x0003, 0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0003, 0x0003, 0x0003, 0x0203, 0x0000, 0x0000, 0x0200}, 
    {0x0100, 0x0000, 0x0102, 0x0002, 0x0202, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0000, 0x0002, 0x0002, 0x0202, 0x0000, 0x0000, 0x0200}, 
    {0x0001, 0x0100, 0x0000, 0x0101, 0x0201, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0100, 0x0000, 0x0101, 0x0201, 0x0000, 0x0000, 0x0200}, 
    {0x0200, 0x0000, 0x0000, 0x0201, 0x0201, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0000, 0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0200}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0200}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0500, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0200}, 
    {0x0003, 0x0002, 0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300}, {0x0000, 0x0002, 0x0002, 0x0302, 0x0000, 0x0000, 0x0000, 0x0300}, 
    {0x0100, 0x0000, 0x0101, 0x0301, 0x0000, 0x0000, 0x0000, 0x0300}, {0x0000, 0x0000, 0x0001, 0x0301, 0x0000, 0x0000, 0x0000, 0x0300}, 
    {0x0001, 0x0100, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0300}, {0x0000, 0x0100, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0300}, 
    {0x0200, 0x0000, 0x0000, 0x0500, 0x0000, 0x0000, 0x0000, 0x0300}, {0x0000, 0x0000, 0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300}, 
    {0x0002, 0x0001, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400}, {0x0000, 0x0001, 0x0401, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400}, 
    {0x0100, 0x0000, 0x0500, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400}, {0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400}, 
    {0x0001, 0x0500, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0500}, {0x0000, 0x0500, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0500}, 
    {0x0600, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0600}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0006, 0x0005, 0x0004, 0x0003, 0x0002, 0x0001, 0x0000, 0x0000}, {0x0000, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000}, 
    {0x0100, 0x0000, 0x0104, 0x0004, 0x0004, 0x0004, 0x0004, 0x0000}, {0x0000, 0x0000, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0103, 0x0003, 0x0003, 0x0003, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0103, 0x0003, 0x0003, 0x0003, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0203, 0x0003, 0x0003, 0x0003, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0003, 0x0003, 0x0003, 0x0003, 0x0000}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0202, 0x0002, 0x0002, 0x0000}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0202, 0x0002, 0x0002, 0x0000}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0302, 0x0002, 0x0002, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000}, 
    {0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0101, 0x0001, 0x0000}, {0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0101, 0x0001, 0x0000}, 
    {0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0101, 0x0001, 0x0000}, {0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0101, 0x0001, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0101, 0x0001, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0101, 0x0001, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0101, 0x0001, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0101, 0x0001, 0x0000}, 
    {0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000}, {0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000}, 
    {0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000}, {0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000}, 
    {0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0301, 0x0001, 0x0000}, {0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0301, 0x0001, 0x0000}, 
    {0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0401, 0x0001, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0001, 0x0000}, 
    {0x0004, 0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0003, 0x0003, 0x0003, 0x0103, 0x0000, 0x0100, 0x0000}, 
    {0x0100, 0x0000, 0x0102, 0x0002, 0x0102, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0100, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0201, 0x0101, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0100, 0x0000}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100, 0x0000}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000}, 
    {0x0003, 0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0200, 0x0000}, {0x0000, 0x0002, 0x0002, 0x0202, 0x0000, 0x0000, 0x0200, 0x0000}, 
    {0x0100, 0x0000, 0x0101, 0x0201, 0x0000, 0x0000, 0x0200, 0x0000}, {0x0000, 0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0200, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0200, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0200, 0x0000}, 
    {0x0002, 0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000}, {0x0000, 0x0001, 0x0301, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000}, 
    {0x0100, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000}, {0x0000, 0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000}, 
    {0x0001, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000}, {0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000}, 
    {0x0500, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0500, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0005, 0x0004, 0x0003, 0x0002, 0x0001, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0103, 0x0003, 0x0003, 0x0003, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0003, 0x0003, 0x0003, 0x0003, 0x0000, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0202, 0x0002, 0x0002, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000, 0x0000}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000, 0x0000}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0301, 0x0001, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0001, 0x0000, 0x0000}, 
    {0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000}, {0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0100, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0100, 0x0000, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000}, 
    {0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000}, {0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000}, 
    {0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000, 0x0000}, {0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000, 0x0000}, 
    {0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0004, 0x0003, 0x0002, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0003, 0x0003, 0x0003, 0x0003, 0x0000, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0001, 0x0001, 0x0000, 0x0000, 0x0000}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0003, 0x0002, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0001, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0002, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0001, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}
};
#endif


constexpr uint8_t N_LAST_FLIP[N_8BIT][HW] = {
    {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 1, 2, 3, 4, 5, 6}, {0, 0, 0, 1, 2, 3, 4, 5}, {0, 0, 0, 1, 2, 3, 4, 5}, {1, 0, 0, 0, 1, 2, 3, 4}, {1, 0, 1, 0, 1, 2, 3, 4}, {0, 0, 0, 0, 1, 2, 3, 4}, {0, 0, 0, 0, 1, 2, 3, 4},
    {2, 1, 0, 0, 0, 1, 2, 3}, {2, 1, 1, 2, 0, 1, 2, 3}, {0, 1, 0, 1, 0, 1, 2, 3}, {0, 1, 0, 1, 0, 1, 2, 3}, {1, 0, 0, 0, 0, 1, 2, 3}, {1, 0, 1, 0, 0, 1, 2, 3}, {0, 0, 0, 0, 0, 1, 2, 3}, {0, 0, 0, 0, 0, 1, 2, 3},
    {3, 2, 1, 0, 0, 0, 1, 2}, {3, 2, 2, 2, 3, 0, 1, 2}, {0, 2, 1, 1, 2, 0, 1, 2}, {0, 2, 1, 1, 2, 0, 1, 2}, {1, 0, 1, 0, 1, 0, 1, 2}, {1, 0, 2, 0, 1, 0, 1, 2}, {0, 0, 1, 0, 1, 0, 1, 2}, {0, 0, 1, 0, 1, 0, 1, 2},
    {2, 1, 0, 0, 0, 0, 1, 2}, {2, 1, 1, 2, 0, 0, 1, 2}, {0, 1, 0, 1, 0, 0, 1, 2}, {0, 1, 0, 1, 0, 0, 1, 2}, {1, 0, 0, 0, 0, 0, 1, 2}, {1, 0, 1, 0, 0, 0, 1, 2}, {0, 0, 0, 0, 0, 0, 1, 2}, {0, 0, 0, 0, 0, 0, 1, 2},
    {4, 3, 2, 1, 0, 0, 0, 1}, {4, 3, 3, 3, 3, 4, 0, 1}, {0, 3, 2, 2, 2, 3, 0, 1}, {0, 3, 2, 2, 2, 3, 0, 1}, {1, 0, 2, 1, 1, 2, 0, 1}, {1, 0, 3, 1, 1, 2, 0, 1}, {0, 0, 2, 1, 1, 2, 0, 1}, {0, 0, 2, 1, 1, 2, 0, 1},
    {2, 1, 0, 1, 0, 1, 0, 1}, {2, 1, 1, 3, 0, 1, 0, 1}, {0, 1, 0, 2, 0, 1, 0, 1}, {0, 1, 0, 2, 0, 1, 0, 1}, {1, 0, 0, 1, 0, 1, 0, 1}, {1, 0, 1, 1, 0, 1, 0, 1}, {0, 0, 0, 1, 0, 1, 0, 1}, {0, 0, 0, 1, 0, 1, 0, 1},
    {3, 2, 1, 0, 0, 0, 0, 1}, {3, 2, 2, 2, 3, 0, 0, 1}, {0, 2, 1, 1, 2, 0, 0, 1}, {0, 2, 1, 1, 2, 0, 0, 1}, {1, 0, 1, 0, 1, 0, 0, 1}, {1, 0, 2, 0, 1, 0, 0, 1}, {0, 0, 1, 0, 1, 0, 0, 1}, {0, 0, 1, 0, 1, 0, 0, 1},
    {2, 1, 0, 0, 0, 0, 0, 1}, {2, 1, 1, 2, 0, 0, 0, 1}, {0, 1, 0, 1, 0, 0, 0, 1}, {0, 1, 0, 1, 0, 0, 0, 1}, {1, 0, 0, 0, 0, 0, 0, 1}, {1, 0, 1, 0, 0, 0, 0, 1}, {0, 0, 0, 0, 0, 0, 0, 1}, {0, 0, 0, 0, 0, 0, 0, 1},
    {5, 4, 3, 2, 1, 0, 0, 0}, {5, 4, 4, 4, 4, 4, 5, 0}, {0, 4, 3, 3, 3, 3, 4, 0}, {0, 4, 3, 3, 3, 3, 4, 0}, {1, 0, 3, 2, 2, 2, 3, 0}, {1, 0, 4, 2, 2, 2, 3, 0}, {0, 0, 3, 2, 2, 2, 3, 0}, {0, 0, 3, 2, 2, 2, 3, 0},
    {2, 1, 0, 2, 1, 1, 2, 0}, {2, 1, 1, 4, 1, 1, 2, 0}, {0, 1, 0, 3, 1, 1, 2, 0}, {0, 1, 0, 3, 1, 1, 2, 0}, {1, 0, 0, 2, 1, 1, 2, 0}, {1, 0, 1, 2, 1, 1, 2, 0}, {0, 0, 0, 2, 1, 1, 2, 0}, {0, 0, 0, 2, 1, 1, 2, 0},
    {3, 2, 1, 0, 1, 0, 1, 0}, {3, 2, 2, 2, 4, 0, 1, 0}, {0, 2, 1, 1, 3, 0, 1, 0}, {0, 2, 1, 1, 3, 0, 1, 0}, {1, 0, 1, 0, 2, 0, 1, 0}, {1, 0, 2, 0, 2, 0, 1, 0}, {0, 0, 1, 0, 2, 0, 1, 0}, {0, 0, 1, 0, 2, 0, 1, 0},
    {2, 1, 0, 0, 1, 0, 1, 0}, {2, 1, 1, 2, 1, 0, 1, 0}, {0, 1, 0, 1, 1, 0, 1, 0}, {0, 1, 0, 1, 1, 0, 1, 0}, {1, 0, 0, 0, 1, 0, 1, 0}, {1, 0, 1, 0, 1, 0, 1, 0}, {0, 0, 0, 0, 1, 0, 1, 0}, {0, 0, 0, 0, 1, 0, 1, 0},
    {4, 3, 2, 1, 0, 0, 0, 0}, {4, 3, 3, 3, 3, 4, 0, 0}, {0, 3, 2, 2, 2, 3, 0, 0}, {0, 3, 2, 2, 2, 3, 0, 0}, {1, 0, 2, 1, 1, 2, 0, 0}, {1, 0, 3, 1, 1, 2, 0, 0}, {0, 0, 2, 1, 1, 2, 0, 0}, {0, 0, 2, 1, 1, 2, 0, 0},
    {2, 1, 0, 1, 0, 1, 0, 0}, {2, 1, 1, 3, 0, 1, 0, 0}, {0, 1, 0, 2, 0, 1, 0, 0}, {0, 1, 0, 2, 0, 1, 0, 0}, {1, 0, 0, 1, 0, 1, 0, 0}, {1, 0, 1, 1, 0, 1, 0, 0}, {0, 0, 0, 1, 0, 1, 0, 0}, {0, 0, 0, 1, 0, 1, 0, 0},
    {3, 2, 1, 0, 0, 0, 0, 0}, {3, 2, 2, 2, 3, 0, 0, 0}, {0, 2, 1, 1, 2, 0, 0, 0}, {0, 2, 1, 1, 2, 0, 0, 0}, {1, 0, 1, 0, 1, 0, 0, 0}, {1, 0, 2, 0, 1, 0, 0, 0}, {0, 0, 1, 0, 1, 0, 0, 0}, {0, 0, 1, 0, 1, 0, 0, 0},
    {2, 1, 0, 0, 0, 0, 0, 0}, {2, 1, 1, 2, 0, 0, 0, 0}, {0, 1, 0, 1, 0, 0, 0, 0}, {0, 1, 0, 1, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},
    {6, 5, 4, 3, 2, 1, 0, 0}, {6, 5, 5, 5, 5, 5, 5, 6}, {0, 5, 4, 4, 4, 4, 4, 5}, {0, 5, 4, 4, 4, 4, 4, 5}, {1, 0, 4, 3, 3, 3, 3, 4}, {1, 0, 5, 3, 3, 3, 3, 4}, {0, 0, 4, 3, 3, 3, 3, 4}, {0, 0, 4, 3, 3, 3, 3, 4},
    {2, 1, 0, 3, 2, 2, 2, 3}, {2, 1, 1, 5, 2, 2, 2, 3}, {0, 1, 0, 4, 2, 2, 2, 3}, {0, 1, 0, 4, 2, 2, 2, 3}, {1, 0, 0, 3, 2, 2, 2, 3}, {1, 0, 1, 3, 2, 2, 2, 3}, {0, 0, 0, 3, 2, 2, 2, 3}, {0, 0, 0, 3, 2, 2, 2, 3},
    {3, 2, 1, 0, 2, 1, 1, 2}, {3, 2, 2, 2, 5, 1, 1, 2}, {0, 2, 1, 1, 4, 1, 1, 2}, {0, 2, 1, 1, 4, 1, 1, 2}, {1, 0, 1, 0, 3, 1, 1, 2}, {1, 0, 2, 0, 3, 1, 1, 2}, {0, 0, 1, 0, 3, 1, 1, 2}, {0, 0, 1, 0, 3, 1, 1, 2},
    {2, 1, 0, 0, 2, 1, 1, 2}, {2, 1, 1, 2, 2, 1, 1, 2}, {0, 1, 0, 1, 2, 1, 1, 2}, {0, 1, 0, 1, 2, 1, 1, 2}, {1, 0, 0, 0, 2, 1, 1, 2}, {1, 0, 1, 0, 2, 1, 1, 2}, {0, 0, 0, 0, 2, 1, 1, 2}, {0, 0, 0, 0, 2, 1, 1, 2},
    {4, 3, 2, 1, 0, 1, 0, 1}, {4, 3, 3, 3, 3, 5, 0, 1}, {0, 3, 2, 2, 2, 4, 0, 1}, {0, 3, 2, 2, 2, 4, 0, 1}, {1, 0, 2, 1, 1, 3, 0, 1}, {1, 0, 3, 1, 1, 3, 0, 1}, {0, 0, 2, 1, 1, 3, 0, 1}, {0, 0, 2, 1, 1, 3, 0, 1},
    {2, 1, 0, 1, 0, 2, 0, 1}, {2, 1, 1, 3, 0, 2, 0, 1}, {0, 1, 0, 2, 0, 2, 0, 1}, {0, 1, 0, 2, 0, 2, 0, 1}, {1, 0, 0, 1, 0, 2, 0, 1}, {1, 0, 1, 1, 0, 2, 0, 1}, {0, 0, 0, 1, 0, 2, 0, 1}, {0, 0, 0, 1, 0, 2, 0, 1},
    {3, 2, 1, 0, 0, 1, 0, 1}, {3, 2, 2, 2, 3, 1, 0, 1}, {0, 2, 1, 1, 2, 1, 0, 1}, {0, 2, 1, 1, 2, 1, 0, 1}, {1, 0, 1, 0, 1, 1, 0, 1}, {1, 0, 2, 0, 1, 1, 0, 1}, {0, 0, 1, 0, 1, 1, 0, 1}, {0, 0, 1, 0, 1, 1, 0, 1},
    {2, 1, 0, 0, 0, 1, 0, 1}, {2, 1, 1, 2, 0, 1, 0, 1}, {0, 1, 0, 1, 0, 1, 0, 1}, {0, 1, 0, 1, 0, 1, 0, 1}, {1, 0, 0, 0, 0, 1, 0, 1}, {1, 0, 1, 0, 0, 1, 0, 1}, {0, 0, 0, 0, 0, 1, 0, 1}, {0, 0, 0, 0, 0, 1, 0, 1},
    {5, 4, 3, 2, 1, 0, 0, 0}, {5, 4, 4, 4, 4, 4, 5, 0}, {0, 4, 3, 3, 3, 3, 4, 0}, {0, 4, 3, 3, 3, 3, 4, 0}, {1, 0, 3, 2, 2, 2, 3, 0}, {1, 0, 4, 2, 2, 2, 3, 0}, {0, 0, 3, 2, 2, 2, 3, 0}, {0, 0, 3, 2, 2, 2, 3, 0},
    {2, 1, 0, 2, 1, 1, 2, 0}, {2, 1, 1, 4, 1, 1, 2, 0}, {0, 1, 0, 3, 1, 1, 2, 0}, {0, 1, 0, 3, 1, 1, 2, 0}, {1, 0, 0, 2, 1, 1, 2, 0}, {1, 0, 1, 2, 1, 1, 2, 0}, {0, 0, 0, 2, 1, 1, 2, 0}, {0, 0, 0, 2, 1, 1, 2, 0},
    {3, 2, 1, 0, 1, 0, 1, 0}, {3, 2, 2, 2, 4, 0, 1, 0}, {0, 2, 1, 1, 3, 0, 1, 0}, {0, 2, 1, 1, 3, 0, 1, 0}, {1, 0, 1, 0, 2, 0, 1, 0}, {1, 0, 2, 0, 2, 0, 1, 0}, {0, 0, 1, 0, 2, 0, 1, 0}, {0, 0, 1, 0, 2, 0, 1, 0},
    {2, 1, 0, 0, 1, 0, 1, 0}, {2, 1, 1, 2, 1, 0, 1, 0}, {0, 1, 0, 1, 1, 0, 1, 0}, {0, 1, 0, 1, 1, 0, 1, 0}, {1, 0, 0, 0, 1, 0, 1, 0}, {1, 0, 1, 0, 1, 0, 1, 0}, {0, 0, 0, 0, 1, 0, 1, 0}, {0, 0, 0, 0, 1, 0, 1, 0},
    {4, 3, 2, 1, 0, 0, 0, 0}, {4, 3, 3, 3, 3, 4, 0, 0}, {0, 3, 2, 2, 2, 3, 0, 0}, {0, 3, 2, 2, 2, 3, 0, 0}, {1, 0, 2, 1, 1, 2, 0, 0}, {1, 0, 3, 1, 1, 2, 0, 0}, {0, 0, 2, 1, 1, 2, 0, 0}, {0, 0, 2, 1, 1, 2, 0, 0},
    {2, 1, 0, 1, 0, 1, 0, 0}, {2, 1, 1, 3, 0, 1, 0, 0}, {0, 1, 0, 2, 0, 1, 0, 0}, {0, 1, 0, 2, 0, 1, 0, 0}, {1, 0, 0, 1, 0, 1, 0, 0}, {1, 0, 1, 1, 0, 1, 0, 0}, {0, 0, 0, 1, 0, 1, 0, 0}, {0, 0, 0, 1, 0, 1, 0, 0},
    {3, 2, 1, 0, 0, 0, 0, 0}, {3, 2, 2, 2, 3, 0, 0, 0}, {0, 2, 1, 1, 2, 0, 0, 0}, {0, 2, 1, 1, 2, 0, 0, 0}, {1, 0, 1, 0, 1, 0, 0, 0}, {1, 0, 2, 0, 1, 0, 0, 0}, {0, 0, 1, 0, 1, 0, 0, 0}, {0, 0, 1, 0, 1, 0, 0, 0},
    {2, 1, 0, 0, 0, 0, 0, 0}, {2, 1, 1, 2, 0, 0, 0, 0}, {0, 1, 0, 1, 0, 0, 0, 0}, {0, 1, 0, 1, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}
};


inline int_fast8_t count_last_flip(uint64_t player, const uint_fast8_t place) {
    const int x = place & 7;
    const int y = place >> 3;
    return
        N_LAST_FLIP[join_h_line(player, y)][x] + 
        N_LAST_FLIP[join_v_line(player, x)][y] + 
        N_LAST_FLIP[join_d7_line(player, x + y)][std::min(y, 7 - x)] + 
        N_LAST_FLIP[join_d9_line(player, x + 7 - y)][std::min(y, x)];
}

inline void last_flip_init() {
}

// ===== FILE: Egaroucid/src/engine/last_flip.hpp =====



#pragma once
#include "setting.hpp"
#if USE_SIMD
#include "last_flip_simd.hpp"
#else
#include "last_flip_generic.hpp"
#endif

// ===== FILE: Egaroucid/src/engine/last_flip_simd.hpp =====



#pragma once
#include "setting.hpp"
#include "common_select.hpp"
#include "bit.hpp"


#if LAST_FLIP_PASS_OPT


constexpr uint16_t N_LAST_FLIP_BOTH[N_8BIT][HW] = {
    {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006}, 
    {0x0100, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005}, {0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005}, 
    {0x0001, 0x0100, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003, 0x0004}, {0x0000, 0x0100, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003, 0x0004}, 
    {0x0200, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002, 0x0003, 0x0004}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0003, 0x0004}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0001, 0x0002, 0x0003}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002, 0x0003}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002, 0x0003}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001, 0x0002, 0x0003}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0003}, 
    {0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0100, 0x0001, 0x0002}, {0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0100, 0x0001, 0x0002}, 
    {0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100, 0x0001, 0x0002}, {0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0100, 0x0001, 0x0002}, 
    {0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001, 0x0002}, {0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001, 0x0002}, 
    {0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100, 0x0001, 0x0002}, {0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0001, 0x0002}, 
    {0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002}, {0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002}, 
    {0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002}, {0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0200, 0x0001, 0x0002}, 
    {0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001, 0x0002}, {0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001, 0x0002}, 
    {0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0001, 0x0002}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002}, 
    {0x0004, 0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0003, 0x0003, 0x0003, 0x0103, 0x0000, 0x0100, 0x0001}, 
    {0x0100, 0x0000, 0x0102, 0x0002, 0x0102, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0100, 0x0001}, 
    {0x0001, 0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100, 0x0001}, 
    {0x0200, 0x0000, 0x0000, 0x0201, 0x0101, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0100, 0x0001}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0001}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100, 0x0001}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0100, 0x0001}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0001}, 
    {0x0003, 0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0200, 0x0001}, {0x0000, 0x0002, 0x0002, 0x0202, 0x0000, 0x0000, 0x0200, 0x0001}, 
    {0x0100, 0x0000, 0x0101, 0x0201, 0x0000, 0x0000, 0x0200, 0x0001}, {0x0000, 0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0200, 0x0001}, 
    {0x0001, 0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200, 0x0001}, {0x0000, 0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200, 0x0001}, 
    {0x0200, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0200, 0x0001}, {0x0000, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0200, 0x0001}, 
    {0x0002, 0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001}, {0x0000, 0x0001, 0x0301, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001}, 
    {0x0100, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001}, {0x0000, 0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0001}, 
    {0x0001, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0001}, {0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0001}, 
    {0x0500, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0500, 0x0001}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001}, 
    {0x0005, 0x0004, 0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0100}, {0x0000, 0x0004, 0x0004, 0x0004, 0x0004, 0x0104, 0x0000, 0x0100}, 
    {0x0100, 0x0000, 0x0103, 0x0003, 0x0003, 0x0103, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0003, 0x0003, 0x0003, 0x0103, 0x0000, 0x0100}, 
    {0x0001, 0x0100, 0x0000, 0x0102, 0x0002, 0x0102, 0x0000, 0x0100}, {0x0000, 0x0100, 0x0000, 0x0102, 0x0002, 0x0102, 0x0000, 0x0100}, 
    {0x0200, 0x0000, 0x0000, 0x0202, 0x0002, 0x0102, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0100}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0201, 0x0101, 0x0000, 0x0100}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0201, 0x0101, 0x0000, 0x0100}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0301, 0x0101, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0100}, 
    {0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100}, {0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0200, 0x0000, 0x0100}, 
    {0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0200, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0200, 0x0000, 0x0100}, 
    {0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0200, 0x0000, 0x0100}, {0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0200, 0x0000, 0x0100}, 
    {0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0200, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100}, 
    {0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100}, {0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100}, 
    {0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100}, 
    {0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0100}, {0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0100}, 
    {0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0500, 0x0000, 0x0100}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100}, 
    {0x0004, 0x0003, 0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0003, 0x0003, 0x0003, 0x0203, 0x0000, 0x0000, 0x0200}, 
    {0x0100, 0x0000, 0x0102, 0x0002, 0x0202, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0000, 0x0002, 0x0002, 0x0202, 0x0000, 0x0000, 0x0200}, 
    {0x0001, 0x0100, 0x0000, 0x0101, 0x0201, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0100, 0x0000, 0x0101, 0x0201, 0x0000, 0x0000, 0x0200}, 
    {0x0200, 0x0000, 0x0000, 0x0201, 0x0201, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0000, 0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0200}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0200}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0500, 0x0000, 0x0000, 0x0200}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0200}, 
    {0x0003, 0x0002, 0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300}, {0x0000, 0x0002, 0x0002, 0x0302, 0x0000, 0x0000, 0x0000, 0x0300}, 
    {0x0100, 0x0000, 0x0101, 0x0301, 0x0000, 0x0000, 0x0000, 0x0300}, {0x0000, 0x0000, 0x0001, 0x0301, 0x0000, 0x0000, 0x0000, 0x0300}, 
    {0x0001, 0x0100, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0300}, {0x0000, 0x0100, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0300}, 
    {0x0200, 0x0000, 0x0000, 0x0500, 0x0000, 0x0000, 0x0000, 0x0300}, {0x0000, 0x0000, 0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300}, 
    {0x0002, 0x0001, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400}, {0x0000, 0x0001, 0x0401, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400}, 
    {0x0100, 0x0000, 0x0500, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400}, {0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400}, 
    {0x0001, 0x0500, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0500}, {0x0000, 0x0500, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0500}, 
    {0x0600, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0600}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0006, 0x0005, 0x0004, 0x0003, 0x0002, 0x0001, 0x0000, 0x0000}, {0x0000, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0000}, 
    {0x0100, 0x0000, 0x0104, 0x0004, 0x0004, 0x0004, 0x0004, 0x0000}, {0x0000, 0x0000, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0103, 0x0003, 0x0003, 0x0003, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0103, 0x0003, 0x0003, 0x0003, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0203, 0x0003, 0x0003, 0x0003, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0003, 0x0003, 0x0003, 0x0003, 0x0000}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0202, 0x0002, 0x0002, 0x0000}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0202, 0x0002, 0x0002, 0x0000}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0302, 0x0002, 0x0002, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000}, 
    {0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0101, 0x0001, 0x0000}, {0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0101, 0x0001, 0x0000}, 
    {0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0101, 0x0001, 0x0000}, {0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0101, 0x0001, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0101, 0x0001, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0101, 0x0001, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0101, 0x0001, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0101, 0x0001, 0x0000}, 
    {0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000}, {0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000}, 
    {0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000}, {0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000}, 
    {0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0301, 0x0001, 0x0000}, {0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0301, 0x0001, 0x0000}, 
    {0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0401, 0x0001, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0001, 0x0000}, 
    {0x0004, 0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0003, 0x0003, 0x0003, 0x0103, 0x0000, 0x0100, 0x0000}, 
    {0x0100, 0x0000, 0x0102, 0x0002, 0x0102, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0100, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0201, 0x0101, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0100, 0x0000}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100, 0x0000}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0100, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000}, 
    {0x0003, 0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0200, 0x0000}, {0x0000, 0x0002, 0x0002, 0x0202, 0x0000, 0x0000, 0x0200, 0x0000}, 
    {0x0100, 0x0000, 0x0101, 0x0201, 0x0000, 0x0000, 0x0200, 0x0000}, {0x0000, 0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0200, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0200, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0200, 0x0000}, 
    {0x0002, 0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000}, {0x0000, 0x0001, 0x0301, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000}, 
    {0x0100, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000}, {0x0000, 0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000}, 
    {0x0001, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000}, {0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000}, 
    {0x0500, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0500, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0005, 0x0004, 0x0003, 0x0002, 0x0001, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0103, 0x0003, 0x0003, 0x0003, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0003, 0x0003, 0x0003, 0x0003, 0x0000, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0202, 0x0002, 0x0002, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000, 0x0000}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000, 0x0000}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0301, 0x0001, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0001, 0x0000, 0x0000}, 
    {0x0003, 0x0002, 0x0001, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000}, {0x0000, 0x0002, 0x0002, 0x0102, 0x0000, 0x0100, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0101, 0x0101, 0x0000, 0x0100, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0001, 0x0101, 0x0000, 0x0100, 0x0000, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0300, 0x0000, 0x0100, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000}, 
    {0x0002, 0x0001, 0x0200, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000}, {0x0000, 0x0001, 0x0201, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0300, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000}, 
    {0x0001, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000, 0x0000}, {0x0000, 0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000, 0x0000}, 
    {0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0004, 0x0003, 0x0002, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0003, 0x0003, 0x0003, 0x0003, 0x0000, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0102, 0x0002, 0x0002, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0201, 0x0001, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0001, 0x0001, 0x0000, 0x0000, 0x0000}, 
    {0x0002, 0x0001, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0001, 0x0101, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0200, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000}, 
    {0x0001, 0x0200, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0200, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000}, 
    {0x0300, 0x0000, 0x0000, 0x0000, 0x0300, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0003, 0x0002, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0101, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0001, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0001, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0200, 0x0000, 0x0000, 0x0200, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0002, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0001, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0100, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, 
    {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}
};
#endif


constexpr int_fast8_t N_LAST_FLIP[N_8BIT][HW] = {
    {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 1, 2, 3, 4, 5, 6}, {0, 0, 0, 1, 2, 3, 4, 5}, {0, 0, 0, 1, 2, 3, 4, 5}, {1, 0, 0, 0, 1, 2, 3, 4}, {1, 0, 1, 0, 1, 2, 3, 4}, {0, 0, 0, 0, 1, 2, 3, 4}, {0, 0, 0, 0, 1, 2, 3, 4},
    {2, 1, 0, 0, 0, 1, 2, 3}, {2, 1, 1, 2, 0, 1, 2, 3}, {0, 1, 0, 1, 0, 1, 2, 3}, {0, 1, 0, 1, 0, 1, 2, 3}, {1, 0, 0, 0, 0, 1, 2, 3}, {1, 0, 1, 0, 0, 1, 2, 3}, {0, 0, 0, 0, 0, 1, 2, 3}, {0, 0, 0, 0, 0, 1, 2, 3},
    {3, 2, 1, 0, 0, 0, 1, 2}, {3, 2, 2, 2, 3, 0, 1, 2}, {0, 2, 1, 1, 2, 0, 1, 2}, {0, 2, 1, 1, 2, 0, 1, 2}, {1, 0, 1, 0, 1, 0, 1, 2}, {1, 0, 2, 0, 1, 0, 1, 2}, {0, 0, 1, 0, 1, 0, 1, 2}, {0, 0, 1, 0, 1, 0, 1, 2},
    {2, 1, 0, 0, 0, 0, 1, 2}, {2, 1, 1, 2, 0, 0, 1, 2}, {0, 1, 0, 1, 0, 0, 1, 2}, {0, 1, 0, 1, 0, 0, 1, 2}, {1, 0, 0, 0, 0, 0, 1, 2}, {1, 0, 1, 0, 0, 0, 1, 2}, {0, 0, 0, 0, 0, 0, 1, 2}, {0, 0, 0, 0, 0, 0, 1, 2},
    {4, 3, 2, 1, 0, 0, 0, 1}, {4, 3, 3, 3, 3, 4, 0, 1}, {0, 3, 2, 2, 2, 3, 0, 1}, {0, 3, 2, 2, 2, 3, 0, 1}, {1, 0, 2, 1, 1, 2, 0, 1}, {1, 0, 3, 1, 1, 2, 0, 1}, {0, 0, 2, 1, 1, 2, 0, 1}, {0, 0, 2, 1, 1, 2, 0, 1},
    {2, 1, 0, 1, 0, 1, 0, 1}, {2, 1, 1, 3, 0, 1, 0, 1}, {0, 1, 0, 2, 0, 1, 0, 1}, {0, 1, 0, 2, 0, 1, 0, 1}, {1, 0, 0, 1, 0, 1, 0, 1}, {1, 0, 1, 1, 0, 1, 0, 1}, {0, 0, 0, 1, 0, 1, 0, 1}, {0, 0, 0, 1, 0, 1, 0, 1},
    {3, 2, 1, 0, 0, 0, 0, 1}, {3, 2, 2, 2, 3, 0, 0, 1}, {0, 2, 1, 1, 2, 0, 0, 1}, {0, 2, 1, 1, 2, 0, 0, 1}, {1, 0, 1, 0, 1, 0, 0, 1}, {1, 0, 2, 0, 1, 0, 0, 1}, {0, 0, 1, 0, 1, 0, 0, 1}, {0, 0, 1, 0, 1, 0, 0, 1},
    {2, 1, 0, 0, 0, 0, 0, 1}, {2, 1, 1, 2, 0, 0, 0, 1}, {0, 1, 0, 1, 0, 0, 0, 1}, {0, 1, 0, 1, 0, 0, 0, 1}, {1, 0, 0, 0, 0, 0, 0, 1}, {1, 0, 1, 0, 0, 0, 0, 1}, {0, 0, 0, 0, 0, 0, 0, 1}, {0, 0, 0, 0, 0, 0, 0, 1},
    {5, 4, 3, 2, 1, 0, 0, 0}, {5, 4, 4, 4, 4, 4, 5, 0}, {0, 4, 3, 3, 3, 3, 4, 0}, {0, 4, 3, 3, 3, 3, 4, 0}, {1, 0, 3, 2, 2, 2, 3, 0}, {1, 0, 4, 2, 2, 2, 3, 0}, {0, 0, 3, 2, 2, 2, 3, 0}, {0, 0, 3, 2, 2, 2, 3, 0},
    {2, 1, 0, 2, 1, 1, 2, 0}, {2, 1, 1, 4, 1, 1, 2, 0}, {0, 1, 0, 3, 1, 1, 2, 0}, {0, 1, 0, 3, 1, 1, 2, 0}, {1, 0, 0, 2, 1, 1, 2, 0}, {1, 0, 1, 2, 1, 1, 2, 0}, {0, 0, 0, 2, 1, 1, 2, 0}, {0, 0, 0, 2, 1, 1, 2, 0},
    {3, 2, 1, 0, 1, 0, 1, 0}, {3, 2, 2, 2, 4, 0, 1, 0}, {0, 2, 1, 1, 3, 0, 1, 0}, {0, 2, 1, 1, 3, 0, 1, 0}, {1, 0, 1, 0, 2, 0, 1, 0}, {1, 0, 2, 0, 2, 0, 1, 0}, {0, 0, 1, 0, 2, 0, 1, 0}, {0, 0, 1, 0, 2, 0, 1, 0},
    {2, 1, 0, 0, 1, 0, 1, 0}, {2, 1, 1, 2, 1, 0, 1, 0}, {0, 1, 0, 1, 1, 0, 1, 0}, {0, 1, 0, 1, 1, 0, 1, 0}, {1, 0, 0, 0, 1, 0, 1, 0}, {1, 0, 1, 0, 1, 0, 1, 0}, {0, 0, 0, 0, 1, 0, 1, 0}, {0, 0, 0, 0, 1, 0, 1, 0},
    {4, 3, 2, 1, 0, 0, 0, 0}, {4, 3, 3, 3, 3, 4, 0, 0}, {0, 3, 2, 2, 2, 3, 0, 0}, {0, 3, 2, 2, 2, 3, 0, 0}, {1, 0, 2, 1, 1, 2, 0, 0}, {1, 0, 3, 1, 1, 2, 0, 0}, {0, 0, 2, 1, 1, 2, 0, 0}, {0, 0, 2, 1, 1, 2, 0, 0},
    {2, 1, 0, 1, 0, 1, 0, 0}, {2, 1, 1, 3, 0, 1, 0, 0}, {0, 1, 0, 2, 0, 1, 0, 0}, {0, 1, 0, 2, 0, 1, 0, 0}, {1, 0, 0, 1, 0, 1, 0, 0}, {1, 0, 1, 1, 0, 1, 0, 0}, {0, 0, 0, 1, 0, 1, 0, 0}, {0, 0, 0, 1, 0, 1, 0, 0},
    {3, 2, 1, 0, 0, 0, 0, 0}, {3, 2, 2, 2, 3, 0, 0, 0}, {0, 2, 1, 1, 2, 0, 0, 0}, {0, 2, 1, 1, 2, 0, 0, 0}, {1, 0, 1, 0, 1, 0, 0, 0}, {1, 0, 2, 0, 1, 0, 0, 0}, {0, 0, 1, 0, 1, 0, 0, 0}, {0, 0, 1, 0, 1, 0, 0, 0},
    {2, 1, 0, 0, 0, 0, 0, 0}, {2, 1, 1, 2, 0, 0, 0, 0}, {0, 1, 0, 1, 0, 0, 0, 0}, {0, 1, 0, 1, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},
    {6, 5, 4, 3, 2, 1, 0, 0}, {6, 5, 5, 5, 5, 5, 5, 6}, {0, 5, 4, 4, 4, 4, 4, 5}, {0, 5, 4, 4, 4, 4, 4, 5}, {1, 0, 4, 3, 3, 3, 3, 4}, {1, 0, 5, 3, 3, 3, 3, 4}, {0, 0, 4, 3, 3, 3, 3, 4}, {0, 0, 4, 3, 3, 3, 3, 4},
    {2, 1, 0, 3, 2, 2, 2, 3}, {2, 1, 1, 5, 2, 2, 2, 3}, {0, 1, 0, 4, 2, 2, 2, 3}, {0, 1, 0, 4, 2, 2, 2, 3}, {1, 0, 0, 3, 2, 2, 2, 3}, {1, 0, 1, 3, 2, 2, 2, 3}, {0, 0, 0, 3, 2, 2, 2, 3}, {0, 0, 0, 3, 2, 2, 2, 3},
    {3, 2, 1, 0, 2, 1, 1, 2}, {3, 2, 2, 2, 5, 1, 1, 2}, {0, 2, 1, 1, 4, 1, 1, 2}, {0, 2, 1, 1, 4, 1, 1, 2}, {1, 0, 1, 0, 3, 1, 1, 2}, {1, 0, 2, 0, 3, 1, 1, 2}, {0, 0, 1, 0, 3, 1, 1, 2}, {0, 0, 1, 0, 3, 1, 1, 2},
    {2, 1, 0, 0, 2, 1, 1, 2}, {2, 1, 1, 2, 2, 1, 1, 2}, {0, 1, 0, 1, 2, 1, 1, 2}, {0, 1, 0, 1, 2, 1, 1, 2}, {1, 0, 0, 0, 2, 1, 1, 2}, {1, 0, 1, 0, 2, 1, 1, 2}, {0, 0, 0, 0, 2, 1, 1, 2}, {0, 0, 0, 0, 2, 1, 1, 2},
    {4, 3, 2, 1, 0, 1, 0, 1}, {4, 3, 3, 3, 3, 5, 0, 1}, {0, 3, 2, 2, 2, 4, 0, 1}, {0, 3, 2, 2, 2, 4, 0, 1}, {1, 0, 2, 1, 1, 3, 0, 1}, {1, 0, 3, 1, 1, 3, 0, 1}, {0, 0, 2, 1, 1, 3, 0, 1}, {0, 0, 2, 1, 1, 3, 0, 1},
    {2, 1, 0, 1, 0, 2, 0, 1}, {2, 1, 1, 3, 0, 2, 0, 1}, {0, 1, 0, 2, 0, 2, 0, 1}, {0, 1, 0, 2, 0, 2, 0, 1}, {1, 0, 0, 1, 0, 2, 0, 1}, {1, 0, 1, 1, 0, 2, 0, 1}, {0, 0, 0, 1, 0, 2, 0, 1}, {0, 0, 0, 1, 0, 2, 0, 1},
    {3, 2, 1, 0, 0, 1, 0, 1}, {3, 2, 2, 2, 3, 1, 0, 1}, {0, 2, 1, 1, 2, 1, 0, 1}, {0, 2, 1, 1, 2, 1, 0, 1}, {1, 0, 1, 0, 1, 1, 0, 1}, {1, 0, 2, 0, 1, 1, 0, 1}, {0, 0, 1, 0, 1, 1, 0, 1}, {0, 0, 1, 0, 1, 1, 0, 1},
    {2, 1, 0, 0, 0, 1, 0, 1}, {2, 1, 1, 2, 0, 1, 0, 1}, {0, 1, 0, 1, 0, 1, 0, 1}, {0, 1, 0, 1, 0, 1, 0, 1}, {1, 0, 0, 0, 0, 1, 0, 1}, {1, 0, 1, 0, 0, 1, 0, 1}, {0, 0, 0, 0, 0, 1, 0, 1}, {0, 0, 0, 0, 0, 1, 0, 1},
    {5, 4, 3, 2, 1, 0, 0, 0}, {5, 4, 4, 4, 4, 4, 5, 0}, {0, 4, 3, 3, 3, 3, 4, 0}, {0, 4, 3, 3, 3, 3, 4, 0}, {1, 0, 3, 2, 2, 2, 3, 0}, {1, 0, 4, 2, 2, 2, 3, 0}, {0, 0, 3, 2, 2, 2, 3, 0}, {0, 0, 3, 2, 2, 2, 3, 0},
    {2, 1, 0, 2, 1, 1, 2, 0}, {2, 1, 1, 4, 1, 1, 2, 0}, {0, 1, 0, 3, 1, 1, 2, 0}, {0, 1, 0, 3, 1, 1, 2, 0}, {1, 0, 0, 2, 1, 1, 2, 0}, {1, 0, 1, 2, 1, 1, 2, 0}, {0, 0, 0, 2, 1, 1, 2, 0}, {0, 0, 0, 2, 1, 1, 2, 0},
    {3, 2, 1, 0, 1, 0, 1, 0}, {3, 2, 2, 2, 4, 0, 1, 0}, {0, 2, 1, 1, 3, 0, 1, 0}, {0, 2, 1, 1, 3, 0, 1, 0}, {1, 0, 1, 0, 2, 0, 1, 0}, {1, 0, 2, 0, 2, 0, 1, 0}, {0, 0, 1, 0, 2, 0, 1, 0}, {0, 0, 1, 0, 2, 0, 1, 0},
    {2, 1, 0, 0, 1, 0, 1, 0}, {2, 1, 1, 2, 1, 0, 1, 0}, {0, 1, 0, 1, 1, 0, 1, 0}, {0, 1, 0, 1, 1, 0, 1, 0}, {1, 0, 0, 0, 1, 0, 1, 0}, {1, 0, 1, 0, 1, 0, 1, 0}, {0, 0, 0, 0, 1, 0, 1, 0}, {0, 0, 0, 0, 1, 0, 1, 0},
    {4, 3, 2, 1, 0, 0, 0, 0}, {4, 3, 3, 3, 3, 4, 0, 0}, {0, 3, 2, 2, 2, 3, 0, 0}, {0, 3, 2, 2, 2, 3, 0, 0}, {1, 0, 2, 1, 1, 2, 0, 0}, {1, 0, 3, 1, 1, 2, 0, 0}, {0, 0, 2, 1, 1, 2, 0, 0}, {0, 0, 2, 1, 1, 2, 0, 0},
    {2, 1, 0, 1, 0, 1, 0, 0}, {2, 1, 1, 3, 0, 1, 0, 0}, {0, 1, 0, 2, 0, 1, 0, 0}, {0, 1, 0, 2, 0, 1, 0, 0}, {1, 0, 0, 1, 0, 1, 0, 0}, {1, 0, 1, 1, 0, 1, 0, 0}, {0, 0, 0, 1, 0, 1, 0, 0}, {0, 0, 0, 1, 0, 1, 0, 0},
    {3, 2, 1, 0, 0, 0, 0, 0}, {3, 2, 2, 2, 3, 0, 0, 0}, {0, 2, 1, 1, 2, 0, 0, 0}, {0, 2, 1, 1, 2, 0, 0, 0}, {1, 0, 1, 0, 1, 0, 0, 0}, {1, 0, 2, 0, 1, 0, 0, 0}, {0, 0, 1, 0, 1, 0, 0, 0}, {0, 0, 1, 0, 1, 0, 0, 0},
    {2, 1, 0, 0, 0, 0, 0, 0}, {2, 1, 1, 2, 0, 0, 0, 0}, {0, 1, 0, 1, 0, 0, 0, 0}, {0, 1, 0, 1, 0, 0, 0, 0}, {1, 0, 0, 0, 0, 0, 0, 0}, {1, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}
};

inline void last_flip_init() {
}

// ===== FILE: Egaroucid/src/engine/level.hpp =====



#pragma once
#include <iostream>
#include <cmath>
#include "common_select.hpp"


constexpr int ACCURATE_MAX_LEVEL = 40;
constexpr int PRAGMATIC_MAX_LEVEL = 25;
constexpr int STANDARD_MAX_LEVEL = 21;
constexpr int LIGHT_LEVEL = 15;

constexpr int DEFAULT_LEVEL = 21;


constexpr int N_LEVEL = 61; 
constexpr int NODEPTH = 100;

constexpr int N_SELECTIVITY_LEVEL = 7;
constexpr int MPC_74_LEVEL = 0;
constexpr int MPC_88_LEVEL = 1;
constexpr int MPC_93_LEVEL = 2;
constexpr int MPC_98_LEVEL = 3;
constexpr int MPC_99_LEVEL = 4;
constexpr int MPC_999_LEVEL = 5;
constexpr int MPC_100_LEVEL = 6;
constexpr double SELECTIVITY_PERCENTAGE[N_SELECTIVITY_LEVEL] = {74, 88, 93, 98, 99, 99.9, 100}; 

constexpr int MAX_LEVEL = (N_LEVEL - 1);
constexpr int LEVEL_TYPE_BOOK = 1000;


struct Level{
    uint_fast8_t mid_lookahead;
    uint_fast8_t mid_mpc_level;
    uint_fast8_t complete0;
    uint_fast8_t complete0_mpc_level;
    uint_fast8_t complete1;
    uint_fast8_t complete1_mpc_level;
    uint_fast8_t complete2;
    uint_fast8_t complete2_mpc_level;
    uint_fast8_t complete3;
    uint_fast8_t complete3_mpc_level;
    uint_fast8_t complete4;
    uint_fast8_t complete4_mpc_level;
};


constexpr Level level_definition[N_LEVEL] = {
    {0, MPC_100_LEVEL, 0, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {1, MPC_100_LEVEL, 2, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {2, MPC_100_LEVEL, 4, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {3, MPC_100_LEVEL, 6, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {4, MPC_100_LEVEL, 8, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},

    {5, MPC_100_LEVEL, 10, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {6, MPC_100_LEVEL, 12, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {7, MPC_100_LEVEL, 14, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {8, MPC_100_LEVEL, 16, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {9, MPC_100_LEVEL, 18, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},

    {10, MPC_100_LEVEL, 20, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {11, MPC_74_LEVEL, 25, MPC_98_LEVEL, 23, MPC_99_LEVEL, 21, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {12, MPC_74_LEVEL, 25, MPC_98_LEVEL, 23, MPC_99_LEVEL, 21, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {13, MPC_74_LEVEL, 27, MPC_93_LEVEL, 25, MPC_98_LEVEL, 23, MPC_99_LEVEL, 21, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {14, MPC_74_LEVEL, 27, MPC_93_LEVEL, 25, MPC_98_LEVEL, 23, MPC_99_LEVEL, 21, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},

    {15, MPC_74_LEVEL, 27, MPC_98_LEVEL, 24, MPC_99_LEVEL, 22, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {16, MPC_74_LEVEL, 27, MPC_98_LEVEL, 24, MPC_99_LEVEL, 22, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {17, MPC_74_LEVEL, 27, MPC_98_LEVEL, 24, MPC_99_LEVEL, 22, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {18, MPC_74_LEVEL, 29, MPC_93_LEVEL, 27, MPC_98_LEVEL, 24, MPC_99_LEVEL, 22, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {19, MPC_74_LEVEL, 29, MPC_93_LEVEL, 27, MPC_98_LEVEL, 24, MPC_99_LEVEL, 22, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},

    {20, MPC_74_LEVEL, 30, MPC_93_LEVEL, 28, MPC_98_LEVEL, 26, MPC_99_LEVEL, 24, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {21, MPC_74_LEVEL, 30, MPC_93_LEVEL, 28, MPC_98_LEVEL, 26, MPC_99_LEVEL, 24, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {22, MPC_74_LEVEL, 30, MPC_93_LEVEL, 38, MPC_98_LEVEL, 26, MPC_99_LEVEL, 24, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {23, MPC_74_LEVEL, 32, MPC_93_LEVEL, 30, MPC_98_LEVEL, 28, MPC_99_LEVEL, 26, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {24, MPC_74_LEVEL, 32, MPC_93_LEVEL, 30, MPC_98_LEVEL, 28, MPC_99_LEVEL, 26, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    
    {25, MPC_74_LEVEL, 34, MPC_88_LEVEL, 32, MPC_93_LEVEL, 30, MPC_98_LEVEL, 28, MPC_99_LEVEL, 26, MPC_100_LEVEL},
    {26, MPC_74_LEVEL, 34, MPC_88_LEVEL, 32, MPC_93_LEVEL, 30, MPC_98_LEVEL, 28, MPC_99_LEVEL, 26, MPC_100_LEVEL},
    {27, MPC_74_LEVEL, 36, MPC_88_LEVEL, 34, MPC_93_LEVEL, 32, MPC_98_LEVEL, 30, MPC_99_LEVEL, 28, MPC_100_LEVEL},
    {28, MPC_74_LEVEL, 36, MPC_88_LEVEL, 34, MPC_93_LEVEL, 32, MPC_98_LEVEL, 30, MPC_99_LEVEL, 28, MPC_100_LEVEL},
    {29, MPC_74_LEVEL, 36, MPC_93_LEVEL, 34, MPC_98_LEVEL, 32, MPC_99_LEVEL, 30, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},

    {30, MPC_74_LEVEL, 36, MPC_93_LEVEL, 34, MPC_98_LEVEL, 32, MPC_99_LEVEL, 30, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {31, MPC_74_LEVEL, 38, MPC_88_LEVEL, 36, MPC_93_LEVEL, 34, MPC_98_LEVEL, 32, MPC_99_LEVEL, 30, MPC_100_LEVEL},
    {32, MPC_74_LEVEL, 38, MPC_88_LEVEL, 36, MPC_93_LEVEL, 34, MPC_98_LEVEL, 32, MPC_99_LEVEL, 30, MPC_100_LEVEL},
    {33, MPC_74_LEVEL, 38, MPC_93_LEVEL, 36, MPC_98_LEVEL, 34, MPC_99_LEVEL, 32, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {34, MPC_74_LEVEL, 38, MPC_93_LEVEL, 36, MPC_98_LEVEL, 34, MPC_99_LEVEL, 32, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},

    {35, MPC_74_LEVEL, 40, MPC_88_LEVEL, 38, MPC_93_LEVEL, 36, MPC_98_LEVEL, 34, MPC_99_LEVEL, 32, MPC_100_LEVEL},
    {36, MPC_74_LEVEL, 40, MPC_88_LEVEL, 38, MPC_93_LEVEL, 36, MPC_98_LEVEL, 34, MPC_99_LEVEL, 32, MPC_100_LEVEL},
    {37, MPC_74_LEVEL, 40, MPC_93_LEVEL, 36, MPC_98_LEVEL, 36, MPC_99_LEVEL, 34, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {38, MPC_74_LEVEL, 40, MPC_93_LEVEL, 38, MPC_98_LEVEL, 36, MPC_99_LEVEL, 34, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {39, MPC_74_LEVEL, 42, MPC_88_LEVEL, 40, MPC_93_LEVEL, 38, MPC_98_LEVEL, 36, MPC_99_LEVEL, 34, MPC_100_LEVEL},

    {40, MPC_74_LEVEL, 42, MPC_88_LEVEL, 40, MPC_93_LEVEL, 38, MPC_98_LEVEL, 36, MPC_99_LEVEL, 34, MPC_100_LEVEL},
    {41, MPC_74_LEVEL, 42, MPC_93_LEVEL, 40, MPC_98_LEVEL, 38, MPC_99_LEVEL, 36, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {42, MPC_74_LEVEL, 42, MPC_93_LEVEL, 40, MPC_98_LEVEL, 38, MPC_99_LEVEL, 36, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {43, MPC_74_LEVEL, 44, MPC_88_LEVEL, 42, MPC_93_LEVEL, 40, MPC_98_LEVEL, 38, MPC_99_LEVEL, 36, MPC_100_LEVEL},
    {44, MPC_74_LEVEL, 44, MPC_88_LEVEL, 42, MPC_93_LEVEL, 40, MPC_98_LEVEL, 38, MPC_99_LEVEL, 36, MPC_100_LEVEL},

    {45, MPC_74_LEVEL, 44, MPC_93_LEVEL, 42, MPC_98_LEVEL, 40, MPC_99_LEVEL, 38, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {46, MPC_74_LEVEL, 44, MPC_93_LEVEL, 42, MPC_98_LEVEL, 40, MPC_99_LEVEL, 38, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {47, MPC_74_LEVEL, 46, MPC_88_LEVEL, 44, MPC_93_LEVEL, 42, MPC_98_LEVEL, 40, MPC_99_LEVEL, 38, MPC_100_LEVEL},
    {48, MPC_74_LEVEL, 46, MPC_88_LEVEL, 44, MPC_93_LEVEL, 42, MPC_98_LEVEL, 40, MPC_99_LEVEL, 38, MPC_100_LEVEL},
    {49, MPC_74_LEVEL, 46, MPC_93_LEVEL, 44, MPC_98_LEVEL, 42, MPC_99_LEVEL, 40, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},

    {50, MPC_74_LEVEL, 46, MPC_93_LEVEL, 44, MPC_98_LEVEL, 42, MPC_99_LEVEL, 40, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {51, MPC_74_LEVEL, 48, MPC_88_LEVEL, 46, MPC_93_LEVEL, 44, MPC_98_LEVEL, 42, MPC_99_LEVEL, 40, MPC_100_LEVEL},
    {52, MPC_74_LEVEL, 50, MPC_88_LEVEL, 48, MPC_93_LEVEL, 46, MPC_98_LEVEL, 44, MPC_99_LEVEL, 42, MPC_100_LEVEL},
    {53, MPC_74_LEVEL, 54, MPC_88_LEVEL, 52, MPC_93_LEVEL, 50, MPC_98_LEVEL, 48, MPC_99_LEVEL, 46, MPC_100_LEVEL},
    {54, MPC_74_LEVEL, 56, MPC_88_LEVEL, 54, MPC_93_LEVEL, 52, MPC_98_LEVEL, 50, MPC_99_LEVEL, 48, MPC_100_LEVEL},

    {55, MPC_74_LEVEL, 58, MPC_88_LEVEL, 56, MPC_93_LEVEL, 54, MPC_98_LEVEL, 52, MPC_99_LEVEL, 50, MPC_100_LEVEL},
    {56, MPC_88_LEVEL, 60, MPC_88_LEVEL, 58, MPC_93_LEVEL, 56, MPC_98_LEVEL, 54, MPC_99_LEVEL, 52, MPC_100_LEVEL},
    {57, MPC_88_LEVEL, 60, MPC_93_LEVEL, 58, MPC_98_LEVEL, 56, MPC_99_LEVEL, 54, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {58, MPC_93_LEVEL, 60, MPC_98_LEVEL, 58, MPC_99_LEVEL, 56, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},
    {59, MPC_93_LEVEL, 60, MPC_99_LEVEL, 58, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL},

    {60, MPC_100_LEVEL, 60, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL, NODEPTH, MPC_100_LEVEL}
};


void get_level(int level, int n_moves, bool *is_mid_search, int *depth, uint_fast8_t *mpc_level) {
    level = std::clamp(level, 1, 60);
    Level level_status = level_definition[level];
    int n_empties = 60 - n_moves;
    if (n_empties > level_status.complete0) {
        *is_mid_search = true;
        *depth = level_status.mid_lookahead;
        *mpc_level = level_status.mid_mpc_level;
    } else {
        *is_mid_search = false;
        *depth = n_empties;
        if (n_empties > level_status.complete1) {
            *mpc_level = level_status.complete0_mpc_level;
        } else if (n_empties > level_status.complete2) {
            *mpc_level = level_status.complete1_mpc_level;
        } else if (n_empties > level_status.complete3) {
            *mpc_level = level_status.complete2_mpc_level;
        } else if (n_empties > level_status.complete4) {
            *mpc_level = level_status.complete3_mpc_level;
        } else {
            *mpc_level = level_status.complete4_mpc_level;
        }
    }
}


bool get_level_use_mpc(int level, int n_moves) {
    level = std::clamp(level, 1, 60);
    Level level_status = level_definition[level];
    int n_empties = 60 - n_moves;
    if (n_empties < level_status.complete0) {
        return level_status.mid_mpc_level != MPC_100_LEVEL;
    } else {
        if (n_empties > level_status.complete1) {
            return level_status.complete0_mpc_level != MPC_100_LEVEL;
        } else if (n_empties > level_status.complete2) {
            return level_status.complete1_mpc_level != MPC_100_LEVEL;
        } else if (n_empties > level_status.complete3) {
            return level_status.complete2_mpc_level != MPC_100_LEVEL;
        } else if (n_empties > level_status.complete4) {
            return level_status.complete3_mpc_level != MPC_100_LEVEL;
        } else {
            return level_status.complete4_mpc_level != MPC_100_LEVEL;
        }
    }
}


void get_level_depth(int level, int *mid_depth, int *end_depth) {
    level = std::clamp(level, 1, 60);
    *mid_depth = level_definition[level].mid_lookahead;
    *end_depth = level_definition[level].complete0;
}


bool get_level_midsearch(int level, int n_moves) {
    level = std::clamp(level, 1, 60);
    Level level_status = level_definition[level];
    int n_empties = 60 - n_moves;
    if (n_empties > level_status.complete0) {
        return true;
    } else {
        return false;
    }
}


int get_level_endsearch_depth(int level) {
    return level_definition[level].complete0;
}


int get_level_complete_depth(int level) {
    if (level_definition[level].complete0_mpc_level == MPC_100_LEVEL) {
        return level_definition[level].complete0;
    }
    if (level_definition[level].complete1_mpc_level == MPC_100_LEVEL) {
        return level_definition[level].complete1;
    }
    if (level_definition[level].complete2_mpc_level == MPC_100_LEVEL) {
        return level_definition[level].complete2;
    }
    if (level_definition[level].complete3_mpc_level == MPC_100_LEVEL) {
        return level_definition[level].complete3;
    }
    return level_definition[level].complete4;
}

int get_level_from_depth_mpc_level(int n_discs, int depth, int mpc_level) {
    int n_empties = HW2 - n_discs;
    if (depth >= n_empties) { 
        for (int level = 0; level < N_LEVEL; ++level) {
            if (level_definition[level].complete0 != NODEPTH && level_definition[level].complete0 >= depth && level_definition[level].complete0_mpc_level == mpc_level) {
                return level;
            }
            if (level_definition[level].complete1 != NODEPTH && level_definition[level].complete1 >= depth && level_definition[level].complete1_mpc_level == mpc_level) {
                return level;
            }
            if (level_definition[level].complete2 != NODEPTH && level_definition[level].complete2 >= depth && level_definition[level].complete2_mpc_level == mpc_level) {
                return level;
            }
            if (level_definition[level].complete3 != NODEPTH && level_definition[level].complete3 >= depth && level_definition[level].complete3_mpc_level == mpc_level) {
                return level;
            }
            if (level_definition[level].complete4 != NODEPTH && level_definition[level].complete4 >= depth && level_definition[level].complete4_mpc_level == mpc_level) {
                return level;
            }
        }
    }
    return depth; 
}

// ===== FILE: Egaroucid/src/engine/local_strategy.hpp =====



#pragma once
#include "ai.hpp"

#define LOCAL_STRATEGY_POLICY_NOT_CHANGED 0


#define LOCAL_STRATEGY_POLICY_CHANGED_GOOD_MOVE_FLIPPED 1
#define LOCAL_STRATEGY_POLICY_CHANGED_GOOD_MOVE_UNFLIPPED 2
#define LOCAL_STRATEGY_POLICY_CHANGED_BAD_MOVE_FLIPPED 4
#define LOCAL_STRATEGY_POLICY_CHANGED_BAD_MOVE_UNFLIPPED 8
#define LOCAL_STRATEGY_POLICY_CHANGED_PLAYER_CANPUT 16 
#define LOCAL_STRATEGY_POLICY_CHANGED_PLAYER_CANNOTPUT 32 
#define LOCAL_STRATEGY_POLICY_CHANGED_OPPONENT_CANPUT 64 
#define LOCAL_STRATEGY_POLICY_CHANGED_OPPONENT_CANNOTPUT 128 

#define LOCAL_STRATEGY_POLICY_CHANGE_BAD_MOVE_LOSS_THRESHOLD 2 
#define LOCAL_STRATEGY_POLICY_CHANGE_GOOD_MOVE_LOSS_THRESHOLD 6 

constexpr int MAX_LOCAL_STRATEGY_LEVEL = 25;

constexpr double local_strategy_cell_weight[HW2_P1][N_CELL_TYPE] = {
    {0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000},
    {0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000},
    {0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000},
    {0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000},
    {0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 35.9446},
    {0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.8169, 20.3119},
    {0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 64.0000, 20.8794, 17.2430},
    {0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -13.9275, 0.0000, -0.8433, -0.7167, 2.1834},
    {0.0000, 0.0000, 0.0000, 0.0000, 36.0008, -9.9566, 11.0838, 12.2988, 2.7371, 1.4415},
    {0.0000, -18.1895, -9.0195, 1.4466, -49.5676, -8.7377, -9.4421, -1.8396, -2.5018, -0.4200},
    {62.1743, -16.7449, 5.5544, 5.0160, -41.6905, -8.5904, -5.9412, -0.7858, -1.4242, -1.5837},
    {46.5245, -19.1576, 0.6120, 0.2820, -45.8374, -10.0821, -8.1021, -3.6418, -2.8625, -1.5600},
    {45.1350, -17.4974, 0.7622, -1.4379, -42.7405, -9.0215, -7.6316, -3.1431, -2.6992, -1.9420},
    {44.9177, -18.3463, -0.0504, -2.1638, -42.5875, -9.5728, -8.0137, -3.7735, -3.2138, -1.9275},
    {43.7127, -17.8035, -0.4463, -2.4987, -41.0401, -9.2611, -7.7909, -3.6852, -2.9848, -2.2829},
    {42.9512, -17.6589, -0.8615, -2.8725, -39.8712, -9.3284, -7.6042, -3.7108, -3.2181, -2.1245},
    {42.0100, -17.1074, -1.2992, -2.8872, -38.3728, -9.1961, -7.4694, -3.6001, -3.1493, -2.1718},
    {40.7323, -16.7183, -1.3629, -3.0117, -37.5244, -8.9338, -7.4134, -3.5138, -3.2001, -2.0746},
    {40.0607, -16.3237, -1.5769, -3.3093, -36.2262, -8.6924, -7.1242, -3.4378, -3.2001, -2.0596},
    {39.1865, -15.6711, -1.5825, -3.1300, -34.9004, -8.5086, -6.9490, -3.3355, -3.1654, -2.0326},
    {38.5542, -15.1432, -1.6038, -3.1474, -33.6294, -8.3487, -6.8920, -3.2454, -3.1092, -2.1573},
    {37.3155, -14.7787, -1.7092, -2.8592, -32.0315, -8.1581, -6.6162, -3.0240, -3.0348, -1.7330},
    {36.7710, -14.1155, -1.8509, -2.9666, -31.2291, -8.0166, -6.4025, -3.0232, -2.9446, -1.7699},
    {35.7192, -13.5841, -1.6730, -2.7950, -29.7329, -7.7212, -6.2553, -2.8064, -2.7118, -1.6369},
    {35.1697, -13.2008, -1.6428, -2.8529, -28.3166, -7.5234, -6.0568, -2.8223, -2.7098, -1.6151},
    {34.0325, -12.5179, -1.7374, -2.6701, -27.2623, -7.3511, -5.8705, -2.6096, -2.5994, -1.5347},
    {33.3272, -11.9877, -1.7716, -2.5502, -26.2366, -7.1923, -5.7395, -2.5535, -2.5442, -1.3363},
    {32.2909, -11.3421, -1.7772, -2.2925, -24.4818, -6.9314, -5.5031, -2.3790, -2.3640, -1.2098},
    {32.0634, -11.0835, -1.8913, -2.1174, -23.6842, -6.6992, -5.4155, -2.3789, -2.3459, -1.2215},
    {31.0442, -10.2439, -1.4812, -1.9173, -22.4231, -6.4460, -5.1011, -2.2346, -2.2707, -1.0441},
    {30.5160, -9.8175, -1.5251, -1.8144, -21.5843, -6.3501, -5.0990, -2.1064, -2.2721, -0.9242},
    {29.3691, -9.3899, -1.3252, -1.8733, -20.2964, -6.0612, -4.8104, -2.0378, -2.0178, -0.8728},
    {29.0703, -8.8353, -1.3830, -1.6139, -19.2314, -5.8829, -4.6959, -1.9525, -2.0162, -0.7884},
    {28.0705, -8.3286, -1.0337, -1.3260, -18.2903, -5.6623, -4.5172, -1.7964, -1.8427, -0.6929},
    {27.6494, -7.8301, -1.3695, -1.2985, -17.4495, -5.6024, -4.3762, -1.8209, -1.7366, -0.6917},
    {26.8963, -7.3670, -1.2737, -1.0379, -16.2258, -5.2222, -4.0763, -1.6847, -1.6581, -0.6373},
    {26.4801, -6.9864, -1.0709, -1.0081, -15.7679, -5.2048, -3.9779, -1.6550, -1.5738, -0.4424},
    {25.2689, -6.3167, -0.9900, -0.7440, -14.8929, -4.8388, -3.8532, -1.6587, -1.4679, -0.4744},
    {25.2522, -6.2574, -0.8425, -0.8805, -14.0071, -4.7250, -3.6572, -1.5583, -1.4360, -0.3408},
    {23.8502, -5.4857, -0.7664, -0.6897, -13.3102, -4.4711, -3.5523, -1.4488, -1.2720, -0.3942},
    {23.6233, -5.2749, -0.8128, -0.4643, -12.8026, -4.3704, -3.4111, -1.4482, -1.2409, -0.2346},
    {22.7648, -4.5089, -0.5584, -0.2763, -11.5602, -4.1107, -3.2100, -1.3291, -1.1733, -0.1977},
    {22.3242, -4.3111, -0.3170, 0.0012, -10.8503, -3.9270, -3.0174, -1.2792, -1.0730, -0.1479},
    {21.4076, -3.7998, -0.3753, -0.1576, -10.3660, -3.8177, -2.9003, -1.2135, -0.9481, -0.1471},
    {20.9582, -3.4324, 0.0446, 0.1502, -10.4060, -3.9096, -2.8884, -1.2502, -1.0162, -0.0750},
    {20.1086, -3.0138, -0.0236, 0.2738, -9.5010, -3.5025, -2.5952, -1.1278, -0.7740, -0.0042},
    {19.5744, -2.5730, 0.1534, 0.2918, -9.0620, -3.4494, -2.5402, -1.0436, -0.7788, 0.0720},
    {18.7738, -2.4116, 0.2340, 0.4364, -8.3068, -3.1902, -2.2212, -0.9684, -0.6186, 0.0572},
    {18.2082, -1.9922, 0.3182, 0.6426, -7.8138, -2.9436, -2.1834, -0.9604, -0.5476, 0.0516},
    {17.3450, -1.3742, 0.3772, 0.7106, -6.9870, -2.7112, -1.9148, -0.8046, -0.4786, 0.1226},
    {16.8198, -1.1282, 0.7694, 0.8940, -6.6340, -2.6640, -1.7026, -0.7358, -0.3107, 0.1200},
    {15.7418, -0.7934, 0.8556, 0.9290, -5.9022, -2.2322, -1.4278, -0.6124, -0.3724, 0.2206},
    {15.3268, -0.3386, 0.8984, 1.0956, -5.4134, -2.2084, -1.4526, -0.6556, -0.1786, 0.3306},
    {14.4972, -0.0308, 0.8974, 1.1072, -4.6116, -1.8592, -1.0333, -0.4014, -0.0218, 0.3482},
    {13.5282, 0.1494, 1.1921, 1.1264, -4.3238, -1.5056, -0.9340, -0.3048, 0.0336, 0.4498},
    {12.7834, 0.5172, 1.2282, 1.4554, -3.6248, -1.2640, -0.5988, -0.1998, 0.1786, 0.4418},
    {11.8684, 0.6774, 1.2466, 1.3520, -3.0590, -0.9594, -0.5746, 0.0300, 0.2978, 0.6152},
    {10.7788, 1.1992, 1.4726, 1.5150, -2.5382, -0.5088, -0.1092, 0.0940, 0.5534, 0.7082},
    {9.8364, 1.4818, 1.4300, 1.5604, -1.6806, -0.0258, 0.3310, 0.4557, 0.6984, 0.8032},
    {8.5496, 1.7428, 1.5438, 1.6206, -0.8102, 0.3442, 0.5180, 0.4762, 0.7564, 0.9188},
    {6.8470, 1.7904, 1.8358, 1.6008, 0.4054, 1.0384, 1.1456, 0.8252, 1.2544, 1.0964},
    {5.1758, 2.1170, 1.8724, 1.4832, 2.1156, 1.9396, 1.5902, 1.2552, 1.1616, 1.0056},
    {2.2740, 2.1902, 1.0258, 1.3252, 4.2662, 2.7912, 2.1468, 1.4662, 1.3404, 0.9242},
    {-2.1394, 2.2954, 0.2222, -0.6540, 8.4924, 3.8908, 2.6462, 1.2518, 1.3726, 0.3190},
    {2.0000, 2.0000, 2.0000, 2.0000, 2.0000, 2.0000, 2.0000, 2.0000, 2.0000, 2.0000}
};

void print_local_strategy(const double arr[]) {
    for (int y = 0; y < HW; ++y) {
        for (int x = 0; x < HW; ++x) {
            int cell = HW2_M1 - (y * HW + x);
            std::cout << std::fixed << std::setprecision(3) << arr[cell] << " ";
        }
        std::cout << std::endl;
    }
}

void print_local_strategy(const int arr[]) {
    for (int y = 0; y < HW; ++y) {
        for (int x = 0; x < HW; ++x) {
            int cell = HW2_M1 - (y * HW + x);
            std::cout << std::fixed << std::setprecision(3) << arr[cell] << " ";
        }
        std::cout << std::endl;
    }
}


void calc_local_strategy_player(Board board, int max_level, double res[], int player, bool *searching, int *done_level, bool show_log) {
    for (int cell = 0; cell < HW2; ++cell) {
        res[cell] = 0.0;
    }
    double value_diffs[HW2];
    constexpr uint64_t edge_bits[4] = {0x7E00000000000000ULL, 0x0001010101010100ULL, 0x000000000000007EULL, 0x0080808080808000ULL};
    constexpr uint64_t corner_bits_next_to_edge[4] = {0x8100000000000000ULL, 0x0100000000000001ULL, 0x0000000000000081ULL, 0x8000000000000080ULL};
    for (int level = 1; level < max_level && *searching && global_searching; ++level) {
        Search_result actual_result = ai_searching(board, level, true, 0, true, false, searching);
        if (show_log) {
            std::cerr << "level " << level << " result " << actual_result.value << std::endl;
        }
        for (int cell = 0; cell < HW2; ++cell) {
            value_diffs[cell] = 0;
        }
        uint64_t done_cells = 0;
        for (int cell = 0; cell < HW2 && *searching && global_searching; ++cell) {
            if ((board.invalid_mask >> cell) & 1ULL) continue;
            uint64_t bit = 1ULL << cell;
            if (done_cells & bit) {
                continue;
            }
            if ((board.player | board.opponent) & bit) { 
                uint64_t bits = bit;
                for (int i = 0; i < 4; ++i) {
                    if ((edge_bits[i] & bit) && (corner_bits_next_to_edge[i] & (board.player | board.opponent)) == 0) {
                        bits = edge_bits[i] & (board.player | board.opponent);
                        break;
                    }
                }
                
                board.player ^= bits;
                board.opponent ^= bits;
                    Search_result result = ai_searching(board, level, true, 0, true, false, searching);
                    uint64_t bits_cpy = bits;
                    int n_bits = pop_count_ull(bits);
                    for (uint_fast8_t c = first_bit(&bits_cpy); bits_cpy; c = next_bit(&bits_cpy)) {
                        value_diffs[c] = -(double)(result.value - actual_result.value) / (double)n_bits;
                    }
                board.player ^= bits;
                board.opponent ^= bits;
                done_cells |= bits;
            } else { 
                done_cells |= bit;
            }
        }
        if (*searching && global_searching) {
            
            
            
            
            
            for (int cell = 0; cell < HW2; ++cell) {
                
                int sgn = player == BLACK ? 1 : -1;
                res[cell] = sgn * std::tanh(0.2 * value_diffs[cell]); 
            }
            
            
            
            *done_level = level;
            if (show_log) {
                std::cerr << "local strategy level " << level << std::endl;
            }
        }
    }
}


uint64_t get_connected_bits_dir4(uint64_t candidate, uint64_t bits, uint64_t cell_bit) {
    uint64_t neighbours = (cell_bit & 0x7F7F7F7F7F7F7F7FULL) << 1;
    neighbours |= (cell_bit & 0xFEFEFEFEFEFEFEFEULL) >> 1;
    neighbours |= cell_bit << 8;
    neighbours |= cell_bit >> 8;
    neighbours &= candidate;
    neighbours &= ~bits;
    if (neighbours) {
        bits |= neighbours;
        for (uint_fast8_t cell = first_bit(&neighbours); neighbours; cell = next_bit(&neighbours)) {
            bits |= get_connected_bits_dir4(candidate, bits, 1ULL << cell);
        }
    }
    return bits;
}

uint64_t get_connected_bits_dir8(uint64_t candidate, uint64_t bits, uint64_t cell_bit) {
    uint64_t neighbours = (cell_bit & 0x7F7F7F7F7F7F7F7FULL) << 1;
    neighbours |= (cell_bit & 0xFEFEFEFEFEFEFEFEULL) >> 1;
    neighbours |= cell_bit << 8;
    neighbours |= cell_bit >> 8;
    neighbours |= (cell_bit & 0x007F7F7F7F7F7F7FULL) << 9;
    neighbours |= (cell_bit & 0xFEFEFEFEFEFEFE00ULL) >> 9;
    neighbours |= (cell_bit & 0x00FEFEFEFEFEFEFEULL) << 7;
    neighbours |= (cell_bit & 0x7F7F7F7F7F7F7F00ULL) >> 7;
    neighbours &= candidate;
    neighbours &= ~bits;
    if (neighbours) {
        bits |= neighbours;
        for (uint_fast8_t cell = first_bit(&neighbours); neighbours; cell = next_bit(&neighbours)) {
            bits |= get_connected_bits_dir8(candidate, bits, 1ULL << cell);
        }
    }
    return bits;
}

uint64_t get_connected_bits_horizontal(uint64_t candidate, uint64_t bits, uint64_t cell_bit) {
    uint64_t neighbours = (cell_bit & 0x7F7F7F7F7F7F7F7FULL) << 1;
    neighbours |= (cell_bit & 0xFEFEFEFEFEFEFEFEULL) >> 1;
    neighbours &= candidate;
    neighbours &= ~bits;
    if (neighbours) {
        bits |= neighbours;
        for (uint_fast8_t cell = first_bit(&neighbours); neighbours; cell = next_bit(&neighbours)) {
            bits |= get_connected_bits_horizontal(candidate, bits, 1ULL << cell);
        }
    }
    return bits;
}

uint64_t get_connected_bits_vertical(uint64_t candidate, uint64_t bits, uint64_t cell_bit) {
    uint64_t neighbours = cell_bit << 8;
    neighbours |= cell_bit >> 8;
    neighbours &= candidate;
    neighbours &= ~bits;
    if (neighbours) {
        bits |= neighbours;
        for (uint_fast8_t cell = first_bit(&neighbours); neighbours; cell = next_bit(&neighbours)) {
            bits |= get_connected_bits_vertical(candidate, bits, 1ULL << cell);
        }
    }
    return bits;
}

uint64_t get_connected_bits_diagonal9(uint64_t candidate, uint64_t bits, uint64_t cell_bit) {
    uint64_t neighbours = (cell_bit & 0x007F7F7F7F7F7F7FULL) << 9;
    neighbours |= (cell_bit & 0xFEFEFEFEFEFEFE00ULL) >> 9;
    neighbours &= candidate;
    neighbours &= ~bits;
    if (neighbours) {
        bits |= neighbours;
        for (uint_fast8_t cell = first_bit(&neighbours); neighbours; cell = next_bit(&neighbours)) {
            bits |= get_connected_bits_diagonal9(candidate, bits, 1ULL << cell);
        }
    }
    return bits;
}

uint64_t get_connected_bits_diagonal7(uint64_t candidate, uint64_t bits, uint64_t cell_bit) {
    uint64_t neighbours = (cell_bit & 0x00FEFEFEFEFEFEFEULL) << 7;
    neighbours |= (cell_bit & 0x7F7F7F7F7F7F7F00ULL) >> 7;
    neighbours &= candidate;
    neighbours &= ~bits;
    if (neighbours) {
        bits |= neighbours;
        for (uint_fast8_t cell = first_bit(&neighbours); neighbours; cell = next_bit(&neighbours)) {
            bits |= get_connected_bits_diagonal7(candidate, bits, 1ULL << cell);
        }
    }
    return bits;
}

uint64_t get_left_bit(uint64_t cell_bit) {
    return (cell_bit & 0x7F7F7F7F7F7F7F7FULL) << 1;
}

uint64_t get_right_bit(uint64_t cell_bit) {
    return (cell_bit & 0xFEFEFEFEFEFEFEFEULL) >> 1;
}

uint64_t get_up_bit(uint64_t cell_bit) {
    return cell_bit << 8;
}

uint64_t get_down_bit(uint64_t cell_bit) {
    return cell_bit >> 8;
}

uint64_t get_d7up_bit(uint64_t cell_bit) {
    return (cell_bit & 0x00FEFEFEFEFEFEFEULL) << 7;
}

uint64_t get_d7down_bit(uint64_t cell_bit) {
    return (cell_bit & 0x7F7F7F7F7F7F7F00ULL) >> 7;
}

uint64_t get_d9up_bit(uint64_t cell_bit) {
    return (cell_bit & 0x007F7F7F7F7F7F7FULL) << 9;
}

uint64_t get_d9down_bit(uint64_t cell_bit) {
    return (cell_bit & 0xFEFEFEFEFEFEFE00ULL) >> 9;
}

uint64_t (*get_neighbour_bit[])(uint64_t) = {get_left_bit, get_right_bit, get_up_bit, get_down_bit, get_d7up_bit, get_d7down_bit, get_d9up_bit, get_d9down_bit};

uint64_t get_connected_bits(uint64_t candidate, uint64_t bits, uint64_t cell_bit, uint64_t (*neighbour_bit_func)(uint64_t)) {
    uint64_t neighbours = neighbour_bit_func(cell_bit);
    neighbours &= candidate;
    neighbours &= ~bits;
    if (neighbours) {
        bits |= neighbours;
        for (uint_fast8_t cell = first_bit(&neighbours); neighbours; cell = next_bit(&neighbours)) {
            bits |= get_connected_bits(candidate, bits, 1ULL << cell, neighbour_bit_func);
        }
    }
    return bits;
}


void calc_local_strategy_policy(Board board, int max_level, int policy_res[HW2][HW2], bool *searching, int *done_level, bool show_log) {
    for (int policy = 0; policy < HW2; ++policy) {
        for (int cell = 0; cell < HW2; ++cell) {
            policy_res[policy][cell] = LOCAL_STRATEGY_POLICY_NOT_CHANGED;
        }
    }
    int policy_changed[HW2][HW2]; 
    const uint64_t actual_legal_player = board.get_legal();
    board.pass();
        const uint64_t actual_legal_opponent = board.get_legal();
    board.pass();
    for (int level = 1; level < max_level && *searching && global_searching; ++level) {
        std::vector<Search_result> actual_results = ai_best_moves_loss_searching(board, level, true, 0, true, false, 1, searching); 
        std::vector<int> actual_best_moves;
        for (const Search_result &result: actual_results) {
            actual_best_moves.push_back(result.policy);
        }
        uint64_t legal = board.get_legal();
        Flip flip;
        for (uint_fast8_t policy = first_bit(&legal); legal && *searching; policy = next_bit(&legal)) {
            bool policy_is_good_move = std::find(actual_best_moves.begin(), actual_best_moves.end(), policy) != actual_best_moves.end();
            for (int cell = 0; cell < HW2; ++cell) {
                policy_changed[policy][cell] = LOCAL_STRATEGY_POLICY_NOT_CHANGED;
            }
            calc_flip(&flip, &board, policy);
            uint64_t policy_bit = 1ULL << policy;
            for (int dir = 0; dir < 8; ++dir) {
                
                uint64_t can_be_flipped_1dir = get_connected_bits(board.opponent, 0, policy_bit, get_neighbour_bit[dir]);
                if (can_be_flipped_1dir) {
                    flip.flip ^= can_be_flipped_1dir;
                    board.move_board(&flip);
                        int g = -ai_searching(board, level, true, 0, true, false, searching).value;
                    board.undo_board(&flip);
                    flip.flip ^= can_be_flipped_1dir;
                    int n_flipped = pop_count_ull(can_be_flipped_1dir);
                    if (g >= actual_results[0].value - 1) { 
                        if (!policy_is_good_move) { 
                            for (uint_fast8_t c = first_bit(&can_be_flipped_1dir); can_be_flipped_1dir; c = next_bit(&can_be_flipped_1dir)) {
                                if (flip.flip & can_be_flipped_1dir) {
                                    policy_changed[policy][c] |= LOCAL_STRATEGY_POLICY_CHANGED_BAD_MOVE_FLIPPED; 
                                } else if (n_flipped > 1) {
                                    policy_changed[policy][c] |= LOCAL_STRATEGY_POLICY_CHANGED_BAD_MOVE_UNFLIPPED; 
                                }
                            }
                        }
                    } else { 
                        if (policy_is_good_move) { 
                            for (uint_fast8_t c = first_bit(&can_be_flipped_1dir); can_be_flipped_1dir; c = next_bit(&can_be_flipped_1dir)) {
                                if (flip.flip & can_be_flipped_1dir) {
                                    policy_changed[policy][c] |= LOCAL_STRATEGY_POLICY_CHANGED_GOOD_MOVE_FLIPPED; 
                                } else if (n_flipped > 1) {
                                    policy_changed[policy][c] |= LOCAL_STRATEGY_POLICY_CHANGED_GOOD_MOVE_UNFLIPPED; 
                                }
                            }
                        }
                    }
                }
                
            }
            board.move_board(&flip);
                uint64_t modified_legal_opponent = board.get_legal();
                board.pass();
                    uint64_t modified_legal_player = board.get_legal();
                board.pass();
            board.undo_board(&flip);
            uint64_t non_legal_to_legal_player = ~actual_legal_player & modified_legal_player; 
            uint64_t legal_to_non_legal_player = (actual_legal_player & ~modified_legal_player) & ~(1ULL << policy); 
            uint64_t non_legal_to_legal_opponent = ~actual_legal_opponent & modified_legal_opponent; 
            uint64_t legal_to_non_legal_opponent = actual_legal_opponent & ~modified_legal_opponent; 
            if (policy_is_good_move) {
                for (uint_fast8_t c = first_bit(&non_legal_to_legal_player); non_legal_to_legal_player; c = next_bit(&non_legal_to_legal_player)) {
                    policy_changed[policy][c] |= LOCAL_STRATEGY_POLICY_CHANGED_PLAYER_CANPUT; 
                }
                for (uint_fast8_t c = first_bit(&legal_to_non_legal_opponent); legal_to_non_legal_opponent; c = next_bit(&legal_to_non_legal_opponent)) {
                    policy_changed[policy][c] |= LOCAL_STRATEGY_POLICY_CHANGED_OPPONENT_CANNOTPUT; 
                }
            } else { 
                for (uint_fast8_t c = first_bit(&legal_to_non_legal_player); legal_to_non_legal_player; c = next_bit(&legal_to_non_legal_player)) {
                    policy_changed[policy][c] |= LOCAL_STRATEGY_POLICY_CHANGED_PLAYER_CANNOTPUT; 
                }
                for (uint_fast8_t c = first_bit(&non_legal_to_legal_opponent); non_legal_to_legal_opponent; c = next_bit(&non_legal_to_legal_opponent)) {
                    policy_changed[policy][c] |= LOCAL_STRATEGY_POLICY_CHANGED_OPPONENT_CANPUT; 
                }
            }
            
            if (*searching && global_searching) {
                for (int cell = 0; cell < HW2; ++cell) {
                    policy_res[policy][cell] = policy_changed[policy][cell];
                }
            }
        }
        if (*searching && global_searching) {
            *done_level = level;
            if (show_log) {
                std::cerr << "local strategy policy level " << level << std::endl;
            }
        }
    }
}






#if TUNE_LOCAL_STRATEGY

void tune_local_strategy() {
    int n_max = 10000000; 
    int n_min = 10000;
    int level = 10;

    double res[HW2_P1][N_CELL_TYPE];
    int count[HW2_P1][N_CELL_TYPE];

    for (int i = 0; i < HW2; ++i) {
        for (int j = 0; j < N_CELL_TYPE; ++j) {
            res[i][j] = 0.0;
            count[i][j] = 0;
        }
    }

    Board board;
    Flip flip;
    for (int n_discs = 4; n_discs <= HW2; ++n_discs) {
        std::cerr << '\r' << "                                                                   ";
        std::cerr << '\r' << "n_discs " << n_discs << " type ";
        for (int cell_type = 0; cell_type < N_CELL_TYPE; ++cell_type) {
            std::cerr << cell_type << " ";
            for (int i = 0; i < n_max && count[n_discs][cell_type] < n_min; ++i) {
                board.reset();
                while (board.n_discs() < n_discs && board.check_pass()) {
                    uint64_t legal = board.get_legal();
                    int random_idx = myrandrange(0, pop_count_ull(legal));
                    int t = 0;
                    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
                        if (t == random_idx) {
                            calc_flip(&flip, &board, cell);
                            break;
                        }
                        ++t;
                    }
                    board.move_board(&flip);
                }
                
                if ((board.player | board.opponent) & cell_type_mask[cell_type]) {
                    uint64_t can_be_masked = (board.player | board.opponent) & cell_type_mask[cell_type];
                    int random_idx = myrandrange(0, pop_count_ull(can_be_masked));
                    int t = 0;
                    uint64_t flipped = 0;
                    for (uint_fast8_t cell = first_bit(&can_be_masked); can_be_masked; cell = next_bit(&can_be_masked)) {
                        if (t == random_idx) {
                            flipped = 1ULL << cell;
                            break;
                        }
                        ++t;
                    }
                    Search_result actual_result = ai(board, level, true, 0, true, false);
                    int sgn = -1; 
                    if (board.player & flipped) { 
                        sgn = 1;
                    }
                    board.player ^= flipped;
                    board.opponent ^= flipped;
                        Search_result flipped_result = ai(board, level, true, 0, true, false);
                    board.player ^= flipped;
                    board.opponent ^= flipped;
                    double diff = sgn * (actual_result.value - flipped_result.value);
                    res[n_discs][cell_type] += diff;
                    ++count[n_discs][cell_type];
                }
                
            }
            if (count[n_discs][cell_type]) {
                res[n_discs][cell_type] /= count[n_discs][cell_type];
            }
        }
        std::cerr << '\r' << n_discs << " ";
        for (int j = 0; j < N_CELL_TYPE; ++j) {
            std::cerr << count[n_discs][j] << " ";
        }
        std::cerr << std::endl;
        std::cout << "{";
        for (int j = 0; j < N_CELL_TYPE; ++j) {
            std::cout << std::fixed << std::setprecision(4) << res[n_discs][j];
            if (j < N_CELL_TYPE - 1) {
                std::cout << ", ";
            }
        }
        std::cout << "}," << std::endl;
    }
    std::cerr << std::endl;

    std::cerr << "count" << std::endl;
    for (int i = 0; i <= HW2; ++i) {
        std::cout << "{";
        for (int j = 0; j < N_CELL_TYPE; ++j) {
            std::cerr << count[i][j];
            if (j < N_CELL_TYPE - 1) {
                std::cerr << ", ";
            }
        }
        std::cout << "}," << std::endl;
    }
    std::cerr << "res" << std::endl;
    for (int i = 0; i <= HW2; ++i) {
        std::cout << "{";
        for (int j = 0; j < N_CELL_TYPE; ++j) {
            std::cout << std::fixed << std::setprecision(4) << res[i][j];
            if (j < N_CELL_TYPE - 1) {
                std::cout << ", ";
            }
        }
        std::cout << "}," << std::endl;
    }
}

#endif

// ===== FILE: Egaroucid/src/engine/midsearch.hpp =====

ï»¿

#pragma once
#include <iostream>
#include <algorithm>
#include <vector>
#include <future>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "evaluate.hpp"
#include "search.hpp"
#include "transposition_table.hpp"
#include "transposition_cutoff.hpp"
#include "move_ordering.hpp"
#include "multi_probcut.hpp"
#include "thread_pool.hpp"
#include "util.hpp"
#include "stability_cutoff.hpp"
#include "endsearch.hpp"
#include "midsearch_nws.hpp"
#include "book.hpp"

inline int aspiration_search(Search *search, int alpha, int beta, int predicted_value, const int depth, const bool skipped, uint64_t legal, const bool is_end_search, bool *searching);


inline int nega_alpha_eval1(Search *search, int alpha, int beta, const bool skipped) {
    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[search->n_discs];
#endif
    int v = -SCORE_INF;
    uint64_t legal = search->board.get_legal();
    if (legal == 0ULL) {
        if (skipped) {
            return end_evaluate(&search->board);
        }
        search->pass();
            v = -nega_alpha_eval1(search, -beta, -alpha, true);
        search->pass();
        return v;
    }
    int g;
    Flip flip;
    for (int i = 0; i < N_STATIC_CELL_PRIORITY; ++i) {
        uint64_t l = legal & static_cell_priority[i];
        for (uint_fast8_t cell = first_bit(&l); l; cell = next_bit(&l)) {
            if ((search->board.invalid_mask >> cell) & 1ULL) continue;
            calc_flip(&flip, &search->board, cell);
            search->move(&flip);
                ++search->n_nodes;
                g = -mid_evaluate_diff(search);
            search->undo(&flip);
            if (v < g) {
                if (alpha < g) {
                    if (beta <= g) {
                        return g;
                    }
                    alpha = g;
                }
                v = g;
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    return v;
}












































int nega_scout(Search *search, int alpha, int beta, const int depth, const bool skipped, uint64_t legal, const bool is_end_search, bool *searching) {
    if (!global_searching || !(*searching)) {
        return SCORE_UNDEFINED;
    }
    if (alpha + 1 == beta) {
        return nega_alpha_ordering_nws(search, alpha, depth, skipped, legal, is_end_search, searching);
    }
    if (is_end_search && search->n_discs == HW2 - 4) {
        return -last4(search, -beta, -alpha);
    }
    if (search->n_discs == HW2) {
        return end_evaluate(&search->board);
    }
    if (!is_end_search) {
        if (depth == 1) {
            return nega_alpha_eval1(search, alpha, beta, skipped);
        }
        if (depth == 0) {
            ++search->n_nodes;
            return mid_evaluate_diff(search);
        }
    }
    ++search->n_nodes;
    int first_alpha = alpha;
    int first_beta = beta;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[search->n_discs];
#endif
#if USE_END_SC
    if (is_end_search) {
        int stab_res = stability_cut(search, &alpha, &beta);
        if (stab_res != SCORE_UNDEFINED) {
            return stab_res;
        }
    }
#endif
    if (legal == LEGAL_UNDEFINED) {
        legal = search->board.get_legal();
    }
    int v = -SCORE_INF;
    if (legal == 0ULL) {
        if (skipped) {
            return end_evaluate(&search->board);
        }
        search->pass();
            v = -nega_scout(search, -beta, -alpha, depth, true, LEGAL_UNDEFINED, is_end_search, searching);
        search->pass();
        return v;
    }
    uint32_t hash_code = search->board.hash();
    transposition_table.prefetch(hash_code);
    uint_fast8_t moves[N_TRANSPOSITION_MOVES] = {MOVE_UNDEFINED, MOVE_UNDEFINED};
    if (transposition_cutoff(search, hash_code, depth, &alpha, &beta, &v, moves)) {
        return v;
    }
    int best_move = MOVE_UNDEFINED;
    const int canput = pop_count_ull(legal);
    
    Flip_value move_list[MAX_N_BRANCHES];
    int idx = 0;
    int tt_moves_idx0 = -1;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
if ((search->board.invalid_mask >> cell) & 1ULL) continue;    calc_flip(&move_list[idx].flip, &search->board, cell);
        if (move_list[idx].flip.flip == search->board.opponent) {
            return SCORE_MAX;
        }
        if (cell == moves[0]) {
            tt_moves_idx0 = idx;
        }
        ++idx;
    }
    int n_etc_done = 0;
#if USE_MID_ETC
    if (depth >= MID_ETC_DEPTH) {
        if (etc(search, move_list, canput, depth, &alpha, &beta, &v, &n_etc_done)) {
            return v;
        }
    }
#endif
#if USE_MID_MPC
    if (search->mpc_level < MPC_100_LEVEL && depth >= USE_MPC_MIN_DEPTH) {
        if (mpc(search, alpha, beta, depth, legal, is_end_search, &v, searching)) {
            return v;
        }
    }
#endif
    int g;
#if USE_ASPIRATION_NEGASCOUT
    if (beta - alpha >= 4 && depth >= 5) {
        int l = -HW2, u = HW2;
        transposition_table.get_bounds(search, hash_code, depth - 5, &l, &u);
        if (l == u && alpha < l && l < beta && !((l % 2) && is_end_search)) {
            return aspiration_search(search, alpha, beta, l, depth, skipped, legal, is_end_search, searching);
        }
    }
#endif
    bool serial_searched = false;
    if (tt_moves_idx0 != -1 && move_list[tt_moves_idx0].flip.flip) {
        search->move(&move_list[tt_moves_idx0].flip);
            g = -nega_scout(search, -beta, -alpha, depth - 1, false, move_list[tt_moves_idx0].n_legal, is_end_search, searching);
        search->undo(&move_list[tt_moves_idx0].flip);
        if (v < g) {
            v = g;
            best_move = move_list[tt_moves_idx0].flip.pos;
            if (alpha < v) {
                alpha = v;
            }
        }
        serial_searched = true;
        move_list[tt_moves_idx0].flip.flip = 0;
        move_list[tt_moves_idx0].value = -INF;
    }
    if (alpha < beta) {
        move_list_evaluate(search, move_list, canput, moves, depth, alpha, beta, searching);
#if USE_YBWC_NEGASCOUT
        if (search->use_multi_thread && ((!is_end_search && depth - 1 >= YBWC_MID_SPLIT_MIN_DEPTH) || (is_end_search && depth - 1 >= YBWC_END_SPLIT_MIN_DEPTH))) {
            move_list_sort(move_list, canput);
            if (move_list[0].flip.flip) {
                if (!serial_searched) {
                    search->move(&move_list[0].flip);
                        g = -nega_scout(search, -beta, -alpha, depth - 1, false, move_list[0].n_legal, is_end_search, searching);
                    search->undo(&move_list[0].flip);
                    move_list[0].flip.flip = 0;
                    if (v < g) {
                        v = g;
                        best_move = move_list[0].flip.pos;
                        if (alpha < v) {
                            alpha = v;
                        }
                    }
                }
                if (alpha < beta) {
                    ybwc_search_young_brothers(search, &alpha, &beta, &v, &best_move, canput - n_etc_done - 1, hash_code, depth, is_end_search, move_list, canput, false, searching);
                }
            }
        } else{
#endif
            for (int move_idx = 0; move_idx < canput - n_etc_done && *searching; ++move_idx) {
                swap_next_best_move(move_list, move_idx, canput);
#if USE_MID_ETC
                if (move_list[move_idx].flip.flip == 0) {
                    break;
                }
#endif
                search->move(&move_list[move_idx].flip);
                    if (v == -SCORE_INF) {
                        g = -nega_scout(search, -beta, -alpha, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searching);
                    } else{
                        g = -nega_alpha_ordering_nws(search, -alpha - 1, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searching);
                        if (alpha < g && g < beta) {
                            g = -nega_scout(search, -beta, -g, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searching);
                        }
                    }
                search->undo(&move_list[move_idx].flip);
                if (v < g) {
                    v = g;
                    best_move = move_list[move_idx].flip.pos;
                    if (alpha < v) {
                        if (beta <= v) {
#if USE_KILLER_MOVE_MO
                            
                            search->update_heuristics_on_cutoff(move_list[move_idx].flip.pos, depth);
#endif
                            break;
                        }
                        alpha = v;
                    }
                }
            }
#if USE_YBWC_NEGASCOUT
        }
#endif
    }
    if (*searching && global_searching) {
        transposition_table.reg(search, hash_code, depth, first_alpha, first_beta, v, best_move);
    }
    return v;
}







































































































































#if USE_ASPIRATION_NEGASCOUT

inline int aspiration_search(Search *search, int alpha, int beta, int predicted_value, const int depth, const bool skipped, uint64_t legal, const bool is_end_search, bool *searching) {
    int pred_alpha = predicted_value - 1;
    int pred_beta = predicted_value + 1;
    int g = nega_scout(search, pred_alpha, pred_beta, depth, false, LEGAL_UNDEFINED, is_end_search, searching);
    if (pred_alpha < g && g < pred_beta) {
        return g;
    } else if (g <= pred_alpha) {
        if (g <= alpha) {
            return g;
        }
        beta = g;
    } else if (pred_beta <= g) {
        if (beta <= g) {
            return g;
        }
        alpha = g;
    }
    return nega_scout(search, alpha, beta, depth, false, LEGAL_UNDEFINED, is_end_search, searching);
}
#endif


std::pair<int, int> first_nega_scout_legal(Search *search, int alpha, int beta, const int depth, const bool is_end_search, const std::vector<Clog_result> clogs, uint64_t legal, uint64_t strt, bool *searching) {
    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[search->n_discs];
#endif
    int g, v = -SCORE_INF, first_alpha = alpha;
    if (legal == 0ULL) {
        return std::make_pair(SCORE_UNDEFINED, -1);
    }
    bool is_all_legal = legal == search->board.get_legal();
    int best_move = MOVE_UNDEFINED;
    const int canput_all = pop_count_ull(legal);
    for (const Clog_result clog: clogs) {
        if (legal & (1ULL << clog.pos)) {
            if (v < clog.val) {
                v = clog.val;
                best_move = clog.pos;
                if (alpha < v) {
                    alpha = v;
                }
            }
            legal &= ~(1ULL << clog.pos);
        }
    }
    uint32_t hash_code = search->board.hash();
    if (alpha < beta && legal) {
        int pv_idx = 1;
        const int canput = pop_count_ull(legal);
        
        Flip_value move_list[MAX_N_BRANCHES];
        int idx = 0;
        for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
            calc_flip(&move_list[idx].flip, &search->board, cell);
            if (move_list[idx].flip.flip == search->board.opponent) {
                return std::make_pair(SCORE_MAX, (int)cell);
            }
            ++idx;
        }
        uint_fast8_t moves[N_TRANSPOSITION_MOVES] = {MOVE_UNDEFINED, MOVE_UNDEFINED};
        transposition_table.get_moves_any_level(&search->board, hash_code, moves);
        move_list_evaluate(search, move_list, canput, moves, depth, alpha, beta, searching);
#if USE_YBWC_NEGASCOUT
        if (
            search->use_multi_thread && 
            ((!is_end_search && depth - 1 >= YBWC_MID_SPLIT_MIN_DEPTH) || (is_end_search && depth - 1 >= YBWC_END_SPLIT_MIN_DEPTH)) 
            
        ) {
            move_list_sort(move_list, canput);
            if (move_list[0].flip.flip) {
                search->move(&move_list[0].flip);
                    g = -nega_scout(search, -beta, -alpha, depth - 1, false, move_list[0].n_legal, is_end_search, searching);
                search->undo(&move_list[0].flip);
                move_list[0].flip.flip = 0;
                if (v < g) {
                    v = g;
                    best_move = move_list[0].flip.pos;
                    if (alpha < v) {
                        alpha = v;
                    }
                }
                if (alpha < beta && *searching) {
                    ybwc_search_young_brothers(search, &alpha, &beta, &v, &best_move, canput - 1, hash_code, depth, is_end_search, move_list, canput, true, searching);
                }
            }
        } else{
#endif
            for (int move_idx = 0; move_idx < canput && *searching; ++move_idx) {
                swap_next_best_move(move_list, move_idx, canput);
                search->move(&move_list[move_idx].flip);
                    if (v == -SCORE_INF) {
                        g = -nega_scout(search, -beta, -alpha, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searching);
                    } else{
                        g = -nega_alpha_ordering_nws(search, -alpha - 1, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searching);
                        if (alpha < g && g < beta) {
                            g = -nega_scout(search, -beta, -g, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searching);
                        }
                    }
                search->undo(&move_list[move_idx].flip);
                
                if (v < g) {
                    v = g;
                    best_move = move_list[move_idx].flip.pos;
                    if (alpha < v) {
                        if (beta <= v) {
#if USE_KILLER_MOVE_MO
                            search->update_heuristics_on_cutoff(move_list[move_idx].flip.pos, depth);
#endif
                            break;
                        }
                        alpha = v;
                    }
                }
            }
#if USE_YBWC_NEGASCOUT
        }
#endif
    }
    if (*searching && global_searching && is_all_legal) {
        transposition_table.reg(search, hash_code, depth, first_alpha, beta, v, best_move);
    }
    return std::make_pair(v, best_move);
}


std::pair<int, int> first_nega_scout(Search *search, int alpha, int beta, const int depth, const bool is_end_search, const std::vector<Clog_result> clogs, uint64_t strt, bool *searching) {
    return first_nega_scout_legal(search, alpha, beta, depth, is_end_search, clogs, search->board.get_legal(), strt, searching);
}

Analyze_result first_nega_scout_analyze(Search *search, int alpha, int beta, const int depth, const bool is_end_search, const std::vector<Clog_result> clogs, int clog_depth, uint_fast8_t played_move, uint64_t strt, bool *searching) {
    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[search->n_discs];
#endif
    Analyze_result res;
    res.played_move = played_move;
    res.alt_score = -SCORE_INF;
    res.alt_move = MOVE_UNDEFINED;
    int g, first_alpha = alpha;
    uint64_t legal = search->board.get_legal();
    const int canput_all = pop_count_ull(legal);
    for (const Clog_result clog: clogs) {
        if (clog.pos == played_move) {
            res.played_score = clog.val;
            res.played_depth = clog_depth;
            res.played_probability = 100;
        } else if (res.alt_score < clog.val) {
            res.alt_score = clog.val;
            res.alt_move = clog.pos;
            res.alt_depth = clog_depth;
            res.alt_probability = 100;
            if (alpha < res.alt_score) {
                alpha = res.alt_score;
            }
        }
        legal &= ~(1ULL << clog.pos);
    }
    uint32_t hash_code = search->board.hash();
    if (alpha < beta && (legal & (1ULL << played_move))) {
        Flip flip;
        calc_flip(&flip, &search->board, played_move);
        search->move(&flip);
            if (book.contain(&search->board)) {
                res.played_depth = SEARCH_BOOK;
                res.played_score = -book.get(search->board).value;
            } else{
                res.played_depth = depth;
                res.played_probability = SELECTIVITY_PERCENTAGE[search->mpc_level];
                res.played_score = -nega_scout(search, -SCORE_MAX, SCORE_MAX, depth - 1, false, LEGAL_UNDEFINED, is_end_search, searching);
            }
        search->undo(&flip);
        legal ^= 1ULL << played_move;
    }
    if (alpha < beta && legal) {
        int pv_idx = 1;
        const int canput = pop_count_ull(legal);
        
        Flip_value move_list[MAX_N_BRANCHES];
        int idx = 0;
        for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
            
if ((search->board.invalid_mask >> cell) & 1ULL) continue;       calc_flip(&move_list[idx].flip, &search->board, cell);
            ++idx;
        }
        uint_fast8_t moves[N_TRANSPOSITION_MOVES] = {MOVE_UNDEFINED, MOVE_UNDEFINED};
        transposition_table.get_moves_any_level(&search->board, hash_code, moves);
        move_list_evaluate(search, move_list, canput, moves, depth, alpha, beta, searching);
#if USE_YBWC_NEGASCOUT_ANALYZE
        if (search->use_multi_thread && depth - 1 >= YBWC_MID_SPLIT_MIN_DEPTH) {
            move_list_sort(move_list);
            bool book_used = false;
            search->move(&move_list[0].flip);
                if (book.contain(&search->board)) {
                    book_used = true;
                    g = -book.get(search->board).value;
                } else {
                    g = -nega_scout(search, -beta, -alpha, depth - 1, false, move_list[0].n_legal, is_end_search, searching);
                }
            search->undo(&move_list[0].flip);
            move_list[0].flip.flip = 0;
            if (res.alt_score < g) {
                res.alt_score = g;
                res.alt_move = move_list[0].flip.pos;
                if (book_used) {
                    res.alt_depth = SEARCH_BOOK;
                } else {
                    res.alt_depth = depth;
                    res.alt_probability = SELECTIVITY_PERCENTAGE[search->mpc_level];
                }
                if (alpha < res.alt_score) {
                    alpha = res.alt_score;
                }
            }
            if (alpha < beta) {
                ybwc_search_young_brothers(search, &alpha, &beta, &res.alt_score, &res.alt_move, hash_code, depth, is_end_search, move_list, true, searching);
            }
        } else{
#endif
            for (int move_idx = 0; move_idx < canput && *searching; ++move_idx) {
                swap_next_best_move(move_list, move_idx, canput);
                bool book_used = false;
                search->move(&move_list[move_idx].flip);
                    if (book.contain(&search->board)) {
                        book_used = true;
                        g = -book.get(search->board).value;
                    } else{
                        if (res.alt_score == -SCORE_INF) {
                            g = -nega_scout(search, -beta, -alpha, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searching);
                        } else{
                            g = -nega_alpha_ordering_nws(search, -alpha - 1, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searching);
                            if (alpha < g && g < beta) {
                                g = -nega_scout(search, -beta, -g, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searching);
                            }
                        }
                    }
                search->undo(&move_list[move_idx].flip);
                if (res.alt_score < g) {
                    res.alt_score = g;
                    res.alt_move = move_list[move_idx].flip.pos;
                    if (book_used) {
                        res.alt_depth = SEARCH_BOOK;
                    } else{
                        res.alt_depth = depth;
                        res.alt_probability = SELECTIVITY_PERCENTAGE[search->mpc_level];
                    }
                    if (alpha < res.alt_score) {
                        if (beta <= res.alt_score) {
                            break;
                        }
                        alpha = res.alt_score;
                    }
                }
            }
#if USE_YBWC_NEGASCOUT_ANALYZE
        }
#endif
    }
    if (res.alt_score == -SCORE_INF) {
        res.alt_move = -1;
        res.alt_score = -SCORE_INF;
        res.alt_depth = -1;
        res.alt_probability = 0;
    }
    if (*searching && global_searching) {
        int v, best_move;
        if (res.played_score >= res.alt_score) {
            v = res.played_score;
            best_move = res.played_move;
        } else{
            v = res.alt_score;
            best_move = res.alt_move;
        }
        transposition_table.reg(search, hash_code, depth, first_alpha, beta, v, best_move);
    }
    return res;
}

// ===== FILE: Egaroucid/src/engine/midsearch_nws.hpp =====



#pragma once
#include <iostream>
#include <algorithm>
#include <vector>
#include <future>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "evaluate.hpp"
#include "search.hpp"
#include "transposition_table.hpp"
#include "transposition_cutoff.hpp"
#include "endsearch.hpp"
#include "move_ordering.hpp"
#include "multi_probcut.hpp"
#include "thread_pool.hpp"
#include "ybwc.hpp"
#include "util.hpp"
#include "stability_cutoff.hpp"

inline bool mpc(Search* search, int alpha, int beta, int depth, uint64_t legal, const bool is_end_search, int* v, std::vector<bool*> &searchings);
inline bool mpc(Search* search, int alpha, int beta, const int depth, uint64_t legal, const bool is_end_search, int* v, const bool* searching);


inline int nega_alpha_eval1_nws(Search *search, int alpha, const bool skipped) {
    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[search->n_discs];
#endif
    int v = -SCORE_INF;
    uint64_t legal = search->board.get_legal();
    if (legal == 0ULL) {
        if (skipped) {
            return end_evaluate(&search->board);
        }
        search->pass();
            v = -nega_alpha_eval1_nws(search, -alpha - 1, true);
        search->pass();
        return v;
    }
    int g;
    Flip flip;
    for (int i = 0; i < N_STATIC_CELL_PRIORITY; ++i) {
        uint64_t l = legal & static_cell_priority[i];
        for (uint_fast8_t cell = first_bit(&l); l; cell = next_bit(&l)) {
            calc_flip(&flip, &search->board, cell);
            search->move(&flip);
                ++search->n_nodes;
                g = -mid_evaluate_diff(search);
            search->undo(&flip);
            if (v < g) {
                if (alpha < g) {
                    return g;
                }
                v = g;
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    return v;
}



int nega_alpha_eval2_nws(Search *search, int alpha, const bool skipped, uint64_t legal, bool *searching) {
    if (!global_searching || !(*searching)) {
        return SCORE_UNDEFINED;
    }
    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[search->n_discs];
#endif
    if (legal == LEGAL_UNDEFINED) {
        legal = search->board.get_legal();
    }
    int v = -SCORE_INF;
    if (legal == 0ULL) {
        if (skipped) {
            return end_evaluate(&search->board);
        }
        search->pass();
            v = -nega_alpha_eval2_nws(search, -alpha - 1, true, LEGAL_UNDEFINED, searching);
        search->pass();
        return v;
    }
    uint32_t hash_code = search->board.hash();
    transposition_table.prefetch(hash_code);
    uint_fast8_t moves[N_TRANSPOSITION_MOVES] = {MOVE_UNDEFINED, MOVE_UNDEFINED};
    if (transposition_cutoff_nws(search, hash_code, 2, alpha, &v, moves)) {
        return v;
    }
    int best_move = MOVE_UNDEFINED;
    int g;
    Flip flip;
    for (int i = 0; i < N_TRANSPOSITION_MOVES; ++i) {
        if (moves[i] != MOVE_UNDEFINED) {
            calc_flip(&flip, &search->board, moves[i]);
            search->move(&flip);
                g = -nega_alpha_eval1_nws(search, -alpha - 1, false);
            search->undo(&flip);
            if (!(*searching)) {
                return SCORE_UNDEFINED;
            }
            legal ^= 1ULL << moves[i];
            if (v < g) {
                v = g;
                best_move = moves[i];
                if (alpha < g) {
                    break;
                }
            }
        }
    }
    for (int i = 0; i < N_STATIC_CELL_PRIORITY && v <= alpha; ++i) {
        uint64_t l = legal & static_cell_priority[i];
        for (uint_fast8_t cell = first_bit(&l); l; cell = next_bit(&l)) {
            calc_flip(&flip, &search->board, cell);
            search->move(&flip);
                g = -nega_alpha_eval1_nws(search, -alpha - 1, false);
            search->undo(&flip);
            if (!(*searching)) {
                return SCORE_UNDEFINED;
            }
            if (v < g) {
                v = g;
                best_move = cell;
                if (alpha < g) {
                    break;
                }
            }
        }
    }
    
    
    
    return v;
}



int nega_alpha_ordering_nws_simple(Search *search, int alpha, const int depth, const bool skipped, uint64_t legal, bool *searching) {
    if (!global_searching || !(*searching)) {
        return SCORE_UNDEFINED;
    }
    if (depth == 2) {
        return nega_alpha_eval2_nws(search, alpha, skipped, legal, searching);
    }
    if (depth == 1) {
        return nega_alpha_eval1_nws(search, alpha, skipped);
    }
    if (depth == 0) {
        ++search->n_nodes;
        return mid_evaluate_diff(search);
    }
    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[search->n_discs];
#endif
    if (legal == LEGAL_UNDEFINED) {
        legal = search->board.get_legal();
    }
    int v = -SCORE_INF;
    if (legal == 0ULL) {
        if (skipped) {
            return end_evaluate(&search->board);
        }
        search->pass();
            v = -nega_alpha_ordering_nws_simple(search, -alpha - 1, depth, true, LEGAL_UNDEFINED, searching);
        search->pass();
        return v;
    }
    uint32_t hash_code = search->board.hash();
    transposition_table.prefetch(hash_code);
    uint_fast8_t moves[N_TRANSPOSITION_MOVES] = {MOVE_UNDEFINED, MOVE_UNDEFINED};
    if (transposition_cutoff_nws(search, hash_code, depth, alpha, &v, moves)) {
        return v;
    }
#if USE_MID_MPC && MID_MPC_MIN_DEPTH <= MID_SIMPLE_ORDERING_DEPTH
    if (search->mpc_level < MPC_100_LEVEL && depth >= USE_MPC_MIN_DEPTH) {
        if (mpc(search, alpha, alpha + 1, depth, legal, false, &v, searching)) {
            return v;
        }
    }
#endif
    int best_move = MOVE_UNDEFINED;
    int g;
    const int canput = pop_count_ull(legal);
    Flip_value move_list[MAX_N_BRANCHES];
    
    int idx = 0;
    int tt_moves_idx0 = -1;
    
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&move_list[idx].flip, &search->board, cell);
        if (move_list[idx].flip.flip == search->board.opponent) {
            return SCORE_MAX;
        }
        if (cell == moves[0]) {
            tt_moves_idx0 = idx;
        }
        
        
        
        ++idx;
    }
#if USE_MID_ETC && MID_ETC_DEPTH_NWS <= MID_SIMPLE_ORDERING_DEPTH
    int n_etc_done = 0;
    if (depth >= MID_ETC_DEPTH_NWS) {
        if (etc_nws(search, move_list, canput, depth, alpha, &v, &n_etc_done)) {
            return v;
        }
    }
#endif
    if (tt_moves_idx0 != -1 && move_list[tt_moves_idx0].flip.flip) {
        search->move(&move_list[tt_moves_idx0].flip);
            g = -nega_alpha_ordering_nws_simple(search, -alpha - 1, depth - 1, false, move_list[tt_moves_idx0].n_legal, searching);
        search->undo(&move_list[tt_moves_idx0].flip);
        if (v < g) {
            v = g;
            best_move = move_list[tt_moves_idx0].flip.pos;
        }
        move_list[tt_moves_idx0].flip.flip = 0;
        move_list[tt_moves_idx0].value = -INF;
    }
    
    
    
    
    
    
    
    
    
    
    
    if (v <= alpha) {
        move_list_evaluate_nws(search, move_list, canput, moves, depth, alpha, searching);
#if USE_MID_ETC && MID_ETC_DEPTH_NWS <= MID_SIMPLE_ORDERING_DEPTH
        for (int move_idx = 0; move_idx < canput - n_etc_done && *searching; ++move_idx) {
#else
        for (int move_idx = 0; move_idx < canput && *searching; ++move_idx) {
#endif
            swap_next_best_move(move_list, move_idx, canput);
#if USE_MID_ETC && MID_ETC_DEPTH_NWS <= MID_SIMPLE_ORDERING_DEPTH
            if (move_list[move_idx].flip.flip == 0) {
                break;
            }
#endif
            search->move(&move_list[move_idx].flip);
                g = -nega_alpha_ordering_nws_simple(search, -alpha - 1, depth - 1, false, move_list[move_idx].n_legal, searching);
            search->undo(&move_list[move_idx].flip);
            if (v < g) {
                v = g;
                best_move = move_list[move_idx].flip.pos;
                if (alpha < v) {
#if USE_KILLER_MOVE_MO && USE_KILLER_MOVE_NWS_MO
                    search->update_heuristics_on_cutoff(move_list[move_idx].flip.pos, depth);
#endif
                    break;
                }
            }
        }
    }
    if (*searching && global_searching) {
        transposition_table.reg(search, hash_code, depth, alpha, alpha + 1, v, best_move);
    }
    return v;
}


inline bool is_searching(std::vector<bool*> &searchings) {
    return std::all_of(searchings.begin(), searchings.end(), 
                       [](bool* elem) { return *elem; });
}




int nega_alpha_ordering_nws(Search *search, int alpha, const int depth, const bool skipped, uint64_t legal, const bool is_end_search, std::vector<bool*> &searchings) {
    if (!global_searching || !is_searching(searchings)) {
        return SCORE_UNDEFINED;
    }
    if (is_end_search) {
        if (depth <= MID_TO_END_DEPTH_MPC || (search->mpc_level == MPC_100_LEVEL && depth <= MID_TO_END_DEPTH)) {
            return nega_alpha_end_nws(search, alpha, skipped, legal);
        }
    } else {
        if (depth <= MID_SIMPLE_ORDERING_DEPTH) {
            return nega_alpha_ordering_nws_simple(search, alpha, depth, skipped, legal, searchings.back());
        }
    }
    int v = -SCORE_INF;
    ++search->n_nodes;
#if USE_SEARCH_STATISTICS
    ++search->n_nodes_discs[search->n_discs];
#endif
    if (legal == LEGAL_UNDEFINED) {
        legal = search->board.get_legal();
    }
    if (legal == 0ULL) {
        if (skipped) {
            return end_evaluate(&search->board);
        }
        search->pass();
            v = -nega_alpha_ordering_nws(search, -alpha - 1, depth, true, LEGAL_UNDEFINED, is_end_search, searchings);
        search->pass();
        return v;
    }
    uint32_t hash_code = search->board.hash();
    transposition_table.prefetch(hash_code);
    uint_fast8_t moves[N_TRANSPOSITION_MOVES] = {MOVE_UNDEFINED, MOVE_UNDEFINED};
    if (transposition_cutoff_nws(search, hash_code, depth, alpha, &v, moves)) {
        return v;
    }
#if USE_MID_MPC
    if (search->mpc_level < MPC_100_LEVEL && depth >= USE_MPC_MIN_DEPTH) {
        if (mpc(search, alpha, alpha + 1, depth, legal, is_end_search, &v, searchings)) {
            return v;
        }
    }
#endif
    int best_move = MOVE_UNDEFINED;
    int g;
    const int canput = pop_count_ull(legal);
    
    Flip_value move_list[MAX_N_BRANCHES];
    int idx = 0;
    int tt_moves_idx0 = -1;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&move_list[idx].flip, &search->board, cell);
        if (move_list[idx].flip.flip == search->board.opponent) {
            return SCORE_MAX;
        }
        if (cell == moves[0]) {
            tt_moves_idx0 = idx;
        }
        ++idx;
    }
    int n_etc_done = 0;
#if USE_MID_ETC
    if (depth >= MID_ETC_DEPTH_NWS) {
        if (etc_nws(search, move_list, canput, depth, alpha, &v, &n_etc_done)) {
            return v;
        }
    }
#endif
    bool serial_searched = false;
    if (tt_moves_idx0 != -1 && move_list[tt_moves_idx0].flip.flip) {
        search->move(&move_list[tt_moves_idx0].flip);
            g = -nega_alpha_ordering_nws(search, -alpha - 1, depth - 1, false, move_list[tt_moves_idx0].n_legal, is_end_search, searchings);
        search->undo(&move_list[tt_moves_idx0].flip);
        if (v < g) {
            v = g;
            best_move = move_list[tt_moves_idx0].flip.pos;
        }
        serial_searched = true;
        move_list[tt_moves_idx0].flip.flip = 0;
        move_list[tt_moves_idx0].value = -INF;
    }
    if (v <= alpha) {
        move_list_evaluate_nws(search, move_list, canput, moves, depth, alpha, searchings.back());
#if USE_YBWC_NWS
        if (
            search->use_multi_thread && 
            ((!is_end_search && depth - 1 >= YBWC_MID_SPLIT_MIN_DEPTH) || (is_end_search && depth - 1 >= YBWC_END_SPLIT_MIN_DEPTH)) 
            
        ) {
            move_list_sort(move_list, canput);
            
            if (move_list[0].flip.flip) {
                if (!serial_searched) {
                    search->move(&move_list[0].flip);
                        g = -nega_alpha_ordering_nws(search, -alpha - 1, depth - 1, false, move_list[0].n_legal, is_end_search, searchings);
                    search->undo(&move_list[0].flip);
                    move_list[0].flip.flip = 0;
                    if (v < g) {
                        v = g;
                        best_move = move_list[0].flip.pos;
                    }
                }
                if (v <= alpha) {
                    ybwc_search_young_brothers_nws(search, alpha, &v, &best_move, canput - n_etc_done - 1, hash_code, depth, is_end_search, move_list, canput, searchings);
                }
            }
        } else{
#endif
            for (int move_idx = 0; move_idx < canput - n_etc_done && is_searching(searchings); ++move_idx) {
                swap_next_best_move(move_list, move_idx, canput);
#if USE_MID_ETC
                if (move_list[move_idx].flip.flip == 0) {
                    break;
                }
#endif
                search->move(&move_list[move_idx].flip);
                    g = -nega_alpha_ordering_nws(search, -alpha - 1, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searchings);
                search->undo(&move_list[move_idx].flip);
                if (v < g) {
                    v = g;
                    best_move = move_list[move_idx].flip.pos;
                    if (alpha < v) {
#if USE_KILLER_MOVE_MO && USE_KILLER_MOVE_NWS_MO
                        search->update_heuristics_on_cutoff(move_list[move_idx].flip.pos, depth);
#endif
                        break;
                    }
                }
            }
#if USE_YBWC_NWS
        }
#endif
    }
    if (global_searching && is_searching(searchings)) {
        transposition_table.reg(search, hash_code, depth, alpha, alpha + 1, v, best_move);
    }
    return v;
}

inline int nega_alpha_ordering_nws(Search *search, int alpha, const int depth, const bool skipped, uint64_t legal, const bool is_end_search, bool *searching) {
    std::vector<bool*> searchings = {searching};
    return nega_alpha_ordering_nws(search, alpha, depth, skipped, legal, is_end_search, searchings);
}

// ===== FILE: Egaroucid/src/engine/minimax.hpp =====



#pragma once
#include "evaluate.hpp"

int negamax(Search *search, int depth, bool passed) {
    if (depth == 0) {
        return mid_evaluate_diff(search);
    }
    int v = -SCORE_INF;
    uint64_t legal = search->board.get_legal();
    if (legal == 0) {
        if (passed) {
            return search->board.score_player(); 
        }
        search->pass();
            v = -negamax(search, depth, true); 
        search->pass();
        return v;
    }
    Flip flip;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&flip, &search->board, cell);
        search->move(&flip);
            v = std::max(v, -negamax(search, depth - 1, false));
        search->undo(&flip);
    }
    return v;
}

int minimax(Board *board, int depth) {
    Search search(board);
    return negamax(&search, depth, false);
}

// ===== FILE: Egaroucid/src/engine/mobility_generic.hpp =====



#pragma once
#include "bit.hpp"
#include "setting.hpp"



void mobility_init() {
}




inline uint64_t calc_legal(const uint64_t P, const uint64_t O) {
    uint64_t moves, mO;
    uint64_t flip1, flip7, flip9, flip8, pre1, pre7, pre9, pre8;
    mO = O & 0x7e7e7e7e7e7e7e7eULL;
    flip1 = mO & (P << 1);         flip7  = mO & (P << 7);        flip9  = mO & (P << 9);        flip8  = O & (P << 8);
    flip1 |= mO & (flip1 << 1);    flip7 |= mO & (flip7 << 7);    flip9 |= mO & (flip9 << 9);    flip8 |= O & (flip8 << 8);
    pre1 = mO & (mO << 1);         pre7 = mO & (mO << 7);         pre9 = mO & (mO << 9);         pre8 = O & (O << 8);
    flip1 |= pre1 & (flip1 << 2);  flip7 |= pre7 & (flip7 << 14); flip9 |= pre9 & (flip9 << 18); flip8 |= pre8 & (flip8 << 16);
    flip1 |= pre1 & (flip1 << 2);  flip7 |= pre7 & (flip7 << 14); flip9 |= pre9 & (flip9 << 18); flip8 |= pre8 & (flip8 << 16);
    moves = flip1 << 1;            moves |= flip7 << 7;           moves |= flip9 << 9;           moves |= flip8 << 8;
    flip1 = mO & (P >> 1);         flip7  = mO & (P >> 7);        flip9  = mO & (P >> 9);        flip8  = O & (P >> 8);
    flip1 |= mO & (flip1 >> 1);    flip7 |= mO & (flip7 >> 7);    flip9 |= mO & (flip9 >> 9);    flip8 |= O & (flip8 >> 8);
    pre1 >>= 1;                    pre7 >>= 7;                    pre9 >>= 9;                    pre8 >>= 8;
    flip1 |= pre1 & (flip1 >> 2);  flip7 |= pre7 & (flip7 >> 14); flip9 |= pre9 & (flip9 >> 18); flip8 |= pre8 & (flip8 >> 16);
    flip1 |= pre1 & (flip1 >> 2);  flip7 |= pre7 & (flip7 >> 14); flip9 |= pre9 & (flip9 >> 18); flip8 |= pre8 & (flip8 >> 16);
    moves |= flip1 >> 1;           moves |= flip7 >> 7;           moves |= flip9 >> 9;           moves |= flip8 >> 8;
    return moves & ~(P | O);
}


// ===== FILE: Egaroucid/src/engine/mobility.hpp =====



#pragma once
#include "setting.hpp"
#if USE_SIMD
#include "mobility_simd.hpp"
#else
#include "mobility_generic.hpp"
#endif

// ===== FILE: Egaroucid/src/engine/mobility_simd.hpp =====



#pragma once
#include "bit.hpp"
#include "setting.hpp"



__m256i shift1897, mflipH;
void mobility_init() {
    shift1897 = _mm256_set_epi64x(7, 9, 8, 1);
    mflipH = _mm256_set_epi64x(0x7E7E7E7E7E7E7E7E, 0x7E7E7E7E7E7E7E7E, -1, 0x7E7E7E7E7E7E7E7E);
}




inline uint64_t calc_legal(const uint64_t P, const uint64_t O) {
    __m256i	PP, mOO, MM, flip_l, flip_r, pre_l, pre_r, shift2;
    __m128i	M;
    PP = _mm256_broadcastq_epi64(_mm_cvtsi64_si128(P));
    mOO = _mm256_and_si256(_mm256_broadcastq_epi64(_mm_cvtsi64_si128(O)), mflipH);
    flip_l = _mm256_and_si256(mOO, _mm256_sllv_epi64(PP, shift1897));
    flip_r = _mm256_and_si256(mOO, _mm256_srlv_epi64(PP, shift1897));
    flip_l = _mm256_or_si256(flip_l, _mm256_and_si256(mOO, _mm256_sllv_epi64(flip_l, shift1897)));
    flip_r = _mm256_or_si256(flip_r, _mm256_and_si256(mOO, _mm256_srlv_epi64(flip_r, shift1897)));
    pre_l = _mm256_and_si256(mOO, _mm256_sllv_epi64(mOO, shift1897));
    pre_r = _mm256_srlv_epi64(pre_l, shift1897);
    shift2 = _mm256_add_epi64(shift1897, shift1897);
    flip_l = _mm256_or_si256(flip_l, _mm256_and_si256(pre_l, _mm256_sllv_epi64(flip_l, shift2)));
    flip_r = _mm256_or_si256(flip_r, _mm256_and_si256(pre_r, _mm256_srlv_epi64(flip_r, shift2)));
    flip_l = _mm256_or_si256(flip_l, _mm256_and_si256(pre_l, _mm256_sllv_epi64(flip_l, shift2)));
    flip_r = _mm256_or_si256(flip_r, _mm256_and_si256(pre_r, _mm256_srlv_epi64(flip_r, shift2)));
    MM = _mm256_sllv_epi64(flip_l, shift1897);
    MM = _mm256_or_si256(MM, _mm256_srlv_epi64(flip_r, shift1897));
    M = _mm_or_si128(_mm256_castsi256_si128(MM), _mm256_extracti128_si256(MM, 1));
    M = _mm_or_si128(M, _mm_unpackhi_epi64(M, M));
    return _mm_cvtsi128_si64(M) & ~(P | O);
}


// ===== FILE: Egaroucid/src/engine/move_ordering.hpp =====


#pragma once
#include <iostream>
#include <vector>
#if USE_SIMD
    #ifdef _MSC_VER
        #include <intrin.h>
    #else
        #include <x86intrin.h>
    #endif
#endif
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "board_factory.hpp"
#include "search.hpp"
#include "midsearch.hpp"
#include "evaluate.hpp"
#include "stability.hpp"
#include "level.hpp"
#include "transposition_table.hpp"

constexpr int W_WIPEOUT = 100000000;
constexpr int W_1ST_MOVE = 10000000;
constexpr int W_2ND_MOVE = 1000000;
constexpr int MO_OFFSET_L_PM = 38;


#if TUNE_MOVE_ORDERING
    constexpr int N_MOVE_ORDERING_PARAM = 20;
    int move_ordering_param_array[N_MOVE_ORDERING_PARAM] = {
        10, 6, 3, 35, 17, 485, 269, 94, 
        5, 3, 1, 17, 204, 7, 25, 
        40, 12, 
        18, 17, 300
    };

    int W_KILLER                    = move_ordering_param_array[0];
    int W_HISTORY_MOVE              = move_ordering_param_array[1];
    int W_COUNTER_MOVE              = move_ordering_param_array[2];
    int W_MOBILITY                  = move_ordering_param_array[3];
    int W_POTENTIAL_MOBILITY        = move_ordering_param_array[4];
    int W_TT_BONUS                  = move_ordering_param_array[5];
    int W_VALUE                     = move_ordering_param_array[6];
    int W_VALUE_DEEP_ADDITIONAL     = move_ordering_param_array[7];

    int W_NWS_KILLER                = move_ordering_param_array[8];
    int W_NWS_HISTORY_MOVE          = move_ordering_param_array[9];
    int W_NWS_COUNTER_MOVE          = move_ordering_param_array[10];
    int W_NWS_MOBILITY              = move_ordering_param_array[11];
    int W_NWS_TT_BONUS              = move_ordering_param_array[12];
    int W_NWS_VALUE                 = move_ordering_param_array[13];
    int W_NWS_VALUE_DEEP_ADDITIONAL = move_ordering_param_array[14];

    int W_END_NWS_MOBILITY          = move_ordering_param_array[15];
    int W_END_NWS_VALUE             = move_ordering_param_array[16];

    int W_END_NWS_SIMPLE_MOBILITY   = move_ordering_param_array[17];
    int W_END_NWS_SIMPLE_PARITY     = move_ordering_param_array[18];
    int W_END_NWS_SIMPLE_TT_BONUS   = move_ordering_param_array[19];

    int MOVE_ORDERING_PARAM_START = 0;
    int MOVE_ORDERING_PARAM_END = 10;
#else
    
    constexpr int W_KILLER = 8;
    constexpr int W_HISTORY_MOVE = 6;
    constexpr int W_COUNTER_MOVE = 3;
    constexpr int W_MOBILITY = 35;
    constexpr int W_POTENTIAL_MOBILITY = 17;
    constexpr int W_TT_BONUS = 485;
    constexpr int W_VALUE = 269;
    constexpr int W_VALUE_DEEP_ADDITIONAL = 94;

    
    constexpr int W_NWS_KILLER = 5;
    constexpr int W_NWS_HISTORY_MOVE = 3;
    constexpr int W_NWS_COUNTER_MOVE = 1;
    constexpr int W_NWS_MOBILITY = 17;
    constexpr int W_NWS_TT_BONUS = 204;
    constexpr int W_NWS_VALUE = 7;
    constexpr int W_NWS_VALUE_DEEP_ADDITIONAL = 25;

    
    constexpr int W_END_NWS_MOBILITY = 40;
    constexpr int W_END_NWS_VALUE = 12;

    
    constexpr int W_END_NWS_SIMPLE_MOBILITY = 18;
    constexpr int W_END_NWS_SIMPLE_PARITY = 17;
    constexpr int W_END_NWS_SIMPLE_TT_BONUS = 300;
#endif

constexpr int MOVE_ORDERING_VALUE_OFFSET_ALPHA = 12;
constexpr int MOVE_ORDERING_VALUE_OFFSET_BETA = 8;
constexpr int MOVE_ORDERING_NWS_VALUE_OFFSET_ALPHA = 16;
constexpr int MOVE_ORDERING_NWS_VALUE_OFFSET_BETA = 6;

constexpr int MOVE_ORDERING_MPC_LEVEL = MPC_74_LEVEL;

int nega_alpha_eval1(Search *search, int alpha, int beta, bool skipped);
int nega_scout(Search *search, int alpha, int beta, const int depth, const bool skipped, uint64_t legal, const bool is_end_search, bool *searching);
inline bool transposition_table_get_value(Search *search, uint32_t hash, int *l, int *u);
inline int mid_evaluate_diff(Search *search);
inline int mid_evaluate_move_ordering_end(Search *search);


#if USE_SIMD
__m256i eval_surround_mask;
__m256i eval_surround_shift1879;
inline void move_ordering_init() {
    eval_surround_mask = _mm256_set_epi64x(0x7E7E7E7E7E7E7E7EULL, 0x00FFFFFFFFFFFF00ULL, 0x007E7E7E7E7E7E00ULL, 0x007E7E7E7E7E7E00ULL);
    eval_surround_shift1879 = _mm256_set_epi64x(1, HW, HW_M1, HW_P1);
}
#else
inline void move_ordering_init() {
}
#endif

#if !USE_BUILTIN_POPCOUNT
inline int get_corner_n_moves(uint64_t legal) {
    int res = (int)((legal & 0b10000001ULL) + ((legal >> 56) & 0b10000001ULL));
    return (res & 0b11) + (res >> 7);
}
#endif
inline int get_corner_n_moves_by_board(const Board& board, uint64_t legal) {
#if USE_BUILTIN_POPCOUNT
    if (const auto* b1 = dynamic_cast<const Board1*>(&board)) {
        return b1->get_corner_n_moves(legal);
    } else if (const auto* b2 = dynamic_cast<const Board2*>(&board)) {
        return b2->get_corner_n_moves(legal);
    } else if (const auto* b3 = dynamic_cast<const Board3*>(&board)) {
        return b3->get_corner_n_moves(legal);
    } else {
        
        return pop_count_ull(legal & 0x8100000000000081ULL);
    }
#else
    (void)board; 
    
    return get_corner_n_moves(legal);
#endif
}

inline int get_weighted_n_moves(const Board& board, uint64_t legal) {
    return pop_count_ull(legal) * 2 + get_corner_n_moves_by_board(board, legal);
}

#ifdef USE_SIMD
inline int get_n_moves_cornerX2(uint64_t legal) {
    return pop_count_ull(legal) + get_corner_n_moves(legal);
}
#else
inline int get_n_moves_cornerX2(uint64_t legal) {
    uint64_t b = legal;
    uint64_t c = b & 0x0100000000000001ull;
    b -= (b >> 1) & 0x1555555555555515ull;
    b = (b & 0x3333333333333333ull) + ((b >> 2) & 0x3333333333333333ull);
    b += c;
    b += (b >> 4);
    b &= 0x0f0f0f0f0f0f0f0full;
    b *= 0x0101010101010101ULL;
    return b >> 56;
}
#endif


#if USE_SIMD
inline int get_potential_mobility(uint64_t discs, uint64_t empties) {
    __m256i pl = _mm256_set1_epi64x(discs);
    pl = _mm256_and_si256(pl, eval_surround_mask);
    pl = _mm256_or_si256(_mm256_sllv_epi64(pl, eval_surround_shift1879), _mm256_srlv_epi64(pl, eval_surround_shift1879));
    __m128i res = _mm_or_si128(_mm256_castsi256_si128(pl), _mm256_extracti128_si256(pl, 1));
    res = _mm_or_si128(res, _mm_shuffle_epi32(res, 0x4e));
    return pop_count_ull(_mm_cvtsi128_si64(res) & (empties & ~board.invalid_mask));
}
#else
inline int get_potential_mobility(uint64_t discs, uint64_t empties) {
    uint64_t hmask = discs & 0x7E7E7E7E7E7E7E7EULL;
    uint64_t vmask = discs & 0x00FFFFFFFFFFFF00ULL;
    uint64_t hvmask = discs & 0x007E7E7E7E7E7E00ULL;
    uint64_t res = 
        (hmask << 1) | (hmask >> 1) | 
        (vmask << HW) | (vmask >> HW) | 
        (hvmask << HW_M1) | (hvmask >> HW_M1) | 
        (hvmask << HW_P1) | (hvmask >> HW_P1);
    return pop_count_ull(empties & res);
}
#endif

inline void move_evaluate(Search *search, Flip_value *flip_value, int alpha, int beta, int depth, bool *searching) {
    flip_value->value = 0;
#if USE_KILLER_MOVE_MO
    flip_value->value += search->get_killer_bonus(flip_value->flip.pos) * W_KILLER;
    int prev_pos = search->get_prev_move();
    flip_value->value += search->get_history_bonus(prev_pos, flip_value->flip.pos) * W_HISTORY_MOVE;
    flip_value->value += search->get_counter_move_bonus(prev_pos, flip_value->flip.pos) * W_COUNTER_MOVE;
#endif
    if ((search->board.invalid_mask >> flip_value->flip.pos) & 1ULL) {
    flip_value->value = -INF;
    return;
    }
    search->move(&flip_value->flip);
        flip_value->n_legal = search->board.get_legal();
        flip_value->value += (MO_OFFSET_L_PM - get_weighted_n_moves(search->board, flip_value->n_legal)) * W_MOBILITY;
        flip_value->value += (MO_OFFSET_L_PM - get_potential_mobility(search->board.opponent, ~(search->board.player | search->board.opponent))) * W_POTENTIAL_MOBILITY;
        switch (depth) {
            case 0:
                flip_value->value += (SCORE_MAX - mid_evaluate_diff(search)) * W_VALUE;
                break;
            case 1:
                flip_value->value += (SCORE_MAX - nega_alpha_eval1(search, alpha, beta, false)) * (W_VALUE + W_VALUE_DEEP_ADDITIONAL);
                break;
            default:
 
                uint_fast8_t mpc_level = search->mpc_level;
                search->mpc_level = MOVE_ORDERING_MPC_LEVEL;
                    flip_value->value += (SCORE_MAX - nega_scout(search, alpha, beta, depth, false, flip_value->n_legal, false, searching)) * (W_VALUE + depth * W_VALUE_DEEP_ADDITIONAL);
                search->mpc_level = mpc_level;
                break;
        }
    search->undo(&flip_value->flip);
}

inline void move_evaluate_nws(Search *search, Flip_value *flip_value, int alpha, int beta, int depth, bool *searching) {
    flip_value->value = 0;
#if USE_KILLER_MOVE_MO && USE_KILLER_MOVE_NWS_MO
    flip_value->value += search->get_killer_bonus(flip_value->flip.pos) * W_NWS_KILLER;
    int prev_pos = search->get_prev_move();
    flip_value->value += search->get_history_bonus(prev_pos, flip_value->flip.pos) * W_NWS_HISTORY_MOVE;
    flip_value->value += search->get_counter_move_bonus(prev_pos, flip_value->flip.pos) * W_NWS_COUNTER_MOVE;
#endif
    if ((search->board.invalid_mask >> flip_value->flip.pos) & 1ULL) {
    flip_value->value = -INF;
    return;
    }
    search->move(&flip_value->flip);
        flip_value->n_legal = search->board.get_legal();
        flip_value->value += (MO_OFFSET_L_PM - get_weighted_n_moves(search->board, flip_value->n_legal)) * W_NWS_MOBILITY;
        switch (depth) {
            case 0:
                flip_value->value += (SCORE_MAX - mid_evaluate_diff(search)) * W_NWS_VALUE;
                break;
            case 1:
                flip_value->value += (SCORE_MAX - nega_alpha_eval1(search, alpha, beta, false)) * (W_NWS_VALUE + W_NWS_VALUE_DEEP_ADDITIONAL);
                break;
            default:

                uint_fast8_t mpc_level = search->mpc_level;
                search->mpc_level = MOVE_ORDERING_MPC_LEVEL;
                    flip_value->value += (SCORE_MAX - nega_scout(search, alpha, beta, depth, false, flip_value->n_legal, false, searching)) * (W_NWS_VALUE + depth * W_NWS_VALUE_DEEP_ADDITIONAL);
                search->mpc_level = mpc_level;
                break;
        }
    search->undo(&flip_value->flip);
}

inline void swap_next_best_move(std::vector<Flip_value> &move_list, const int strt, const int siz) {
    if (strt == siz - 1) {
        return;
    }
    int top_idx = strt;
    int best_value = move_list[strt].value;
    for (int i = strt + 1; i < siz; ++i) {
        if (best_value < move_list[i].value) {
            best_value = move_list[i].value;
            top_idx = i;
        }
    }
    if (top_idx != strt) {
        std::swap(move_list[strt], move_list[top_idx]);
    }
}

inline void swap_next_best_move(Flip_value move_list[], const int strt, const int siz) {
    if (strt == siz - 1) {
        return;
    }
    int top_idx = strt;
    int best_value = move_list[strt].value;
    for (int i = strt + 1; i < siz; ++i) {
        if (best_value < move_list[i].value) {
            best_value = move_list[i].value;
            top_idx = i;
        }
    }
    if (top_idx != strt) {
        std::swap(move_list[strt], move_list[top_idx]);
    }
}

inline bool move_list_evaluate(Search *search, std::vector<Flip_value> &move_list, uint_fast8_t moves[], int depth, int alpha, int beta, bool *searching) {
    if (move_list.size() == 1) {
        return false;
    }
    int eval_alpha = -std::min(SCORE_MAX, beta + MOVE_ORDERING_VALUE_OFFSET_BETA);
    int eval_beta = -std::max(-SCORE_MAX, alpha - MOVE_ORDERING_VALUE_OFFSET_ALPHA);
    int eval_depth = depth >> 3;
    if (depth >= 25 && search->mpc_level < MPC_100_LEVEL) {
        eval_depth = ((depth / 3) & 0b11111110) + (depth & 1); 
    }
    for (Flip_value &flip_value: move_list) {
#if USE_MID_ETC
        if (flip_value.flip.flip) {
#endif
            if (flip_value.flip.pos == moves[0]) {
                flip_value.value = W_1ST_MOVE;
            } else if (flip_value.flip.pos == moves[1]) {
                flip_value.value = W_2ND_MOVE;
            } else {
                move_evaluate(search, &flip_value, eval_alpha, eval_beta, eval_depth, searching);
            }
#if USE_MID_ETC
        }
#endif
    }
    return false;
}

inline bool move_list_evaluate(Search *search, Flip_value move_list[], int canput, uint_fast8_t moves[], int depth, int alpha, int beta, bool *searching) {
    if (canput == 1) {
        return false;
    }
    int eval_alpha = -std::min(SCORE_MAX, beta + MOVE_ORDERING_VALUE_OFFSET_BETA);
    int eval_beta = -std::max(-SCORE_MAX, alpha - MOVE_ORDERING_VALUE_OFFSET_ALPHA);
    int eval_depth = depth >> 3;
    if (depth >= 25 && search->mpc_level < MPC_100_LEVEL) {
        eval_depth = ((depth / 3) & 0b11111110) + (depth & 1); 
    }
    for (int i = 0; i < canput; ++i) {
#if USE_MID_ETC
        if (move_list[i].flip.flip) {
#endif
            if (move_list[i].flip.pos == moves[0]) {
                move_list[i].value = W_1ST_MOVE;
            } else if (move_list[i].flip.pos == moves[1]) {
                move_list[i].value = W_2ND_MOVE;
            } else {
                move_evaluate(search, &move_list[i], eval_alpha, eval_beta, eval_depth, searching);
            }
#if USE_MID_ETC
        }
#endif
    }
    return false;
}


inline bool move_list_evaluate_nws(Search *search, std::vector<Flip_value> &move_list, uint_fast8_t moves[], int depth, int alpha, bool *searching) {
    if (move_list.size() <= 1) {
        return false;
    }
    const int eval_alpha = -std::min(SCORE_MAX, alpha + MOVE_ORDERING_NWS_VALUE_OFFSET_BETA);
    const int eval_beta = -std::max(-SCORE_MAX, alpha - MOVE_ORDERING_NWS_VALUE_OFFSET_ALPHA);
    int eval_depth = depth >> 4;
    for (Flip_value &flip_value: move_list) {
        if (flip_value.flip.flip) {
            if (flip_value.flip.pos == moves[0]) {
                flip_value.value = W_1ST_MOVE;
            } else if (flip_value.flip.pos == moves[1]) {
                flip_value.value = W_2ND_MOVE;
            } else{
                move_evaluate_nws(search, &flip_value, eval_alpha, eval_beta, eval_depth, searching);
            }
        }
    }
    return false;
}


inline bool move_list_evaluate_nws(Search *search, Flip_value move_list[], int canput, uint_fast8_t moves[], int depth, int alpha, bool *searching) {
    if (canput <= 1) {
        return false;
    }
    const int eval_alpha = -std::min(SCORE_MAX, alpha + MOVE_ORDERING_NWS_VALUE_OFFSET_BETA);
    const int eval_beta = -std::max(-SCORE_MAX, alpha - MOVE_ORDERING_NWS_VALUE_OFFSET_ALPHA);
    int eval_depth = depth >> 4;
    for (int i = 0; i < canput; ++i) {
        if (move_list[i].flip.flip) {
            if (move_list[i].flip.pos == moves[0]) {
                move_list[i].value = W_1ST_MOVE;
            } else if (move_list[i].flip.pos == moves[1]) {
                move_list[i].value = W_2ND_MOVE;
            } else{
                move_evaluate_nws(search, &move_list[i], eval_alpha, eval_beta, eval_depth, searching);
            }
        }
    }
    return false;
}

inline void move_list_sort(std::vector<Flip_value> &move_list) {
    std::sort(move_list.begin(), move_list.end(), [](Flip_value &a, Flip_value &b) { return a.value > b.value; });
}

inline void move_list_sort(Flip_value move_list[], int canput) {
    std::sort(move_list, move_list + canput, [](Flip_value &a, Flip_value &b) { return a.value > b.value; });
}


#if TUNE_MOVE_ORDERING
#include "ai.hpp"
inline Search_result tree_search_legal(Board board, int alpha, int beta, int depth, uint_fast8_t mpc_level, bool show_log, uint64_t use_legal, bool use_multi_thread, uint64_t time_limit, bool *searching);

uint64_t n_nodes_test(int level, std::vector<Board> testcase_arr) {
    uint64_t n_nodes = 0;
    for (Board &board: testcase_arr) {
        int depth;
        bool is_mid_search;
        uint_fast8_t mpc_level;
        int n_disc_effective = board.n_discs() + board.n_blocked_squares();
get_level(level, n_disc_effective - 4, &is_mid_search, &depth, &mpc_level);
        transposition_table.init();
        bool searching = true;
        Search_result result = tree_search_legal(board, -SCORE_MAX, SCORE_MAX, depth, mpc_level, false, board.get_legal(), true, TIME_LIMIT_INF, &searching);
        n_nodes += result.nodes;
    }
    transposition_table.reset_importance();
    return n_nodes;
}

void tune_move_ordering(int level) {
    std::cout << "please input testcase file" << std::endl;
    std::string file;
    std::cin >> file;
    std::ifstream ifs(file);
    if (ifs.fail()) {
        std::cerr << "[ERROR] [FATAL] problem file " << file << " not found" << std::endl;
        return;
    }
    std::vector<Board> testcase_arr;
    std::string line;
    while (std::getline(ifs, line)) {
        Board b(line);
        testcase_arr.emplace_back(b);
    }
    std::cerr << testcase_arr.size() << " testcases loaded" << std::endl;
    int minute = 10;
    std::cout << "please input timelimit (minute)" << std::endl;
    std::cin >> minute;
    uint64_t tl = 60ULL * 1000ULL * minute; 
    uint64_t min_n_nodes = n_nodes_test(level, testcase_arr);
    double min_percentage = 100.0;
    uint64_t first_n_nodes = min_n_nodes;
    std::cerr << "min_n_nodes " << min_n_nodes << std::endl;
    int n_updated = 0;
    int n_try = 0;
    uint64_t strt = tim();
    while (tim() - strt < tl) {
        
        int idx = myrandrange(MOVE_ORDERING_PARAM_START, MOVE_ORDERING_PARAM_END + 1); 
        int delta = myrandrange(-5, 6);
        while (delta == 0) {
            delta = myrandrange(-5, 6);
        }
        if (move_ordering_param_array[idx] + delta < 0) {
            continue;
        }
        move_ordering_param_array[idx] += delta;
        uint64_t n_nodes = n_nodes_test(level, testcase_arr);
        double percentage = 100.0 * n_nodes / first_n_nodes;

        
        constexpr double start_temp = 0.1; 
        constexpr double end_temp = 0.0001; 
        double temp = start_temp + (end_temp - start_temp) * (tim() - strt) / tl;
        double prob = exp((min_percentage - percentage) / temp);
        if (prob > myrandom()) {
            min_n_nodes = n_nodes;
            min_percentage = percentage;
            ++n_updated;
        } else {
            move_ordering_param_array[idx] -= delta;
        }
        ++n_try;

        std::cerr << "try " << n_try << " updated " << n_updated << " min_n_nodes " << min_n_nodes << " n_nodes " << n_nodes << " " << min_percentage << "% " << tim() - strt << " ms ";
        for (int i = 0; i < N_MOVE_ORDERING_PARAM; ++i) {
            std::cerr << ", " << move_ordering_param_array[i];
        }
        std::cerr << std::endl;
    }
    std::cout << "done " << min_percentage << "% ";
    for (int i = 0; i < N_MOVE_ORDERING_PARAM; ++i) {
        std::cout << ", " << move_ordering_param_array[i];
    }
    std::cout << std::endl;
}
#endif

// ===== FILE: Egaroucid/src/engine/multi_probcut.hpp =====



#pragma once
#include <iostream>
#include "board.hpp"
#include "evaluate.hpp"
#include "search.hpp"
#include "midsearch.hpp"
#include "util.hpp"

constexpr int USE_MPC_MIN_DEPTH = 3;



constexpr int MPC_ERROR0_OFFSET = 4;



constexpr double SELECTIVITY_MPCT[N_SELECTIVITY_LEVEL] = {1.13, 1.55, 1.81, 2.32, 2.57, 3.29, 9.99};


constexpr double probcut_a = 0.7308488452189136;
constexpr double probcut_b = -4.5708322989025865;
constexpr double probcut_c = 1.096319765006055;
constexpr double probcut_d = -0.8362251801219095;
constexpr double probcut_e = 4.610017383697701;
constexpr double probcut_f = 3.818582623595395;
constexpr double probcut_g = 1.7775013664098447;


#if USE_MPC_PRE_CALCULATION
int mpc_error[N_SELECTIVITY_LEVEL][HW2 + 1][HW2 - 3][HW2 - 3];
#endif


inline double probcut_sigma(int n_discs, int depth1, int depth2) {
    double res = probcut_a * ((double)n_discs / 64.0) + probcut_b * ((double)depth1 / 60.0) + probcut_c * ((double)depth2 / 60.0);
    res = probcut_d * res * res * res + probcut_e * res * res + probcut_f * res + probcut_g;
    return res;
}

int nega_alpha_ordering_nws(Search *search, int alpha, int depth, bool skipped, uint64_t legal, const bool is_end_search, std::vector<bool*> &searchings);


inline bool mpc(Search* search, int alpha, int beta, int depth, uint64_t legal, const bool is_end_search, int* v, std::vector<bool*> &searchings) {
    int search_depth;
    if (is_end_search) {
        search_depth = ((depth / 3) & 0b11111110) + (depth & 1); 
    } else {
        search_depth = ((depth / 2) & 0b11111110) + (depth & 1); 
    }
    
    int d0value = mid_evaluate_diff(search);
    
    

    if (is_end_search) {
        if ((alpha & 1) == 0) {
            alpha += 1;
        }
        if ((beta & 1) == 0) {
            beta -= 1;
        }
    }
    
    if (search_depth == 0) {
#if USE_MPC_PRE_CALCULATION
        int error = mpc_error[search->mpc_level][search->n_discs][0][depth];
#else
        double mpct = SELECTIVITY_MPCT[search->mpc_level];
        int error = ceil(mpct * probcut_sigma(search->n_discs, 0, depth));
#endif
        if (d0value >= beta + error) {
            *v = beta;
            if (is_end_search) {
                *v += beta & 1;
            }
            return true;
        }
        if (d0value <= alpha - error) {
            *v = alpha;
            if (is_end_search) {
                *v -= alpha & 1;
            }
            return true;
        }
    } else {
        uint_fast8_t mpc_level = search->mpc_level;
#if USE_MPC_PRE_CALCULATION
        int error_search = mpc_error[mpc_level][search->n_discs][search_depth][depth];
#else
        double mpct = SELECTIVITY_MPCT[mpc_level];
        int error_search = ceil(mpct * probcut_sigma(search->n_discs, search_depth, depth));
#endif
        
        
        
        int error_0 = std::max(1, error_search - MPC_ERROR0_OFFSET);
        search->mpc_level = MPC_100_LEVEL;
        if (d0value >= beta + error_0) {
            int pc_beta = beta + error_search;
            if (pc_beta <= SCORE_MAX) {
                if (nega_alpha_ordering_nws(search, pc_beta - 1, search_depth, false, legal, false, searchings) >= pc_beta) {
                    *v = beta;
                    if (is_end_search) {
                        *v += beta & 1;
                    }
                    search->mpc_level = mpc_level;
                    return true;
                }
            }
        }
        if (d0value <= alpha - error_0) {
            int pc_alpha = alpha - error_search;
            if (pc_alpha >= -SCORE_MAX) {
                if (nega_alpha_ordering_nws(search, pc_alpha, search_depth, false, legal, false, searchings) <= pc_alpha) {
                    *v = alpha;
                    if (is_end_search) {
                        *v -= alpha & 1;
                    }
                    search->mpc_level = mpc_level;
                    return true;
                }
            }
        }
        search->mpc_level = mpc_level;
    }
    return false;
}

inline bool mpc(Search* search, int alpha, int beta, int depth, uint64_t legal, const bool is_end_search, int* v, bool *searching) {
    std::vector<bool*> searchings = {searching};
    return mpc(search, alpha, beta, depth, legal, is_end_search, v, searchings);
}


#if USE_ALL_NODE_PREDICTION_NWS
inline bool predict_all_node(Search* search, int alpha, int depth, uint64_t legal, const bool is_end_search, bool *searching) {
    uint_fast8_t mpc_level = MPC_93_LEVEL;
    int search_depth = mpc_search_depth_arr[is_end_search][depth];
    int error_search, error_0;
#if USE_MPC_PRE_CALCULATION
    if (is_end_search) {
        error_search = mpc_error_end[mpc_level][search->n_discs][search_depth];
        error_0 = mpc_error_end[mpc_level][search->n_discs][0];
    } else{
        error_search = mpc_error[mpc_level][search->n_discs][search_depth][depth];
        error_0 = mpc_error[mpc_level][search->n_discs][0][depth];
    }
#else
    double mpct = SELECTIVITY_MPCT[mpc_level];
    if (is_end_search) {
        error_search = ceil(mpct * probcut_sigma_end(search->n_discs, search_depth));
        error_0 = ceil(mpct * probcut_sigma_end(search->n_discs, 0));
    }else{
        error_search = ceil(mpct * probcut_sigma(search->n_discs, search_depth, depth));
        error_0 = ceil(mpct * probcut_sigma(search->n_discs, 0, depth));
    }
#endif
    int d0value = mid_evaluate_diff(search);
    if (d0value <= alpha - (error_search + error_0) / 2) {
        int pc_alpha = alpha - error_search;
        if (pc_alpha > -SCORE_MAX) {
            if (nega_alpha_ordering_nws(search, pc_alpha, search_depth, false, legal, false, searching) <= pc_alpha) {
                return true;
            }
        }
    }
    return false;
}
#endif



#if USE_MPC_PRE_CALCULATION
void mpc_init() {
    int mpc_level, n_discs, depth1, depth2;
    for (mpc_level = 0; mpc_level < N_SELECTIVITY_LEVEL; ++mpc_level) {
        for (n_discs = 0; n_discs < HW2 + 1; ++n_discs) {
            for (depth1 = 0; depth1 < HW2 - 3; ++depth1) {
                for (depth2 = 0; depth2 < HW2 - 3; ++depth2) {
                    mpc_error[mpc_level][n_discs][depth1][depth2] = ceil(SELECTIVITY_MPCT[mpc_level] * probcut_sigma(n_discs, depth1, depth2));
                }
            }
        }
    }
}
#endif

#if TUNE_PROBCUT_MID
inline Search_result tree_search_legal(Board board, int alpha, int beta, int depth, uint_fast8_t mpc_level, bool show_log, uint64_t use_legal, bool use_multi_thread, uint64_t time_limit, thread_id_t thread_id, bool *searching);
void get_data_probcut_mid() {
    std::ofstream ofs("probcut_mid.txt");
    Board board;
    Flip flip;
    Search_result short_ans, long_ans;
    bool searching = true;
    for (int i = 0; i < 10000; ++i) {
        
        for (int depth = 4; depth <= 16; ++depth) {
            for (int n_discs = 4; n_discs < HW2 - depth - 2; ++n_discs) {
                board.reset();
                for (int j = 4; j < n_discs && board.check_pass(); ++j) { 
                    uint64_t legal = board.get_legal();
                    int random_idx = myrandrange(0, pop_count_ull(legal));
                    int t = 0;
                    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
                        if (t == random_idx) {
                            calc_flip(&flip, &board, cell);
                            break;
                        }
                        ++t;
                    }
                    board.move_board(&flip);
                }
                if (board.check_pass()) {
                    int short_depth = myrandrange(1, depth - 1);
                    short_depth &= 0xfffffffe;
                    short_depth |= depth & 1;
                    
                    if (short_depth == 0) {
                        short_ans.value = mid_evaluate(&board);
                    } else {
                        short_ans = tree_search_legal(board, -SCORE_MAX, SCORE_MAX, short_depth, MPC_100_LEVEL, false, board.get_legal(), true, TIME_LIMIT_INF, THREAD_ID_NONE, &searching);
                    }
                    long_ans = tree_search_legal(board, -SCORE_MAX, SCORE_MAX, depth, MPC_100_LEVEL, false, board.get_legal(), true, TIME_LIMIT_INF, THREAD_ID_NONE, &searching);
                    
                    std::cerr << i << " " << n_discs << " " << short_depth << " " << depth << " " << long_ans.value - short_ans.value << std::endl;
                    ofs << n_discs << " " << short_depth << " " << depth << " " << long_ans.value - short_ans.value << std::endl;
                }
            }
        }
    }
}
#endif

#if TUNE_PROBCUT_END
inline Search_result tree_search_legal(Board board, int alpha, int beta, int depth, uint_fast8_t mpc_level, bool show_log, uint64_t use_legal, bool use_multi_thread, uint64_t time_limit, thread_id_t thread_id, bool *searching);
void get_data_probcut_end() {
    std::ofstream ofs("probcut_end.txt");
    Board board;
    Flip flip;
    Search_result short_ans, long_ans;
    bool searching = true;
    for (int i = 0; i < 10000; ++i) {
        for (int depth = 2; depth <= 26; ++depth) {
            board.reset();
            for (int j = 0; j < HW2 - 4 - depth && board.check_pass(); ++j) { 
                uint64_t legal = board.get_legal();
                int random_idx = myrandrange(0, pop_count_ull(legal));
                int t = 0;
                for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
                    if (t == random_idx) {
                        calc_flip(&flip, &board, cell);
                        break;
                    }
                    ++t;
                }
                board.move_board(&flip);
            }
            if (board.check_pass()) {
                int short_depth = myrandrange(2, std::min(18, depth - 1));
                short_depth &= 0xfffffffe;
                short_depth |= depth & 1;
                
                if (short_depth == 0) {
                    short_ans.value = mid_evaluate(&board);
                } else {
                    short_ans = tree_search_legal(board, -SCORE_MAX, SCORE_MAX, short_depth, MPC_100_LEVEL, false, board.get_legal(), true, TIME_LIMIT_INF, THREAD_ID_NONE, &searching);
                }
                long_ans = tree_search_legal(board, -SCORE_MAX, SCORE_MAX, depth, MPC_100_LEVEL, false, board.get_legal(), true, TIME_LIMIT_INF, THREAD_ID_NONE, &searching);
                
                std::cerr << i << " " << HW2 - depth << " " << short_depth << " " << long_ans.value - short_ans.value << std::endl;
                ofs << HW2 - depth << " " << short_depth << " " << long_ans.value - short_ans.value << std::endl;
            }
        }
    }
}
#endif

// ===== FILE: Egaroucid/src/engine/parallel.hpp =====



#pragma once
#include <iostream>
#include <functional>
#include "setting.hpp"
#include "board.hpp"


struct Parallel_task {
    int value;
    uint64_t n_nodes;
    uint_fast8_t cell;
    int move_idx;
};

// ===== FILE: Egaroucid/src/engine/perft.hpp =====



#pragma once
#include "board.hpp"

uint64_t perft(Board *board, int depth, bool passed) {
    if (depth == 0) {
        return 1ULL;
    }
    uint64_t res = 0;
    uint64_t legal = board->get_legal();
    if (legal == 0) {
        if (passed) {
            return 1ULL; 
        }
        board->pass();
            res = perft(board, depth - 1, true); 
        board->pass();
        return res;
    }
    if (depth == 1) {
        return pop_count_ull(legal); 
    }
    Flip flip;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&flip, board, cell);
        board->move_board(&flip);
            res += perft(board, depth - 1, false);
        board->undo_board(&flip);
    }
    return res;
}

uint64_t perft_no_pass_count(Board *board, int depth, bool passed) {
    if (depth == 0) {
        return 1ULL;
    }
    uint64_t res = 0;
    uint64_t legal = board->get_legal();
    if (legal == 0) {
        if (passed) {
            return 1ULL; 
        }
        board->pass();
            res = perft_no_pass_count(board, depth, true); 
        board->pass();
        return res;
    }
    if (depth == 1) {
        return pop_count_ull(legal); 
    }
    Flip flip;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&flip, board, cell);
        board->move_board(&flip);
            res += perft_no_pass_count(board, depth - 1, false);
        board->undo_board(&flip);
    }
    return res;
}

// ===== FILE: Egaroucid/src/engine/principal_variation.hpp =====



#pragma once
#include <iostream>
#include <future>
#include "setting.hpp"
#include "ai.hpp"

constexpr int PV_LENGTH_SETTING_MIN = 2;
constexpr int PV_LENGTH_SETTING_MAX = 40;

void get_principal_variation_str(Board board, int depth, int max_level, std::string *res) {
    Flip flip;
    for (int level = 1; level <= max_level && global_searching; ++level) {
        std::string pv;
        Board board_cpy = board.copy();
        for (int i = 0; i < depth && !board_cpy.is_end(); ++i) {
            if (board_cpy.get_legal() == 0) {
                board_cpy.pass();
            }
            Search_result search_result = ai_specified(board_cpy, level, true, 0, true, false);
            if (global_searching) {
                int best_move = search_result.policy;
                pv += idx_to_coord(best_move);
                calc_flip(&flip, &board_cpy, best_move);
                board_cpy.move_board(&flip);
            }
        }
        
        *res = pv;
    }
}

std::string get_principal_variation_str_tt(Board board, int depth) {
    Flip flip;
    std::string pv;
    Board board_cpy = board.copy();
    for (int i = 0; i < depth && !board_cpy.is_end(); ++i) {
        if (board_cpy.get_legal() == 0) {
            board_cpy.pass();
        }

        Book_value book_result = book.get_specified_best_move(&board_cpy, board_cpy.get_legal());
        if (is_valid_policy(book_result.policy)) {
            pv += idx_to_coord(book_result.policy);
            calc_flip(&flip, &board_cpy, book_result.policy);
            board_cpy.move_board(&flip);
        } else {
            int lower = -SCORE_MAX, upper = SCORE_MAX;
            uint_fast8_t moves[2] = {MOVE_UNDEFINED, MOVE_UNDEFINED};
            int depth;
            uint_fast8_t mpc_level;
            transposition_table.get_info(board_cpy, &lower, &upper, moves, &depth, &mpc_level);
            if (moves[0] != MOVE_UNDEFINED) {
                pv += idx_to_coord(moves[0]);
                calc_flip(&flip, &board_cpy, book_result.policy);
                board_cpy.move_board(&flip);
            } else {
                break;
            }
        }
    }
    return pv;
}

// ===== FILE: Egaroucid/src/engine/problem_generator.hpp =====

#include "ai.hpp"
#include <fstream>

void problem_generator(int n_empties, int n_problems, int level) {
    std::string problem_file = std::to_string(n_empties) + "_" + std::to_string(n_problems) + "_problem.txt";
    std::string answer_file = std::to_string(n_empties) + "_" + std::to_string(n_problems) + "_answer.txt";
    std::string move_file = std::to_string(n_empties) + "_" + std::to_string(n_problems) + "_move.txt";
    std::ofstream prob_ofs(problem_file);
    std::ofstream ans_ofs(answer_file);
    std::ofstream move_ofs(move_file);
    Board board;
    Flip flip;
    for (int i = 0; i < n_problems; ++i) {
        if ((i + 1) % 100 == 0)
            std::cerr << '\r' << i;
        board.reset();
        for (int j = 0; j < 60 - n_empties; ++j) {
            uint64_t legal = board.get_legal();
            if (legal == 0) {
                board.pass();
                legal = board.get_legal();
                if (legal == 0) {
                    break;
                }
            }
            std::vector<uint_fast8_t> legals;
            for (uint_fast8_t c = first_bit(&legal); legal; c = next_bit(&legal)) {
                legals.emplace_back(c);
            }
            uint_fast8_t cell = legals[myrandrange(0, (int)legals.size())];
            calc_flip(&flip, &board, cell);
            board.move_board(&flip);
        }
        if (board.is_end()) {
            --i;
        } else{
            if (board.get_legal() == 0) {
                board.pass();
            }
            for (int i = 0; i < HW2; ++i) {
                if (1 & (board.player >> i)) {
                    prob_ofs << "X";
                } else if (1 & (board.opponent >> i)) {
                    prob_ofs << "O";
                } else{
                    prob_ofs << "-";
                }
            }
            prob_ofs << "X" << std::endl;
            Search_result res = ai(board, level, false, 0, true, false);
            ans_ofs << res.value << std::endl;
            uint64_t legal = board.get_legal();
            for (int i = 0; i < HW2; ++i) {
                if (i == res.policy) {
                    move_ofs << "B";
                } else if (1 & (legal >> i)) {
                    move_ofs << "O";
                } else{
                    move_ofs << "-";
                }
            }
            move_ofs << std::endl;
        }
    }
    std::cerr << std::endl;
}

// ===== FILE: Egaroucid/src/engine/random_board_generator.hpp =====


#pragma once
#include "ai.hpp"

std::vector<int> random_board_generator(int score_range, int n_moves, int light_level, int adjustment_level, bool *searching) {
    int light_n_moves = std::max(0, n_moves - 2);
    int adjustment_n_moves = n_moves - light_n_moves;
    if (score_range == SCORE_MAX) {
        light_n_moves = n_moves;
        adjustment_n_moves = 0;
    }
    bool success = false;
    std::vector<int> res;
    while (!success && *searching) {
        bool failed = false;

        Board board;
        board.reset();
        res.clear();
        Flip flip;

        std::random_device seed_gen;
        std::default_random_engine engine(seed_gen());
        std::normal_distribution<> dist(0.0, 4.0); 
        for (int i = 0; i < light_n_moves; ++i) {
            if (board.is_end()) {
                failed = true;
                break;
            }
            if (board.get_legal() == 0) {
                board.pass();
            }
            int acceptable_loss = std::abs(std::round(dist(engine)));
            Search_result search_result = ai_accept_loss(board, light_level, acceptable_loss);
            int policy = search_result.policy;
            res.emplace_back(policy);
            std::cerr << "light " << acceptable_loss << " " << idx_to_coord(policy) << " " << search_result.value << std::endl;
            calc_flip(&flip, &board, policy);
            board.move_board(&flip);
        }
        if (!failed) {
            for (int i = 0; i < adjustment_n_moves; ++i) {
                if (board.is_end()) {
                    failed = true;
                    break;
                }
                if (board.get_legal() == 0) {
                    board.pass();
                }
                Search_result search_result = ai_range(board, adjustment_level, -score_range, score_range, searching);
                if (search_result.value == SCORE_UNDEFINED) {
                    failed = true;
                    break;
                }
                int policy = search_result.policy;
                res.emplace_back(policy);
                std::cerr << "adjust " << idx_to_coord(policy) << " " << search_result.value << std::endl;
                calc_flip(&flip, &board, policy);
                board.move_board(&flip);
            }
        }
        if (!failed) {
            success = true;
            std::cerr << "random board generated" << std::endl;
        }
    }
    if (res.size() != light_n_moves + adjustment_n_moves) {
        res.clear();
    }
    return res;
}

// ===== FILE: Egaroucid/src/engine/search.hpp =====



#pragma once
#include <iostream>
#include <fstream>
#include <algorithm>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "thread_pool.hpp"
#include "evaluate_common.hpp"
#include "evaluate.hpp"
#include "flip.hpp"


constexpr int END_FAST_DEPTH = 6;
constexpr int END_SIMPLE_DEPTH = 10;
constexpr int MID_TO_END_DEPTH = 13;
constexpr int MID_TO_END_DEPTH_MPC = 9;
constexpr int MID_SIMPLE_ORDERING_DEPTH = 4;




constexpr uint64_t TIME_LIMIT_INF = 18446744073709551615ULL;



constexpr int SCORE_UNDEFINED = -126;
constexpr int MOVE_UNDEFINED = 125;
constexpr int MOVE_NOMOVE = 65;
constexpr int MOVE_PASS = 64;
constexpr int SEARCH_BOOK = -1;
constexpr int MAX_N_BRANCHES = 35;


constexpr int stability_threshold_nws[HW2] = {
    99, 99, 99, 99, 99, 99, 99, 99, 
    99, 99, 99, 99, 99, 99, 99, 99, 
    99, 64, 64, 64, 64, 64, 64, 64, 
    64, 62, 62, 60, 60, 58, 58, 56, 
    56, 54, 54, 52, 52, 50, 50, 48, 
    48, 46, 44, 42, 40, 38, 36, 34, 
    32, 30, 28, 26, 24, 22, 20, 16, 
    14, 12, 10, 8, 6, 99, 99, 99
};

constexpr int stability_threshold[HW2] = {
    99, 99, 99, 99, 99, 99, 99, 99, 
    99, 99, 99, 99, 99, 99, 99, 99, 
    99, 62, 62, 60, 60, 58, 58, 56, 
    56, 54, 54, 52, 52, 50, 50, 48, 
    48, 46, 46, 44, 44, 42, 42, 40, 
    40, 38, 36, 34, 32, 30, 28, 26, 
    24, 22, 20, 18, 16, 14, 12, 8, 
    6, 4, 2, 0, -2, 99, 99, 99
};


constexpr uint_fast8_t cell_div4[HW2] = {
    1, 1, 1, 1, 2, 2, 2, 2, 
    1, 1, 1, 1, 2, 2, 2, 2, 
    1, 1, 1, 1, 2, 2, 2, 2, 
    1, 1, 1, 1, 2, 2, 2, 2, 
    4, 4, 4, 4, 8, 8, 8, 8, 
    4, 4, 4, 4, 8, 8, 8, 8, 
    4, 4, 4, 4, 8, 8, 8, 8, 
    4, 4, 4, 4, 8, 8, 8, 8
};


constexpr uint64_t parity_table[16] = {
    0x0000000000000000ULL, 0x000000000F0F0F0FULL, 0x00000000F0F0F0F0ULL, 0x00000000FFFFFFFFULL,
    0x0F0F0F0F00000000ULL, 0x0F0F0F0F0F0F0F0FULL, 0x0F0F0F0FF0F0F0F0ULL, 0x0F0F0F0FFFFFFFFFULL,
    0xF0F0F0F000000000ULL, 0xF0F0F0F00F0F0F0FULL, 0xF0F0F0F0F0F0F0F0ULL, 0xF0F0F0F0FFFFFFFFULL,
    0xFFFFFFFF00000000ULL, 0xFFFFFFFF0F0F0F0FULL, 0xFFFFFFFFF0F0F0F0ULL, 0xFFFFFFFFFFFFFFFFULL
};


constexpr int N_STATIC_CELL_PRIORITY = 4;
constexpr uint64_t static_cell_priority[N_STATIC_CELL_PRIORITY] = {
    0x8100000000000081ULL, 
    0x00003C24243C0000ULL, 
    0x3C3CC3C3C3C33C3CULL, 
    0x42C300000000C342ULL  
};




#if USE_KILLER_MOVE_MO
constexpr int MAX_PLY = 65;


constexpr int HISTORY_MAX = 16384;  
constexpr int HISTORY_SCALE = 16;   
#endif


inline void calc_eval_features(Board *board, Eval_search *eval);
inline void eval_undo(Eval_search *eval);
inline void eval_undo_endsearch(Eval_search *eval);
#if USE_SIMD
inline void eval_move(Eval_search *eval, const Flip *flip, const Board *board);
inline void eval_pass(Eval_search *eval, const Board *board);
inline void eval_move_endsearch(Eval_search *eval, const Flip *flip, const Board *board);
inline void eval_pass_endsearch(Eval_search *eval, const Board *board);
#else
inline void eval_move(Eval_search *eval, const Flip *flip);
inline void eval_pass(Eval_search *eval);
inline void eval_move_endsearch(Eval_search *eval, const Flip *flip);
inline void eval_pass_endsearch(Eval_search *eval);
#endif




struct Search_result {
    int level;
    int_fast8_t policy;
    int value;
    int depth;
    uint64_t time;
    uint64_t nodes;
    uint64_t clog_time;
    uint64_t clog_nodes;
    uint64_t nps;
    bool is_end_search;
    int probability;

    Search_result() 
        : level(0), policy(MOVE_UNDEFINED), value(SCORE_UNDEFINED), depth(-1), time(0), nodes(0), clog_time(0), clog_nodes(0), nps(0), is_end_search(false), probability(0) {}

    bool operator<(const Search_result &another) const {
        if (depth == SEARCH_BOOK && another.depth != SEARCH_BOOK) {
            return false;
        } else if (depth != SEARCH_BOOK && another.depth == SEARCH_BOOK) {
            return true;
        }
        return value < another.value;
    }

    bool operator>(const Search_result &another) const {
        if (another.depth == SEARCH_BOOK && depth != SEARCH_BOOK) {
            return false;
        } else if (another.depth != SEARCH_BOOK && depth == SEARCH_BOOK) {
            return true;
        }
        return value > another.value;
    }
};


struct Analyze_result {
    int played_move;
    int played_score;
    int played_depth;
    int played_probability;
    int alt_move;
    int alt_score;
    int alt_depth;
    int alt_probability;
};


class Search {
    public:
        Board board;
        
        int_fast8_t n_discs;
        uint_fast8_t parity;
        uint_fast8_t mpc_level;
        uint64_t n_nodes;
        Eval_search eval;
        bool use_multi_thread;
        thread_id_t thread_id;
#if USE_SEARCH_STATISTICS
        uint64_t n_nodes_discs[HW2];
#endif
        bool is_presearch;

#if USE_KILLER_MOVE_MO
        
        int killer1[MAX_PLY];
        int killer2[MAX_PLY];
        
        
        
        int history[HW2];  
        
        
        int counter_moves[HW2];  
        
        
        int move_history[MAX_PLY];  
#endif

    public:

        Search() {};

        Search(const Board *board_, uint_fast8_t mpc_level_, bool use_multi_thread_, bool is_presearch_)
            : board(board_->copy()), n_discs(board_->n_discs()), mpc_level(mpc_level_), use_multi_thread(use_multi_thread_), n_nodes(0), is_presearch(is_presearch_), thread_id(THREAD_ID_NONE) {
            uint64_t empty = ~(board.player | board.opponent | board.invalid_mask);
            parity = 1 & pop_count_ull(empty & 0x000000000F0F0F0FULL);
            parity |= (1 & pop_count_ull(empty & 0x00000000F0F0F0F0ULL)) << 1;
            parity |= (1 & pop_count_ull(empty & 0x0F0F0F0F00000000ULL)) << 2;
            parity |= (1 & pop_count_ull(empty & 0xF0F0F0F000000000ULL)) << 3;
            calc_eval_features(&board, &eval);
#if USE_KILLER_MOVE_MO
            clear_killers();
#endif
        }

        Search(uint64_t board_player, uint64_t board_opponent, uint_fast8_t mpc_level_, bool use_multi_thread_, bool is_presearch_)
            : board(Board{board_player, board_opponent}), n_discs(pop_count_ull(board_player | board_opponent)), mpc_level(mpc_level_), use_multi_thread(use_multi_thread_), n_nodes(0), is_presearch(is_presearch_), thread_id(THREAD_ID_NONE) {
            uint64_t empty = ~(board.player | board.opponent | board.invalid_mask);
            parity = 1 & pop_count_ull(empty & 0x000000000F0F0F0FULL);
            parity |= (1 & pop_count_ull(empty & 0x00000000F0F0F0F0ULL)) << 1;
            parity |= (1 & pop_count_ull(empty & 0x0F0F0F0F00000000ULL)) << 2;
            parity |= (1 & pop_count_ull(empty & 0xF0F0F0F000000000ULL)) << 3;
            calc_eval_features(&board, &eval);
#if USE_KILLER_MOVE_MO
            clear_killers();
            clear_history();
            clear_counter_moves();
            clear_move_history();
#endif
        }

        Search(uint64_t board_player, uint64_t board_opponent, int_fast8_t n_discs_, uint_fast8_t parity_, uint_fast8_t mpc_level_, bool use_multi_thread_, bool is_presearch_, thread_id_t thread_id_)
            : board(Board(board_player, board_opponent)), n_discs(n_discs_), parity(parity_), mpc_level(mpc_level_), use_multi_thread(use_multi_thread_), n_nodes(0), is_presearch(is_presearch_), thread_id(thread_id_) {
            calc_eval_features(&board, &eval);
#if USE_KILLER_MOVE_MO
            clear_killers();
            clear_history();
            clear_counter_moves();
            clear_move_history();
#endif
        }

        
        Search(const Board *board_)
            : board(board_->copy()), n_discs(board_->n_discs()), thread_id(THREAD_ID_NONE) {
            uint64_t empty = ~(board.player | board.opponent | board.invalid_mask);
            parity = 1 & pop_count_ull(empty & 0x000000000F0F0F0FULL);
            parity |= (1 & pop_count_ull(empty & 0x00000000F0F0F0F0ULL)) << 1;
            parity |= (1 & pop_count_ull(empty & 0x0F0F0F0F00000000ULL)) << 2;
            parity |= (1 & pop_count_ull(empty & 0xF0F0F0F000000000ULL)) << 3;
            calc_eval_features(&board, &eval);
#if USE_KILLER_MOVE_MO
            clear_killers();
#endif
        }
        

        
        inline void move(const Flip *flip) {
#if USE_SIMD
            eval_move(&eval, flip, &board); 
#else
            eval_move(&eval, flip);
#endif
            board.move_board(flip);
            ++n_discs;
            parity ^= cell_div4[flip->pos];
#if USE_KILLER_MOVE_MO
            
            record_move(flip->pos);
#endif
        }

        
        inline void undo(const Flip *flip) {
            eval_undo(&eval);
            board.undo_board(flip);
            --n_discs;
            parity ^= cell_div4[flip->pos];
        }

        
        inline void pass() {
#if USE_SIMD
            eval_pass(&eval, &board); 
#else
            eval_pass(&eval);
#endif
            board.pass();
        }

        
        inline void move_endsearch(const Flip *flip) {
#if USE_SIMD
            eval_move_endsearch(&eval, flip, &board); 
#else
            eval_move_endsearch(&eval, flip);
#endif
            board.move_board(flip);
            ++n_discs;
            parity ^= cell_div4[flip->pos];
        }

        
        inline void undo_endsearch(const Flip *flip) {
            eval_undo_endsearch(&eval);
            board.undo_board(flip);
            --n_discs;
            parity ^= cell_div4[flip->pos];
        }

        
        inline void pass_endsearch() {
#if USE_SIMD
            eval_pass_endsearch(&eval, &board); 
#else
            eval_pass_endsearch(&eval);
#endif
            board.pass();
        }

        
        inline void move_noeval(const Flip *flip) {
            board.move_board(flip);
            ++n_discs;
            parity ^= cell_div4[flip->pos];
        }

        
        inline void undo_noeval(const Flip *flip) {
            board.undo_board(flip);
            --n_discs;
            parity ^= cell_div4[flip->pos];
        }

        
        inline void pass_noeval() {
            board.pass();
        }

        
        inline void move_lastN(const Flip *flip) {
            board.move_board(flip);
            #if !USE_SIMD
                parity ^= cell_div4[flip->pos];
            #endif
        }

        
        inline void undo_lastN(const Flip *flip) {
            board.undo_board(flip);
#if !USE_SIMD
            parity ^= cell_div4[flip->pos];
#endif
        }

        
        inline int phase() {
            return (n_discs - 4) / PHASE_N_DISCS;
            
        }

#if USE_KILLER_MOVE_MO
        
        inline void clear_killers() {
            for (int i = 0; i < MAX_PLY; ++i) {
                killer1[i] = -1;
                killer2[i] = -1;
            }
        }

        
        inline int get_ply() const {
            return n_discs - 4;
        }

        
        inline void update_killer(int pos) {
            int ply = get_ply();
            if (ply < 0 || ply >= MAX_PLY) return;  
            if (pos < 0 || pos >= HW2) return;       
            if (pos == killer1[ply]) return;
            killer2[ply] = killer1[ply];
            killer1[ply] = pos;
        }

        
        inline int get_killer_bonus(int pos) const {
            int ply = get_ply();
            if (ply < 0 || ply >= MAX_PLY) return 0;
            if (pos == killer1[ply]) return 2;
            else if (pos == killer2[ply]) return 1;
            return 0;
        }

        
        inline void clear_history() {
            for (int i = 0; i < HW2; ++i) {
                history[i] = 0;
            }
        }

        
        inline void clear_counter_moves() {
            for (int i = 0; i < HW2; ++i) {
                counter_moves[i] = -1;
            }
        }

        
        inline void clear_move_history() {
            for (int i = 0; i < MAX_PLY; ++i) {
                move_history[i] = -1;
            }
        }

        
        inline void update_history(int from_pos, int to_pos, int depth) {
            
            if (to_pos < 0 || to_pos >= HW2) {
                return;
            }
            int bonus = depth * depth;
            history[to_pos] += bonus;
            
            if (history[to_pos] > HISTORY_MAX) {
                age_history();
            }
        }

        
        inline void age_history() {
            for (int i = 0; i < HW2; ++i) {
                history[i] /= HISTORY_SCALE;
            }
        }

        
        inline void update_counter_move(int prev_pos, int counter_pos) {
            if (prev_pos >= 0 && prev_pos < HW2 && counter_pos >= 0 && counter_pos < HW2) {
                counter_moves[prev_pos] = counter_pos;
            }
        }

        
        inline int get_history_bonus(int from_pos, int to_pos) const {
            
            if (to_pos < 0 || to_pos >= HW2) return 0;
            return history[to_pos] / (HISTORY_MAX + 1);
        }

        
        inline int get_counter_move_bonus(int prev_pos, int current_pos) const {
            if (prev_pos < 0 || prev_pos >= HW2) return 0;
            return (counter_moves[prev_pos] == current_pos);
        }

        
        inline void record_move(int pos) {
            int ply = get_ply();
            if (ply >= 0 && ply < MAX_PLY && pos >= 0 && pos < HW2) {
                move_history[ply] = pos;
            }
        }

        
        inline int get_prev_move() const {
            int ply = get_ply();
            if (ply > 0 && ply <= MAX_PLY) {
                return move_history[ply - 1];
            }
            return -1;
        }

        
        inline void update_heuristics_on_cutoff(int pos, int depth) {
            int prev_pos = get_prev_move();
            
            
            update_killer(pos);
            
            
            if (prev_pos >= 0) {
                update_history(prev_pos, pos, depth);
            }
            
            
            update_counter_move(prev_pos, pos);
        }
#endif
};


struct Clog_result {
    uint_fast8_t pos;
    int val;
};


struct Flip_value {
    Flip flip;
    int value;
    uint64_t n_legal;

    Flip_value() 
        : n_legal(LEGAL_UNDEFINED), value(0) {}

    bool operator<(const Flip_value &another) const{
        return value < another.value;
    }

    bool operator>(const Flip_value &another) const{
        return value > another.value;
    }
};

// ===== FILE: Egaroucid/src/engine/setting.hpp =====





#pragma once
#include <string>



#ifndef HAS_NO_AVX2 
    #define USE_SIMD true
    
    #ifdef HAS_AVX512 
        #define USE_AVX512 true
    #endif
#endif


#ifdef HAS_ARM_PROCESSOR
    #define USE_ARM true
#endif


#if HAS_AMD_PROCESSOR
    #define USE_AMD true
#endif

#ifndef HAS_32_BIT_OS
    #ifdef _WIN32
        #ifdef _WIN64
            #define USE_64_BIT true
        #else
            #define USE_64_BIT false
        #endif
    #else
        #define USE_64_BIT true
    #endif
#endif






#if USE_SIMD
    #if USE_ARM
        
        #define USE_FAST_VERTICAL_MIRROR true

        
        #define USE_BUILTIN_POPCOUNT true

        
        #define USE_MINUS_NTZ false

        
        #define USE_SIMD_EVALUATION true
    #else
        
        #define USE_FAST_VERTICAL_MIRROR true

        
        #define USE_BUILTIN_POPCOUNT true

        
        #define USE_BUILTIN_NTZ true

        
        #define USE_FAST_NEXT_BIT true

        
        #define USE_SIMD_EVALUATION true

        
        #define USE_BIT_GATHER_OPTIMIZE true

        
        #define USE_FAST_JOIN_H_LINE true

        #if USE_AVX512
            #define USE_AVX512_STABILITY true
        #endif

        
        #define USE_CRC32C_HASH false
        #define USE_CRC32C_HASH_LTT false

        
        #define USE_SIMD_TT_INIT false

    #endif
#else
    
    #define USE_MINUS_NTZ false
#endif







#define USE_END_PO true


#define USE_END_SC true
#define USE_LAST4_SC false


#define USE_MID_ETC true


#define USE_MID_MPC true


#define LAST_PO_OPTIMIZE true


#define USE_PARALLEL_CLOG_SEARCH true


#define USE_MPC_PRE_CALCULATION true


#define USE_YBWC_NWS true
#define USE_YBWC_NEGASCOUT true
#define USE_YBWC_NEGASCOUT_ANALYZE false


#define USE_ASPIRATION_NEGASCOUT false


#define USE_CHANGEABLE_HASH_LEVEL true



#define TT_USE_STACK true


#define AUTO_FLIP_OPT_BY_COMPILER true


#define USE_LAZY_SMP true
#define USE_LAZY_SMP2 false


#define USE_YBWC_SPLITTED_TASK_TERMINATION false


#define LAST_FLIP_PASS_OPT true


#define USE_KILLER_MOVE_MO false
#define USE_KILLER_MOVE_NWS_MO false






#define USE_SEARCH_STATISTICS false


#define USE_THREAD_MONITOR false




#define TUNE_MOVE_ORDERING false


#define TUNE_PROBCUT_MID false
#define TUNE_PROBCUT_END false


#define TUNE_LOCAL_STRATEGY false





#define TEST_ENDGAME_ACCURACY false





#ifdef __APPLE__
    #ifdef GUI_BUILD
        #include <Siv3D.hpp>
        const std::string EXE_DIRECTORY_PATH = FileSystem::RelativePath(Resource(U"")).narrow();
    #else
        const std::string EXE_DIRECTORY_PATH = "./";
    #endif
#else 
    const std::string EXE_DIRECTORY_PATH = "./";
#endif

// ===== FILE: Egaroucid/src/engine/spinlock.hpp =====



#pragma once
#include <atomic>
#include <thread>
#include <mutex>



struct Spinlock {
    std::atomic<bool> lock_ = {0};

    void lock() {
        for (;;) {
            if (!lock_.exchange(true, std::memory_order_acquire)) {
                return;
            }
            
            
            
        }
    }

    bool try_lock() noexcept {
        return !lock_.load(std::memory_order_relaxed) && !lock_.exchange(true, std::memory_order_acquire);
    }

    void unlock() noexcept {
        lock_.store(false, std::memory_order_release);
    }
};


// ===== FILE: Egaroucid/src/engine/stability_cutoff.hpp =====



#pragma once
#include "stability.hpp"


inline int stability_cut(Search *search, int *alpha, int *beta) {
    if (*beta >= stability_threshold[search->n_discs]) {
        int n_beta = HW2 - 2 * pop_count_ull(calc_stability(search->board.opponent, search->board.player));
        if (n_beta <= *alpha) {
            return n_beta;
        } else if (n_beta < *beta) {
            *beta = n_beta;
        }
    }
    return SCORE_UNDEFINED;
}


inline int stability_cut_last4(Search *search, int *alpha, int beta) {
    if (*alpha <= -stability_threshold[60]) {
        int n_alpha = 2 * pop_count_ull(calc_stability(search->board.opponent, search->board.player)) - HW2;
        if (n_alpha >= beta) {
            return n_alpha;
        } else if (n_alpha > *alpha) {
            *alpha = n_alpha;
        }
    }
    return SCORE_UNDEFINED;
}


inline int stability_cut_nws(Search *search, int alpha) {
    if (alpha >= stability_threshold_nws[search->n_discs]) {
        int n_beta = HW2 - 2 * pop_count_ull(calc_stability(search->board.opponent, search->board.player));
        if (n_beta <= alpha) {
            return n_beta;
        }
    }
    return SCORE_UNDEFINED;
}


inline int stability_cut_last4_nws(Search *search, int alpha) {
    if (alpha < -stability_threshold_nws[60]) {
        int n_alpha = 2 * pop_count_ull(calc_stability(search->board.opponent, search->board.player)) - HW2;
        if (n_alpha > alpha) {
            return n_alpha;
        }
    }
    return SCORE_UNDEFINED;
}

// ===== FILE: Egaroucid/src/engine/stability.hpp =====



#pragma once
#include <iostream>
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "search.hpp"
#include "util.hpp"


uint64_t stability_edge_arr[N_8BIT][N_8BIT][2];

#if USE_SIMD
#if USE_AVX512_STABILITY
__m128i stability_e180, stability_e181, stability_e182, stability_e183, stability_e184;
#endif
__m128i stability_e790, stability_e791, stability_e792, stability_e793; 
#endif



inline void probably_move_line(int p, int o, int place, int *np, int *no) {
    int i, j;
    *np = p | (1 << place);
    for (i = place - 1; i > 0 && (1 & (o >> i)); --i);
    if (1 & (p >> i)) {
        for (j = place - 1; j > i; --j) {
            *np ^= 1 << j;
        }
    }
    for (i = place + 1; i < HW_M1 && (1 & (o >> i)); ++i);
    if (1 & (p >> i)) {
        for (j = place + 1; j < i; ++j) {
            *np ^= 1 << j;
        }
    }
    *no = o & ~(*np);
}


int calc_stability_line(int b, int w) {
    int i, nb, nw, res = b | w;
    int empties = ~(b | w);
    for (i = 0; i < HW; ++i) {
        if (1 & (empties >> i)) {
            probably_move_line(b, w, i, &nb, &nw);
            res &= b | nw;
            res &= calc_stability_line(nb, nw);
            probably_move_line(w, b, i, &nw, &nb);
            res &= w | nb;
            res &= calc_stability_line(nb, nw);
        }
    }
    return res;
}


inline void stability_init() {
    int place, b, w, stab;
    for (b = 0; b < N_8BIT; ++b) {
        for (w = b; w < N_8BIT; ++w) {
            if (b & w) {
                stability_edge_arr[b][w][0] = 0;
                stability_edge_arr[b][w][1] = 0;
                stability_edge_arr[w][b][0] = 0;
                stability_edge_arr[w][b][1] = 0;
            } else{
                stab = calc_stability_line(b, w);
                stability_edge_arr[b][w][0] = 0;
                stability_edge_arr[b][w][1] = 0;
                for (place = 0; place < HW; ++place) {
                    if (1 & (stab >> place)) {
                        stability_edge_arr[b][w][0] |= 1ULL << place;
                        stability_edge_arr[b][w][1] |= 1ULL << (place * HW);
                    }
                }
                stability_edge_arr[w][b][0] = stability_edge_arr[b][w][0];
                stability_edge_arr[w][b][1] = stability_edge_arr[b][w][1];
            }
        }
    }
#if USE_SIMD
#if USE_AVX512_STABILITY
    stability_e180 = _mm_set_epi64x(1, 8);
    stability_e181 = _mm_set_epi64x(2, 16);
    stability_e182 = _mm_set_epi64x(4, 32);
    stability_e183 = _mm_set_epi64x(0x0101010101010101ULL, 0x00000000000000FFULL);
    stability_e184 = _mm_set_epi64x(0x00000000000000FFULL, 0x0101010101010101ULL);
#endif
    stability_e790 = _mm_set1_epi64x(0xFF80808080808080);
    stability_e791 = _mm_set1_epi64x(0x01010101010101FF);
    stability_e792 = _mm_set1_epi64x(0x00003F3F3F3F3F3F);
    stability_e793 = _mm_set1_epi64x(0x0F0F0F0Ff0F0F0F0);
#endif
}




inline uint64_t full_stability_h(uint64_t full) {
    full &= full >> 1;
    full &= full >> 2;
    full &= full >> 4;
    return (full & 0x0101010101010101ULL) * 0xFF;
}


inline uint64_t full_stability_v(uint64_t full) {
    full &= (full >> 8) | (full << 56);
    full &= (full >> 16) | (full << 48);
    full &= (full >> 32) | (full << 32);
    return full;
}

#if USE_SIMD
inline void full_stability(uint64_t discs, uint64_t *h, uint64_t *v, uint64_t *d7, uint64_t *d9) {
    
#if USE_AVX512_STABILITY
    __m128i hv = _mm_set1_epi64x(discs);
    hv = _mm_and_si128(hv, _mm_srlv_epi64(hv, stability_e180));
    hv = _mm_and_si128(hv, _mm_srlv_epi64(hv, stability_e181));
    hv = _mm_and_si128(hv, _mm_srlv_epi64(hv, stability_e182));
    hv = _mm_and_si128(hv, stability_e183);
    hv = _mm_mullo_epi64(hv, stability_e184);
    *v = _mm_cvtsi128_si64(hv);
    *h = _mm_cvtsi128_si64(_mm_unpackhi_epi64(hv, hv));
#else
    *h = full_stability_h(discs);
    *v = full_stability_v(discs);
#endif
    
    __m128i l79, r79;
    l79 = r79 = _mm_unpacklo_epi64(_mm_cvtsi64_si128(discs), _mm_cvtsi64_si128(vertical_mirror(discs)));
    l79 = _mm_and_si128(l79, _mm_or_si128(stability_e790, _mm_srli_epi64(l79, 9)));
    r79 = _mm_and_si128(r79, _mm_or_si128(stability_e791, _mm_slli_epi64(r79, 9)));
    l79 = _mm_andnot_si128(_mm_andnot_si128(_mm_srli_epi64(l79, 18), stability_e792), l79);
    r79 = _mm_andnot_si128(_mm_slli_epi64(_mm_andnot_si128(r79, stability_e792), 18), r79);
    l79 = _mm_and_si128(_mm_and_si128(l79, r79), _mm_or_si128(stability_e793,
        _mm_or_si128(_mm_srli_epi64(l79, 36), _mm_slli_epi64(r79, 36))));
    *d9 = _mm_cvtsi128_si64(l79);
    *d7 = vertical_mirror(_mm_cvtsi128_si64(_mm_unpackhi_epi64(l79, l79)));
}
#else

inline void full_stability_d(uint64_t full, uint64_t *full_d7, uint64_t *full_d9) {
    constexpr uint64_t edge = 0xFF818181818181FFULL;
    uint64_t l7, r7, l9, r9;
    l7 = r7 = full;
    l7 &= edge | (l7 >> 7);        r7 &= edge | (r7 << 7);
    l7 &= 0xFFFF030303030303ULL | (l7 >> 14);    r7 &= 0xC0C0C0C0C0C0FFFFULL | (r7 << 14);
    l7 &= 0xFFFFFFFF0F0F0F0FULL | (l7 >> 28);    r7 &= 0xF0F0F0F0FFFFFFFFULL | (r7 << 28);
    *full_d7 = l7 & r7;

    l9 = r9 = full;
    l9 &= edge | (l9 >> 9);        r9 &= edge | (r9 << 9);
    l9 &= 0xFFFFC0C0C0C0C0C0ULL | (l9 >> 18);    r9 &= 0x030303030303FFFFULL | (r9 << 18);
    *full_d9 = l9 & r9 & (0x0F0F0F0FF0F0F0F0ULL | (l9 >> 36) | (r9 << 36));
}


inline void full_stability(uint64_t discs, uint64_t *h, uint64_t *v, uint64_t *d7, uint64_t *d9) {
    *h = full_stability_h(discs);
    *v = full_stability_v(discs);
    full_stability_d(discs, d7, d9);
}
#endif



inline uint64_t calc_stability(uint64_t player, uint64_t opponent) {
    uint64_t player_stability = 0, n_stability;
    const uint64_t player_mask = player & 0x007E7E7E7E7E7E00ULL;
    n_stability = stability_edge_arr[player & 0xFFU][opponent & 0xFFU][0];
    n_stability |= stability_edge_arr[player >> 56][opponent >> 56][0] << 56;
    n_stability |= stability_edge_arr[join_v_line(player, 0)][join_v_line(opponent, 0)][1];
    n_stability |= stability_edge_arr[join_v_line(player, 7)][join_v_line(opponent, 7)][1] << 7;
    uint64_t full_h, full_v, full_d7, full_d9;
    full_stability(player | opponent, &full_h, &full_v, &full_d7, &full_d9);
    n_stability |= full_h & full_v & full_d7 & full_d9;
    n_stability &= player;
#if USE_SIMD
    __m256i hvd7d9, p256;
    const __m256i shift = _mm256_set_epi64x(1, HW, HW_M1, HW_P1);
    __m128i and_tmp;
    while (n_stability & ~player_stability) {
        player_stability |= n_stability;
        p256 = _mm256_set1_epi64x(player_stability);
        hvd7d9 = _mm256_set_epi64x(full_h, full_v, full_d7, full_d9);
        hvd7d9 = _mm256_or_si256(hvd7d9, _mm256_srlv_epi64(p256, shift));
        hvd7d9 = _mm256_or_si256(hvd7d9, _mm256_sllv_epi64(p256, shift));
        and_tmp = _mm_and_si128(_mm256_castsi256_si128(hvd7d9), _mm256_extractf128_si256(hvd7d9, 1));
        n_stability =  _mm_extract_epi64(and_tmp, 0) & _mm_extract_epi64(and_tmp, 1) & player_mask;
    }
#else
    uint64_t h, v, d7, d9;
    while (n_stability & ~player_stability) {
        player_stability |= n_stability;
        h = (player_stability >> 1) | (player_stability << 1) | full_h;
        v = (player_stability >> HW) | (player_stability << HW) | full_v;
        d7 = (player_stability >> HW_M1) | (player_stability << HW_M1) | full_d7;
        d9 = (player_stability >> HW_P1) | (player_stability << HW_P1) | full_d9;
        n_stability = h & v & d7 & d9 & player_mask;
    }
#endif
    return player_stability;
}

uint64_t calc_edge_stability(uint64_t player, uint64_t opponent) {
    uint64_t n_stability;
    n_stability = stability_edge_arr[player & 0xFFU][opponent & 0xFFU][0];
    n_stability |= stability_edge_arr[player >> 56][opponent >> 56][0] << 56;
    n_stability |= stability_edge_arr[join_v_line(player, 0)][join_v_line(opponent, 0)][1];
    n_stability |= stability_edge_arr[join_v_line(player, 7)][join_v_line(opponent, 7)][1] << 7;
    return n_stability;
}


inline uint64_t calc_stability_bits(Board *board) {
    return calc_stability(board->player, board->opponent) | calc_stability(board->opponent, board->player);
}


inline uint64_t calc_edge_stability_bits(Board *board) {
    return calc_edge_stability(board->player, board->opponent);
}


// ===== FILE: Egaroucid/src/engine/test.hpp =====



#include "ai.hpp"
#include "fstream"


void endgame_accuracy_test() {
    std::string problem_file, answer_file;
    std::cerr << "endgame accuracy test" << std::endl;
    std::cerr << "input [problem_file] [answer_file]" << std::endl;
    std::cin >> problem_file >> answer_file;
    std::ifstream ifs(problem_file);
    if (!ifs) {
        std::cerr << "input file not found" << std::endl;
        return;
    }
    std::ifstream ans(answer_file);
    if (!ans) {
        std::cerr << "answer file not found" << std::endl;
        return;
    }
    std::string line;
    
    
    uint64_t n_error = 0;
    uint64_t n = 0;
    while (getline(ifs, line)) {
        if ((n & 0b111111) == 0b111111) {
            std::cerr << '\r' << n;
        }
        Board board;
        
        
        
        
        if (!board.from_str(line)) {
            std::cerr << "input file format error at idx " << n << " " << line << std::endl;
            return;
        }
        int v = ai(board, 60, false, 0, true, false).value;
        int v_ans;
        ans >> v_ans;
        if (v != v_ans) {
            ++n_error;
            std::cerr << "\r[ERROR] endgame value wrong idx " << n << " " << line << " got " << v << " expected " << v_ans << std::endl;
        }
        ++n;
    }
    std::cerr << std::endl;
    std::cerr << n_error << " endgame error found in " << n << " boards" << std::endl;
}

// ===== FILE: Egaroucid/src/engine/thread_monitor.hpp =====



#pragma once
#include "thread_pool.hpp"

#define THREAD_MONITOR_INTERVAL 10 
#define THREAD_MONITOR_TIME 40000 

void thread_monitor() {
    std::chrono::system_clock::time_point strt = std::chrono::system_clock::now();
    std::chrono::system_clock::time_point tp = std::chrono::system_clock::now();
    while (std::chrono::duration_cast<std::chrono::milliseconds>(tp - strt).count() < THREAD_MONITOR_TIME) {
        std::this_thread::sleep_for(std::chrono::microseconds(THREAD_MONITOR_INTERVAL));
        std::cout << std::chrono::duration_cast<std::chrono::milliseconds>(tp - strt).count() << " " << thread_pool.get_n_idle() << std::endl;
        tp = std::chrono::system_clock::now();
    }
}

void start_thread_monitor() {
    int n_thread = thread_pool.size();
    thread_pool.resize(n_thread + 1);
    std::cerr << "thread pool resized for monitor from " << n_thread << " to " << n_thread + 1 << std::endl;
    bool pushed = false;
    while (!pushed) {
        thread_pool.push(&pushed, &thread_monitor);
    }
}

// ===== FILE: Egaroucid/src/engine/thread_pool.hpp =====



#pragma once
#include <iostream>
#include <future>
#include <queue>
#include <thread>
#include <atomic>
#include <functional>
#include <unordered_map>

#define THREAD_ID_SIZE 100
#define THREAD_ID_NONE 99 
#define THREAD_SIZE_INF 999999999
#define THREAD_SIZE_DEFAULT -1

using thread_id_t = int;







void reset_unavailable_task(bool *start_flag) {
    while (!*start_flag);
}

class Thread_pool {
    private:
        mutable std::mutex mtx;
        bool running;
        int n_thread;
        
        int n_idle;
        std::queue<std::pair<thread_id_t, std::function<void()>>> tasks{};
        std::unique_ptr<std::thread[]> threads;
        std::condition_variable condition;

        int max_thread_size[THREAD_ID_SIZE];
        std::atomic<int> n_using_thread[THREAD_ID_SIZE];
        
        
        

    public:
        void set_thread(int new_n_thread) {
            {
                std::lock_guard<std::mutex> lock(mtx);
                
                if (new_n_thread < 0) {
                    new_n_thread = 0;
                }
                n_thread = new_n_thread;
                threads.reset(new std::thread[n_thread]);
                for (int i = 0; i < n_thread; ++i) {
                    threads[i] = std::thread(&Thread_pool::worker, this);
                }
                running = true;
                n_idle = 0;
                for (int i = 0; i < THREAD_ID_SIZE; ++i) {
                    max_thread_size[i] = THREAD_SIZE_DEFAULT;
                    n_using_thread[i] = THREAD_SIZE_DEFAULT;
                }
                max_thread_size[THREAD_ID_NONE] = THREAD_SIZE_INF;
                n_using_thread[THREAD_ID_NONE] = 0;
            }
        }

        void exit_thread() {
            {
                std::lock_guard<std::mutex> lock(mtx);
                running = false;
            }
            condition.notify_all();
            for (int i = 0; i < n_thread; ++i) {
                if (threads[i].joinable()) {
                    threads[i].join();
                }
            }
            n_thread = 0;
            n_idle = 0;
        }

        void set_max_thread_size(uint64_t id, int new_max_thread_size) {
            std::lock_guard<std::mutex> lock(mtx);
            max_thread_size[id] = new_max_thread_size;
            if (n_using_thread[id] == THREAD_SIZE_DEFAULT) {
                n_using_thread[id] = 0; 
            }
        }

        Thread_pool() {
            set_max_thread_size(THREAD_ID_NONE, THREAD_SIZE_INF);
            set_thread(0);
        }

        Thread_pool(int new_n_thread) {
            set_max_thread_size(THREAD_ID_NONE, THREAD_SIZE_INF);
            set_thread(new_n_thread);
        }

        ~Thread_pool() {
            exit_thread();
        }

        void resize(int new_n_thread) {
            exit_thread();
            set_thread(new_n_thread);
        }

        int size() const {
            return n_thread;
        }

        int get_n_idle() const {
            return n_idle;
        }

        int get_max_thread_size(thread_id_t id) {
            return max_thread_size[id];
        }

        int get_n_using_thread(thread_id_t id) {
            return n_using_thread[id];
        }

        

#if ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L) || __cplusplus >= 201703L)
        template<typename F, typename... Args, typename R = std::invoke_result_t<std::decay_t<F>, std::decay_t<Args>...>>
#else
        template<typename F, typename... Args, typename R = typename std::result_of<std::decay_t<F>(std::decay_t<Args>...)>::type>
#endif
        std::future<R> push(bool *pushed, F &&func, const Args &&...args) {
            auto task = std::make_shared<std::packaged_task<R()>>([func, args...]() {
                return func(args...);
            });
            auto future = task->get_future();
            *pushed = push_task(THREAD_ID_NONE, [task]() {(*task)();});
            return future;
        }

#if ((defined(_MSVC_LANG) && _MSVC_LANG >= 201703L) || __cplusplus >= 201703L)
        template<typename F, typename... Args, typename R = std::invoke_result_t<std::decay_t<F>, std::decay_t<Args>...>>
#else
        template<typename F, typename... Args, typename R = typename std::result_of<std::decay_t<F>(std::decay_t<Args>...)>::type>
#endif
    std::future<R> push(thread_id_t id, bool *pushed, F &&func, const Args &&...args) {
        
        if (n_using_thread[id] >= max_thread_size[id]) {
            *pushed = false;
            return std::future<R>();
        }
        
        auto task = std::make_shared<std::packaged_task<R()>>([func, args...]() {
            return func(args...);
        });
        auto future = task->get_future();
        *pushed = push_task(id, [task]() {(*task)();});
        return future;
    }

        

    private:

        template<typename F>
        inline bool push_task(thread_id_t id, const F &task) {
            if (!running) {
                throw std::runtime_error("Cannot schedule new task after shutdown.");
            }
            bool pushed = false;
            if (n_idle > 0 && n_using_thread[id] < max_thread_size[id]) {
                {
                    std::unique_lock<std::mutex> lock(mtx);
                    if (n_idle > 0 && n_using_thread[id] < max_thread_size[id]) {
                        pushed = true;
                        tasks.push(std::make_pair(id, std::function<void()>(task)));
                        --n_idle;
                        condition.notify_one();
                        if (id != THREAD_ID_NONE) {
                            n_using_thread[id].fetch_add(1);
                        }
                    }
                }
            }
            return pushed;
        }

        void worker() {
            thread_id_t id;
            std::function<void()> task;
            for (;;) {
                {
                    std::unique_lock<std::mutex> lock(mtx);
                    ++n_idle;
                    condition.wait(lock, [&] { return !tasks.empty() || !running; });
                    if (!running && tasks.empty()) {
                        return;
                    }
                    if (!tasks.empty()) {
                        id = tasks.front().first;
                        task = std::move(tasks.front().second);
                        tasks.pop();
                    }
                }
                if (task) {
                    task();
                    if (id != THREAD_ID_NONE) {
                        n_using_thread[id].fetch_sub(1);
                    }
                }
            }
        }
};

Thread_pool thread_pool(0);


// ===== FILE: Egaroucid/src/engine/time_management.hpp =====



#pragma once
#include "ai.hpp"





#define TIME_MANAGEMENT_REMAINING_TIME_OFFSET 400 
#define TIME_MANAGEMENT_REMAINING_TIME_OFFSET_BASE 5000 

#define TIME_MANAGEMENT_N_MOVES_COE_30_OR_MORE 1.4 
#define TIME_MANAGEMENT_N_MOVES_COE_40_OR_MORE_ADDITIONAL 0.2 
#define TIME_MANAGEMENT_N_MOVES_COE_30_OR_MORE_NOTIME 1.2
#define TIME_MANAGEMENT_ADDITIONAL_TIME_COE_BASE 1.8
#define TIME_MANAGEMENT_ADDITIONAL_TIME_COE_ADD 1.8


Search_result ai(Board board, int level, bool use_book, int book_acc_level, bool use_multi_thread, bool show_log);

uint64_t calc_time_limit_ply(const Board board, uint64_t remaining_time_msec, bool show_log) {
    int n_empties = HW2 - board.n_discs();
    double remaining_moves = (double)(n_empties + 1) / 2.0;
    uint64_t remaining_time_msec_margin = remaining_time_msec;
    if (remaining_time_msec > TIME_MANAGEMENT_REMAINING_TIME_OFFSET * remaining_moves + TIME_MANAGEMENT_REMAINING_TIME_OFFSET_BASE) {
        remaining_time_msec_margin -= TIME_MANAGEMENT_REMAINING_TIME_OFFSET * remaining_moves + TIME_MANAGEMENT_REMAINING_TIME_OFFSET_BASE;
    } else {
        if (show_log) {
            std::cerr << "don't have enough time! remaining " << remaining_time_msec_margin << std::endl;
        }
    }











    
    
    constexpr double complete_const_a = 0.60; 
    constexpr double complete_const_b = 0.75;
    constexpr double complete_nps = 7.0e8;
    double complete_use_time = (double)remaining_time_msec_margin * 0.9;
    double complete_search_depth = log(complete_use_time / 1000.0 * complete_nps / complete_const_a) / complete_const_b;

    
    
    constexpr double endgame_const_a = 0.05; 
    constexpr double endgame_const_b = 0.62;
    constexpr double endgame_nps = 3.5e8;
    double endgame_use_time = (double)remaining_time_msec_margin * 0.15;
    double endgame_search_depth = log(endgame_use_time / 1000.0 * endgame_nps / endgame_const_a) / endgame_const_b;

    if (show_log) {
        std::cerr << "complete search depth " << complete_search_depth << " endgame search depth " << endgame_search_depth << " n_empties " << n_empties << std::endl;
    }

    
    double remaining_moves_proc = 0;
    if (remaining_time_msec_margin < remaining_time_msec) {
        if (remaining_moves >= 30 / 2) { 
            remaining_moves_proc += (remaining_moves - (30 / 2)) * TIME_MANAGEMENT_N_MOVES_COE_30_OR_MORE;
        }
        if (remaining_moves >= 40 / 2) { 
            remaining_moves_proc += (remaining_moves - (40 / 2)) * TIME_MANAGEMENT_N_MOVES_COE_40_OR_MORE_ADDITIONAL;
        }
    } else {
        remaining_moves_proc += (remaining_moves - (26 / 2)) * TIME_MANAGEMENT_N_MOVES_COE_30_OR_MORE_NOTIME;
    }
    remaining_moves_proc = std::max(2.0, remaining_moves_proc); 
    uint64_t midgame_use_time = std::max<uint64_t>(1ULL, (uint64_t)(remaining_time_msec_margin / remaining_moves_proc));

    if (n_empties <= complete_search_depth) {
        if (show_log) {
            std::cerr << "try complete search tl max(" << complete_use_time << ", " << midgame_use_time << ")" << std::endl;
        }
        return std::max((uint64_t)complete_use_time, midgame_use_time);
    }
    if (n_empties <= endgame_search_depth) {
        if (show_log) {
            std::cerr << "try endgame search tl max(" << endgame_use_time << ", " << midgame_use_time << ")" << std::endl;
        }
        return std::max((uint64_t)endgame_use_time, midgame_use_time);
    }
    return midgame_use_time;
}

uint64_t calc_time_limit_ply_MCTS(const Board board, uint64_t remaining_time_msec, bool show_log) {
    int n_empties = HW2 - board.n_discs();
    double remaining_moves = (double)(n_empties + 1) / 2.0;
    uint64_t remaining_time_msec_margin = remaining_time_msec;
    if (remaining_time_msec > TIME_MANAGEMENT_REMAINING_TIME_OFFSET * remaining_moves + TIME_MANAGEMENT_REMAINING_TIME_OFFSET_BASE) {
        remaining_time_msec_margin -= TIME_MANAGEMENT_REMAINING_TIME_OFFSET * remaining_moves + TIME_MANAGEMENT_REMAINING_TIME_OFFSET_BASE;
    } else {
        if (show_log) {
            std::cerr << "don't have enough time! remaining " << remaining_time_msec_margin << std::endl;
        }
    }











    
    
    constexpr double complete_const_a = 0.60; 
    constexpr double complete_const_b = 0.75;
    constexpr double complete_nps = 7.0e8;
    double complete_use_time = (double)remaining_time_msec_margin * 0.9;
    double complete_search_depth = log(complete_use_time / 1000.0 * complete_nps / complete_const_a) / complete_const_b;

    
    
    constexpr double endgame_const_a = 0.05; 
    constexpr double endgame_const_b = 0.62;
    constexpr double endgame_nps = 3.5e8;
    double endgame_use_time = (double)remaining_time_msec_margin * 0.15;
    double endgame_search_depth = log(endgame_use_time / 1000.0 * endgame_nps / endgame_const_a) / endgame_const_b;

    if (show_log) {
        std::cerr << "complete search depth " << complete_search_depth << " endgame search depth " << endgame_search_depth << " n_empties " << n_empties << std::endl;
    }

    
    double remaining_moves_proc = 0;
    if (remaining_moves > 30 / 2) {
        remaining_moves_proc += remaining_moves - 30 / 2;
    }
    remaining_moves_proc = std::max(2.0, remaining_moves_proc); 
    double coe = 1.0;
    if (n_empties >= 35) {
        coe += 1.5 * (double)(n_empties - 35) / (60.0 - 35.0);
    }
    std::cerr << "n_empties " << n_empties << " coe " << coe << std::endl;
    uint64_t midgame_use_time = std::max<uint64_t>(1ULL, (uint64_t)(coe * remaining_time_msec_margin / remaining_moves_proc));

    if (n_empties <= complete_search_depth) {
        if (show_log) {
            std::cerr << "try complete search tl max(" << complete_use_time << ", " << midgame_use_time << ")" << std::endl;
        }
        return std::max((uint64_t)complete_use_time, midgame_use_time);
    }
    if (n_empties <= endgame_search_depth) {
        if (show_log) {
            std::cerr << "try endgame search tl max(" << endgame_use_time << ", " << midgame_use_time << ")" << std::endl;
        }
        return std::max((uint64_t)endgame_use_time, midgame_use_time);
    }
    return midgame_use_time;
}

uint64_t request_more_time(Board board, uint64_t remaining_time_msec, uint64_t time_limit, bool show_log) {
    int n_empties = HW2 - board.n_discs();
    double remaining_moves = (double)(n_empties + 1) / 2.0;
    uint64_t remaining_time_msec_margin = remaining_time_msec;
    if (remaining_time_msec > TIME_MANAGEMENT_REMAINING_TIME_OFFSET * remaining_moves + TIME_MANAGEMENT_REMAINING_TIME_OFFSET_BASE) {
        remaining_time_msec_margin -= TIME_MANAGEMENT_REMAINING_TIME_OFFSET * remaining_moves + TIME_MANAGEMENT_REMAINING_TIME_OFFSET_BASE;
    } else {
        remaining_time_msec_margin = 1;
    }
    if (show_log) {
        std::cerr << "requesting more time remaining " << remaining_time_msec << " remaining_margin " << remaining_time_msec_margin << " tl before " << time_limit << std::endl;
    }
    if (remaining_time_msec_margin > time_limit && remaining_time_msec_margin > 40000ULL) {
        
        int remaining_moves_proc = 0;
        if (remaining_moves >= 30 / 2) { 
            remaining_moves_proc += std::round((remaining_moves - (30 / 2)) * TIME_MANAGEMENT_N_MOVES_COE_30_OR_MORE);
        }
        if (remaining_moves >= 40 / 2) { 
            remaining_moves_proc += std::round((remaining_moves - (40 / 2)) * TIME_MANAGEMENT_N_MOVES_COE_40_OR_MORE_ADDITIONAL);
        }
        remaining_moves_proc = std::max(2, remaining_moves_proc); 
        double coe = TIME_MANAGEMENT_ADDITIONAL_TIME_COE_BASE;
        if (remaining_moves >= 40 / 2) { 
            coe += TIME_MANAGEMENT_ADDITIONAL_TIME_COE_ADD * (double)(remaining_moves - (40.0 / 2.0)) / (60.0 / 2.0 - 40.0 / 2.0);
        }
        if (show_log) {
            std::cerr << "time request coe " << coe << std::endl;
        }
        uint64_t additional_time = (remaining_time_msec_margin - time_limit) / remaining_moves_proc * coe;
        additional_time = std::min(additional_time, remaining_time_msec_margin / 2);
        if (show_log) {
            std::cerr << "additional time " << additional_time << std::endl;
        }
        time_limit += additional_time;
    }
    if (show_log) {
        std::cerr << "more time requested: new time limit " << time_limit << std::endl;
    }
    return time_limit;
}


void selfplay(Board board, int level) {
    Search_result result;
    Flip flip;
    while (board.check_pass()) {
        result = ai(board, level, true, 0, false, false);
        calc_flip(&flip, &board, result.policy);
        board.move_board(&flip);
    }
}


void time_management_selfplay(Board board, bool show_log, uint64_t use_legal, uint64_t time_limit) {
    uint64_t start_time = tim();
    if (show_log) {
        std::cerr << "self play time " << time_limit << " ms" << std::endl;
    }
    std::vector<Flip> move_list(pop_count_ull(use_legal));
    int idx = 0;
    for (uint_fast8_t cell = first_bit(&use_legal); use_legal; cell = next_bit(&use_legal)) {
        calc_flip(&move_list[idx], &board, cell);
        ++idx;
    }
    int select_idx = 0;
    uint64_t count = 0;
    while (tim() - start_time < time_limit) {
        board.move_board(&move_list[select_idx]);
            selfplay(board, 11);
        board.undo_board(&move_list[select_idx]);
        ++count;
        ++select_idx;
        select_idx %= move_list.size();
    }
    if (show_log) {
        std::cerr << "self play count " << count << std::endl;
    }
}

// ===== FILE: Egaroucid/src/engine/transposition_cutoff.hpp =====


#pragma once
#include "setting.hpp"
#include "search.hpp"
#include "transposition_table.hpp"
#include "move_ordering.hpp"

constexpr int MID_ETC_DEPTH = 16;
constexpr int MID_ETC_DEPTH_NWS = 16;

inline bool transposition_cutoff(Search *search, const uint32_t hash_code, int depth, int *alpha, int *beta, int *v, uint_fast8_t moves[]) {
    int lower = -SCORE_MAX, upper = SCORE_MAX;
    transposition_table.get(search, hash_code, depth, &lower, &upper, moves);
    if (upper == lower || upper <= *alpha) {
        *v = upper;
        return true;
    }
    if (*beta <= lower) {
        *v = lower;
        return true;
    }
    if (*alpha < lower) {
        *alpha = lower;
    }
    if(upper < *beta) {
        *beta = upper;
    }
    return false;
}

inline bool transposition_cutoff_bestmove(Search *search, const uint32_t hash_code, int depth, int *alpha, int *beta, int *v, int *best_move) {
    int lower = -SCORE_MAX, upper = SCORE_MAX;
    uint_fast8_t moves[N_TRANSPOSITION_MOVES];
    transposition_table.get(search, hash_code, depth, &lower, &upper, moves);
    if (upper == lower || upper <= *alpha) {
        *v = upper;
        *best_move = moves[0];
        return true;
    }
    if (*beta <= lower) {
        *v = lower;
        *best_move = moves[0];
        return true;
    }
    if (*alpha < lower) {
        *alpha = lower;
    }
    if(upper < *beta) {
        *beta = upper;
    }
    return false;
}

inline bool transposition_cutoff_nws(Search *search, const uint32_t hash_code, int depth, int alpha, int *v, uint_fast8_t moves[]) {
    int lower = -SCORE_MAX, upper = SCORE_MAX;
    transposition_table.get(search, hash_code, depth, &lower, &upper, moves);
    if (upper == lower || upper <= alpha) {
        *v = upper;
        return true;
    }
    if (alpha < lower) {
        *v = lower;
        return true;
    }
    return false;
}

inline bool transposition_cutoff_nws(Search *search, const uint32_t hash_code, int depth, int alpha, int *v) {
    int lower = -SCORE_MAX, upper = SCORE_MAX;
    transposition_table.get_bounds(search, hash_code, depth, &lower, &upper);
    if (upper == lower || upper <= alpha) {
        *v = upper;
        return true;
    }
    if (alpha < lower) {
        *v = lower;
        return true;
    }
    return false;
}

inline bool transposition_cutoff_nws_bestmove(Search *search, const uint32_t hash_code, int depth, int alpha, int *v, int *best_move) {
    int lower = -SCORE_MAX, upper = SCORE_MAX;
    uint_fast8_t moves[N_TRANSPOSITION_MOVES];
    transposition_table.get(search, hash_code, depth, &lower, &upper, moves);
    if (upper == lower || upper <= alpha) {
        *v = upper;
        *best_move = moves[0];
        return true;
    }
    if (alpha < lower) {
        *v = lower;
        *best_move = moves[0];
        return true;
    }
    return false;
}




inline bool etc(Search *search, std::vector<Flip_value> &move_list, int depth, int *alpha, int *beta, int *v, int *n_etc_done) {
    *n_etc_done = 0;
    int l, u, n_beta = *alpha;
    for (Flip_value &flip_value: move_list) {
        l = -SCORE_MAX;
        u = SCORE_MAX;
        search->move(&flip_value.flip);
            if (transposition_table.has_node_any_level_get_bounds(search, search->board.hash(), depth - 1, &l, &u)) {
                flip_value.value = W_TT_BONUS;
            }
        search->undo(&flip_value.flip);
        if (*beta <= -u) { 
            *v = -u;
            return true; 
        } else if (*alpha <= -u && -u < *beta) { 
            *alpha = -u; 
            *v = -u;
            if (-l <= *v || u == l) { 
                flip_value.flip.flip = 0ULL; 
                flip_value.value = -INF;
                ++(*n_etc_done);
            }
        } else if (-l <= *alpha) { 
            *v = std::max(*v, -l); 
            flip_value.flip.flip = 0ULL; 
            flip_value.value = -INF;
            ++(*n_etc_done);
        }
    }
    return false;
}


inline bool etc(Search *search, Flip_value move_list[], int canput, int depth, int *alpha, int *beta, int *v, int *n_etc_done) {
    *n_etc_done = 0;
    int l, u, n_beta = *alpha;
    for (int i = 0; i < canput; ++i) {
        l = -SCORE_MAX;
        u = SCORE_MAX;
        search->move(&move_list[i].flip);
            if (transposition_table.has_node_any_level_get_bounds(search, search->board.hash(), depth - 1, &l, &u)) {
                move_list[i].value = W_TT_BONUS;
            }
        search->undo(&move_list[i].flip);
        if (*beta <= -u) { 
            *v = -u;
            return true; 
        } else if (*alpha <= -u && -u < *beta) { 
            *alpha = -u; 
            *v = -u;
            if (-l <= *v || u == l) { 
                move_list[i].flip.flip = 0ULL; 
                move_list[i].value = -INF;
                ++(*n_etc_done);
            }
        } else if (-l <= *alpha) { 
            *v = std::max(*v, -l); 
            move_list[i].flip.flip = 0ULL; 
            move_list[i].value = -INF;
            ++(*n_etc_done);
        }
    }
    return false;
}


inline bool etc_nws(Search *search, std::vector<Flip_value> &move_list, int depth, int alpha, int *v, int *n_etc_done) {
    *n_etc_done = 0;
    int l, u;
    for (Flip_value &flip_value: move_list) {
        l = -SCORE_MAX;
        u = SCORE_MAX;
        search->move(&flip_value.flip);
            if (transposition_table.has_node_any_level_get_bounds(search, search->board.hash(), depth - 1, &l, &u)) {
                flip_value.value = W_NWS_TT_BONUS;
            }
        search->undo(&flip_value.flip);
        if (alpha < -u) { 
            *v = -u;
            return true;
        }
        if (-alpha <= l) { 
            if (*v < -l)
                *v = -l;
            flip_value.flip.flip = 0ULL; 
            flip_value.value = -INF;
            ++(*n_etc_done);
        }
    }
    return false;
}



inline bool etc_nws(Search *search, Flip_value move_list[], int canput, int depth, int alpha, int *v, int *n_etc_done) {
    *n_etc_done = 0;
    int l, u;
    for (int i = 0; i < canput; ++i) {
        l = -SCORE_MAX;
        u = SCORE_MAX;
        search->move(&move_list[i].flip);
            if (transposition_table.has_node_any_level_get_bounds(search, search->board.hash(), depth - 1, &l, &u)) {
                move_list[i].value = W_NWS_TT_BONUS;
            }
        search->undo(&move_list[i].flip);
        if (alpha < -u) { 
            *v = -u;
            return true;
        }
        if (-alpha <= l) { 
            if (*v < -l)
                *v = -l;
            move_list[i].flip.flip = 0ULL; 
            move_list[i].value = -INF;
            ++(*n_etc_done);
        }
    }
    return false;
}

// ===== FILE: Egaroucid/src/engine/transposition_table.hpp =====

ï»¿

#pragma once
#include "setting.hpp"
#include "common_select.hpp"
#include "board.hpp"
#include "thread_pool.hpp"
#include "spinlock.hpp"
#include "search.hpp"
#include <future>
#include <functional>




constexpr int TRANSPOSITION_TABLE_N_LOOP = 3;
#if TT_USE_STACK
constexpr size_t TRANSPOSITION_TABLE_STACK_SIZE = hash_sizes[DEFAULT_HASH_LEVEL] + TRANSPOSITION_TABLE_N_LOOP - 1;
#endif
constexpr int N_TRANSPOSITION_MOVES = 2;
constexpr double TT_REGISTER_THRESHOLD_RATE = 0.4;

constexpr int TRANSPOSITION_TABLE_HAS_NODE = 100;
constexpr int TRANSPOSITION_TABLE_NOT_HAS_NODE = -100;

bool transposition_table_auto_reset_importance = true;

inline uint32_t get_level_common(uint8_t depth, uint8_t mpc_level) {
    return ((uint32_t)depth << 8) | mpc_level;
}

inline uint32_t get_level_common(int depth, uint_fast8_t mpc_level) {
    return ((uint32_t)depth << 8) | mpc_level;
}


class Hash_data {
    private:
        uint8_t mpc_level;
        uint8_t depth;
        uint8_t importance;
        int8_t lower;
        int8_t upper;
        uint8_t moves[N_TRANSPOSITION_MOVES];

    public:

        
        
        
        
        inline void init() {
            lower = -SCORE_MAX;
            upper = SCORE_MAX;
            moves[0] = MOVE_UNDEFINED;
            moves[1] = MOVE_UNDEFINED;
            mpc_level = 0;
            depth = 0;
            importance = 0;
        }

        
        inline void reg_same_level(const int alpha, const int beta, const int value, const int policy) {
            if (value < beta && value < upper) {
                upper = (int8_t)value;
                if (alpha < value && value < lower) {
                    lower = value;
                }
            }
            if (alpha < value && lower < value) {
                lower = (int8_t)value;
                if (value < beta && upper < value) {
                    upper = value;
                }
            }
            if ((alpha < value || value == -SCORE_MAX) && moves[0] != policy && is_valid_policy(policy)) {
                moves[1] = moves[0];
                moves[0] = (uint8_t)policy;
            }
            importance = 1;
        }

        
        inline void reg_new_level(const int d, const uint_fast8_t ml, const int alpha, const int beta, const int value, const int policy) {
            if (value < beta) {
                upper = (int8_t)value;
            } else {
                upper = SCORE_MAX;
            }
            if (alpha < value) {
                lower = (int8_t)value;
            } else {
                lower = -SCORE_MAX;
            }
            if ((alpha < value || value == -SCORE_MAX) && moves[0] != policy && is_valid_policy(policy)) {
                moves[1] = moves[0];
                moves[0] = policy;
            }
            depth = d;
            mpc_level = ml;
            importance = 1;
        }

        
        inline void reg_new_data(const int d, const uint_fast8_t ml, const int alpha, const int beta, const int value, const int policy) {
            if (value < beta) {
                upper = (int8_t)value;
            } else {
                upper = SCORE_MAX;
            }
            if (alpha < value) {
                lower = (int8_t)value;
            } else {
                lower = -SCORE_MAX;
            }
            if ((alpha < value || value == -SCORE_MAX) && moves[0] != policy) {
                moves[0] = policy;
            } else {
                moves[0] = MOVE_UNDEFINED;
            }
            moves[1] = MOVE_UNDEFINED;
            depth = d;
            mpc_level = ml;
            importance = 1;
        }

        
        inline uint32_t get_level() {
            if (importance) {
                return get_level_common(depth, mpc_level);
            }
            return 0;
        }

        
        inline uint32_t get_level_no_importance() {
            return get_level_common(depth, mpc_level);
        }

        inline int get_depth() {
            return depth;
        }

        inline int get_mpc_level() {
            return mpc_level;
        }

        inline int get_window_width() {
            return upper - lower;
        }

        
        inline void get_moves(uint_fast8_t res_moves[]) {
            res_moves[0] = moves[0];
            res_moves[1] = moves[1];
        }

        
        inline void get_bounds(int *l, int *u) {
            *l = lower;
            *u = upper;
        }

        
        inline void set_importance_zero() {
            importance = 0;
        }

        inline uint8_t get_importance() const {
            return importance;
        }
};

struct Hash_node {
    Board board;
    Hash_data data;
    Spinlock lock;

    
    

    void init() {
        board.player = 0ULL;
        board.opponent = 0ULL;
        data.init();
    }
};


void init_transposition_table(Hash_node table[], size_t s, size_t e) {
#if USE_SIMD && USE_SIMD_TT_INIT
    
    Hash_node HASH_NODE_INIT;
    HASH_NODE_INIT.init();
    __m256i init_data = _mm256_load_si256(((__m256i*)&HASH_NODE_INIT));
    for(size_t i = s; i < e;) {
        std::cerr << sizeof(Hash_node) << " " << ((uintptr_t)(table + i) & 0x1f) << std::endl;
        if (sizeof(Hash_node) == 32 && (((uintptr_t)(table + i) & 0x1f) == 0) && i + 1 < e) {
            std::cerr << "a";
            _mm256_stream_si256(((__m256i*)(table + i)), init_data);
            _mm_sfence();
            i += 1; 
        } else {
            table[i].init();
            ++i;
        }
    }
#else
    for(size_t i = s; i < e; ++i) {
        table[i].init();
    }
#endif
}


void set_importance_zero_transposition_table(Hash_node table[], size_t s, size_t e) {
    for(size_t i = s; i < e; ++i) {
        table[i].data.set_importance_zero();
    }
}


class Transposition_table {
    private:
        std::mutex mtx;
#if TT_USE_STACK
        Hash_node table_stack[TRANSPOSITION_TABLE_STACK_SIZE];
#endif
#if USE_CHANGEABLE_HASH_LEVEL || !TT_USE_STACK
        Hash_node *table_heap;
#endif
        size_t table_size;
        std::atomic<uint64_t> n_registered;
        uint64_t n_registered_threshold;

    public:
        
        Transposition_table() 
#if USE_CHANGEABLE_HASH_LEVEL || !TT_USE_STACK
            : table_heap(nullptr), table_size(0), n_registered(0), n_registered_threshold(0) {}
#else
            : table_size(0), n_registered(0), n_registered_threshold(0) {}
#endif

#if USE_CHANGEABLE_HASH_LEVEL
        
        inline bool resize(int hash_level) {
            size_t n_table_size = hash_sizes[hash_level] + TRANSPOSITION_TABLE_N_LOOP - 1;
            table_size = 0;
            if (table_heap != nullptr) {
                free(table_heap);
                table_heap = nullptr;
            }
            #if TT_USE_STACK
                if (n_table_size > TRANSPOSITION_TABLE_STACK_SIZE) {
                    table_heap = (Hash_node*)malloc(sizeof(Hash_node) * (n_table_size - TRANSPOSITION_TABLE_STACK_SIZE));
                    if (table_heap == nullptr)
                        return false;
                }
            #else
                table_heap = (Hash_node*)malloc(sizeof(Hash_node) * n_table_size);
                if (table_heap == nullptr)
                    return false;
            #endif
            table_size = n_table_size;
            n_registered_threshold = table_size * TT_REGISTER_THRESHOLD_RATE;
            init();
            return true;
        }
#else 
        inline bool set_size() {
            table_size = TRANSPOSITION_TABLE_STACK_SIZE;
            n_registered_threshold = table_size * TT_REGISTER_THRESHOLD_RATE;
            init();
            return true;
        }
#endif 

        
        inline void init() {
            int thread_size = thread_pool.size();
            if (thread_size == 0) {
#if TT_USE_STACK
                for (size_t i = 0; i < std::min(table_size, (size_t)TRANSPOSITION_TABLE_STACK_SIZE); ++i) {
                    table_stack[i].init();
                }
#if USE_CHANGEABLE_HASH_LEVEL
                if (table_size > TRANSPOSITION_TABLE_STACK_SIZE) {
                    for (size_t i = 0; i < table_size - (size_t)TRANSPOSITION_TABLE_STACK_SIZE; ++i)
                        table_heap[i].init();
                }
#endif 
#else 
                for (size_t i = 0; i < table_size; ++i)
                    table_heap[i].init();
#endif 
            } else {
                size_t s, e;
                std::vector<std::future<void>> tasks;
#if TT_USE_STACK
                    size_t delta = (std::min(table_size, (size_t)TRANSPOSITION_TABLE_STACK_SIZE) + thread_size - 1) / thread_size;
                    s = 0;
                    for (int i = 0; i < thread_size; ++i) {
                        e = std::min(std::min(table_size, (size_t)TRANSPOSITION_TABLE_STACK_SIZE), s + delta);
                        bool pushed = false;
                        while (!pushed) {
                            tasks.emplace_back(thread_pool.push(&pushed, std::bind(&init_transposition_table, table_stack, s, e)));
                            if (!pushed)
                                tasks.pop_back();
                        }
                        s = e;
                    }
#if USE_CHANGEABLE_HASH_LEVEL
                    if (table_size > TRANSPOSITION_TABLE_STACK_SIZE) {
                        delta = (table_size - (size_t)TRANSPOSITION_TABLE_STACK_SIZE + thread_size - 1) / thread_size;
                        s = 0;
                        for (int i = 0; i < thread_size; ++i) {
                            e = std::min(table_size - (size_t)TRANSPOSITION_TABLE_STACK_SIZE, s + delta);
                            bool pushed = false;
                            while (!pushed) {
                                tasks.emplace_back(thread_pool.push(&pushed, std::bind(&init_transposition_table, table_heap, s, e)));
                                if (!pushed)
                                    tasks.pop_back();
                            }
                            s = e;
                        }
                    }
#endif 
#else 
                size_t delta = (table_size + thread_size - 1) / thread_size;
                s = 0;
                for (int i = 0; i < thread_size; ++i) {
                    e = std::min(table_size, s + delta);
                    bool pushed = false;
                    while (!pushed) {
                        tasks.emplace_back(thread_pool.push(&pushed, std::bind(&init_transposition_table, table_heap, s, e)));
                        if (!pushed)
                            tasks.pop_back();
                    }
                    s = e;
                }
#endif 
                for (std::future<void> &task: tasks) {
                    task.get();
                }
            }
            n_registered.store(0);
        }

        
        inline void reset_importance() {
            std::lock_guard lock(mtx);
            reset_importance_proc();
        }

        
        inline void reset_importance_new_thread(int thread_size) {
            size_t s, e;
            std::vector<std::future<void>> tasks;
#if TT_USE_STACK
            size_t delta = (std::min(table_size, (size_t)TRANSPOSITION_TABLE_STACK_SIZE) + thread_size - 1) / thread_size;
            s = 0;
            for (int i = 0; i < thread_size; ++i) {
                e = std::min(std::min(table_size, (size_t)TRANSPOSITION_TABLE_STACK_SIZE), s + delta);
                tasks.emplace_back(std::async(std::launch::async, std::bind(&set_importance_zero_transposition_table, table_stack, s, e)));
                s = e;
            }
#if USE_CHANGEABLE_HASH_LEVEL
            if (table_size > TRANSPOSITION_TABLE_STACK_SIZE) {
                delta = (table_size - (size_t)TRANSPOSITION_TABLE_STACK_SIZE + thread_size - 1) / thread_size;
                s = 0;
                for (int i = 0; i < thread_size; ++i) {
                    e = std::min(table_size - (size_t)TRANSPOSITION_TABLE_STACK_SIZE, s + delta);
                    tasks.emplace_back(std::async(std::launch::async, std::bind(&set_importance_zero_transposition_table, table_heap, s, e)));
                    s = e;
                }
            }
#endif 
#else 
            size_t delta = (table_size + thread_size - 1) / thread_size;
            s = 0;
            for (int i = 0; i < thread_size; ++i) {
                e = std::min(table_size, s + delta);
                tasks.emplace_back(std::async(std::launch::async, std::bind(&set_importance_zero_transposition_table, table_heap, s, e)));
                s = e;
            }
#endif 
            for (std::future<void> &task: tasks)
                task.get();
            n_registered = 0;
        }

        
        inline void reg(const Search *search, uint32_t hash, const int depth, int alpha, int beta, int value, int policy) {
            Hash_node *node = get_node(hash);
            const uint32_t level = get_level_common(depth, search->mpc_level);
            uint32_t node_level;
#if TT_REGISTER_MIN_LEVEL
            Hash_node *min_level_node = nullptr;
            uint32_t min_level = 0x4fffffff;
            bool registered = false;
#endif
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                if (node->data.get_level() <= level) {
                    node->lock.lock();
                        node_level = node->data.get_level();
                        if (node_level <= level) {
                            if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                                if (node_level == level)
                                    node->data.reg_same_level(alpha, beta, value, policy);
                                else
                                    node->data.reg_new_level(depth, search->mpc_level, alpha, beta, value, policy);
                                node->lock.unlock();
#if TT_REGISTER_MIN_LEVEL
                                registered = true;
#endif
                                break;
                            } else{
#if TT_REGISTER_MIN_LEVEL
                                if (node_level < min_level) {
                                    min_level = node_level;
                                    min_level_node = node;
                                }
#else
                                if (node->data.get_importance() == 0) {
                                    n_registered.fetch_add(1);
                                }
                                node->board.player = search->board.player;
                                node->board.opponent = search->board.opponent;
                                node->data.reg_new_data(depth, search->mpc_level, alpha, beta, value, policy);
                                node->lock.unlock();
                                
                                
                                
                                break;
#endif
                            }
                        }
                    node->lock.unlock();
                }
                ++hash;
                node = get_node(hash);
            }
#if TT_REGISTER_MIN_LEVEL
            if (!registered && min_level_node != nullptr) {
                min_level_node->lock.lock();
                    min_level_node->board.player = search->board.player;
                    min_level_node->board.opponent = search->board.opponent;
                    min_level_node->data.reg_new_data(depth, search->mpc_level, alpha, beta, value, policy);
                    if (min_level_node->data.get_level() > 0) {
                        n_registered.fetch_add(1);
                    }
                min_level_node->lock.unlock();
            }
#endif
            if (n_registered >= n_registered_threshold && transposition_table_auto_reset_importance) {
                std::lock_guard lock(mtx);
                if (n_registered >= n_registered_threshold) {
                    reset_importance_proc();
                }
            }
        }


        inline void reg_overwrite(const Search *search, uint32_t hash, const int depth, int alpha, int beta, int value, int policy) {
            Hash_node *node = get_node(hash);
            
            uint32_t node_level;
#if TT_REGISTER_MIN_LEVEL
            Hash_node *min_level_node = nullptr;
            uint32_t min_level = 0x4fffffff;
            bool registered = false;
#endif
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                node->lock.lock();
                    if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                        node->data.reg_new_level(depth, search->mpc_level, alpha, beta, value, policy);
                        node->lock.unlock();
#if TT_REGISTER_MIN_LEVEL
                        registered = true;
#endif
                        break;
                    }
                node->lock.unlock();
                ++hash;
                node = get_node(hash);
            }
            if (n_registered >= n_registered_threshold && transposition_table_auto_reset_importance) {
                std::lock_guard lock(mtx);
                if (n_registered >= n_registered_threshold) {
                    
                    reset_importance_proc();
                }
            }
        }

        
        inline void get(const Search *search, const uint32_t hash, const int depth, int *lower, int *upper, uint_fast8_t moves[]) {
            Hash_node *node = get_node(hash);
            const uint32_t level = get_level_common(depth, search->mpc_level);
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                    node->lock.lock();
                        if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                            node->data.get_moves(moves);
                            if (node->data.get_level_no_importance() >= level) {
                                node->data.get_bounds(lower, upper);
                            }
                            node->lock.unlock();
                            return;
                        }
                    node->lock.unlock();
                }
                node = get_node(hash + i + 1);
            }
        }

        
        inline bool get_bounds(const Search *search, uint32_t hash, int depth, int *lower, int *upper) {
            Hash_node *node = get_node(hash);
            const uint32_t level = get_level_common(depth, search->mpc_level);
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                    node->lock.lock();
                        if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                            if (node->data.get_level_no_importance() >= level) {
                                node->data.get_bounds(lower, upper);
                                node->lock.unlock();
                                return true;
                            }
                        }
                    node->lock.unlock();
                }
                ++hash;
                node = get_node(hash);
            }
            return false;
        }

        
        inline bool get_bounds_any_level(const Search *search, uint32_t hash, int *lower, int *upper) {
            Hash_node *node = get_node(hash);
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                    node->lock.lock();
                        if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                            node->data.get_bounds(lower, upper);
                            node->lock.unlock();
                            return true;
                        }
                    node->lock.unlock();
                }
                ++hash;
                node = get_node(hash);
            }
            return false;
        }

        
        inline bool get_bounds_any_level(const Board *board, uint32_t hash, int *lower, int *upper) {
            Hash_node *node = get_node(hash);
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                if (node->board.player == board->player && node->board.opponent == board->opponent) {
                    node->lock.lock();
                        if (node->board.player == board->player && node->board.opponent == board->opponent) {
                            node->data.get_bounds(lower, upper);
                            node->lock.unlock();
                            return true;
                        }
                    node->lock.unlock();
                }
                ++hash;
                node = get_node(hash);
            }
            return false;
        }

        
        inline bool get_moves_any_level(const Board *board, uint32_t hash, uint_fast8_t moves[]) {
            Hash_node *node = get_node(hash);
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                if (node->board.player == board->player && node->board.opponent == board->opponent) {
                    node->lock.lock();
                        if (node->board.player == board->player && node->board.opponent == board->opponent) {
                            node->data.get_moves(moves);
                            node->lock.unlock();
                            return true;
                        }
                    node->lock.unlock();
                }
                ++hash;
                node = get_node(hash);
            }
            return false;
        }

        inline void get_info(Board board, int *lower, int *upper, uint_fast8_t moves[], int *depth, uint_fast8_t *mpc_level) {
            uint32_t hash = board.hash();
            Hash_node *node = get_node(hash);
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                if (node->board.player == board.player && node->board.opponent == board.opponent) {
                    node->lock.lock();
                        if (node->board.player == board.player && node->board.opponent == board.opponent) {
                            node->data.get_bounds(lower, upper);
                            node->data.get_moves(moves);
                            *depth = node->data.get_depth();
                            *mpc_level = node->data.get_mpc_level();
                            node->lock.unlock();
                            return;
                        }
                    node->lock.unlock();
                }
                node = get_node(hash + i + 1);
            }
        }

        inline void del(const Board *board, uint32_t hash) {
            Hash_node *node = get_node(hash);
            uint32_t node_level;
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                node->lock.lock();
                    if (node->board.player == board->player && node->board.opponent == board->opponent) {
                        node->init();
                    }
                node->lock.unlock();
                ++hash;
                node = get_node(hash);
            }
        }

        inline bool has_node(const Search *search, uint32_t hash, int depth) {
            Hash_node *node = get_node(hash);
            const uint32_t level = get_level_common(depth, search->mpc_level);
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                    node->lock.lock();
                        if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                            if (node->data.get_level_no_importance() >= level) {
                                node->lock.unlock();
                                return true;
                            }
                        }
                    node->lock.unlock();
                }
                ++hash;
                node = get_node(hash);
            }
            return false;
        }

        inline bool has_node_any_level(const Search *search, uint32_t hash) {
            Hash_node *node = get_node(hash);
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                    return true;
                }
                ++hash;
                node = get_node(hash);
            }
            return false;
        }

        inline int has_node_any_level_cutoff(const Search *search, uint32_t hash, int depth, int alpha, int beta) {
            Hash_node *node = get_node(hash);
            const uint32_t level = get_level_common(depth, search->mpc_level);
            int res = TRANSPOSITION_TABLE_NOT_HAS_NODE;
            int l, u;
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                    node->lock.lock();
                        if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                            res = TRANSPOSITION_TABLE_HAS_NODE;
                            if (node->data.get_level_no_importance() >= level) {
                                node->data.get_bounds(&l, &u);
                                if (u <= alpha) {
                                    res = u;
                                } else if (beta <= l) {
                                    res = l;
                                }
                            }
                        }
                    node->lock.unlock();
                    break;
                }
                ++hash;
                node = get_node(hash);
            }
            return res;

        }

        inline bool has_node_any_level_get_bounds(const Search *search, uint32_t hash, int depth, int* l, int* u) {
            Hash_node *node = get_node(hash);
            const uint32_t level = get_level_common(depth, search->mpc_level);
            for (uint_fast8_t i = 0; i < TRANSPOSITION_TABLE_N_LOOP; ++i) {
                if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                    node->lock.lock();
                        if (node->board.player == search->board.player && node->board.opponent == search->board.opponent) {
                            if (node->data.get_level_no_importance() >= level) {
                                node->data.get_bounds(l, u);
                            }
                            node->lock.unlock();
                            return true;
                        }
                    node->lock.unlock();
                }
                ++hash;
                node = get_node(hash);
            }
            return false;

        }

        inline void prefetch(uint32_t hash) {
            
#if USE_SIMD 
            Hash_node *node = get_node(hash);
            _mm_prefetch((char const *)node, _MM_HINT_T0);
            
#endif
        }

    private:
        inline Hash_node* get_node(const uint32_t hash) {
#if TT_USE_STACK
#if USE_CHANGEABLE_HASH_LEVEL
            if (hash < TRANSPOSITION_TABLE_STACK_SIZE) {
                return &table_stack[hash];
            }
            return &table_heap[hash - TRANSPOSITION_TABLE_STACK_SIZE];
#else 
            return &table_stack[hash];
#endif 
#else 
            return &table_heap[hash];
#endif 
        }

        inline void reset_importance_proc() {
            
            
#if TT_USE_STACK
            for (size_t i = 0; i < std::min(table_size, (size_t)TRANSPOSITION_TABLE_STACK_SIZE); ++i) {
                table_stack[i].data.set_importance_zero();
            }
#if USE_CHANGEABLE_HASH_LEVEL
            if (table_size > TRANSPOSITION_TABLE_STACK_SIZE) {
                for (size_t i = 0; i < table_size - (size_t)TRANSPOSITION_TABLE_STACK_SIZE; ++i)
                    table_heap[i].data.set_importance_zero();
            }
#endif 
#else 
            for (size_t i = 0; i < table_size; ++i) {
                table_heap[i].data.set_importance_zero();
            }
#endif 
            n_registered.store(0);
        }
};


Transposition_table transposition_table;

void transposition_table_init() {
    transposition_table.init();
}

#if USE_CHANGEABLE_HASH_LEVEL

bool hash_resize(int hash_level_failed, int hash_level, bool show_log) {
    if (!transposition_table.resize(hash_level)) {
        std::cerr << "[ERROR] hash table resize failed. resize to level " << hash_level_failed << std::endl;
        transposition_table.resize(hash_level_failed);
        if (!hash_init(hash_level_failed)) {
            std::cerr << "[ERROR] can't get hash. you can ignore this error" << std::endl;
            hash_init_rand(hash_level_failed);
        }
        global_hash_level = hash_level_failed;
#if USE_CRC32C_HASH
        global_hash_bit_mask = (1U << global_hash_level) - 1;
#endif
        return false;
    }
    if (!hash_init(hash_level)) {
        std::cerr << "[ERROR] can't get hash. you can ignore this error" << std::endl;
        hash_init_rand(hash_level);
    }
    global_hash_level = hash_level;
#if USE_CRC32C_HASH
    global_hash_bit_mask = (1U << global_hash_level) - 1;
#endif
    if (show_log) {
        double size_mb = (double)sizeof(Hash_node) / 1024 / 1024 * hash_sizes[hash_level];
        std::cerr << "hash resized to level " << hash_level << " elements " << hash_sizes[hash_level] << " size " << size_mb << " MB" << std::endl;
    }
    return true;
}


bool hash_resize(int hash_level_failed, int hash_level, std::string binary_path, bool show_log) {
    if (!transposition_table.resize(hash_level)) {
        std::cerr << "[ERROR] hash table resize failed. resize to level " << hash_level_failed << std::endl;
        transposition_table.resize(hash_level_failed);
        if (!hash_init(hash_level_failed, binary_path)) {
            std::cerr << "[ERROR] can't get hash. you can ignore this error" << std::endl;
            hash_init_rand(hash_level_failed);
        }
        global_hash_level = hash_level_failed;
#if USE_CRC32C_HASH
        global_hash_bit_mask = (1U << global_hash_level) - 1;
#endif
        return false;
    }
    if (!hash_init(hash_level, binary_path)) {
        std::cerr << "[ERROR] can't get hash. you can ignore this error" << std::endl;
        hash_init_rand(hash_level);
    }
    global_hash_level = hash_level;
#if USE_CRC32C_HASH
    global_hash_bit_mask = (1U << global_hash_level) - 1;
#endif
    if (show_log) {
        double size_mb = (double)sizeof(Hash_node) / 1024 / 1024 * hash_sizes[hash_level];
        std::cerr << "hash resized to level " << hash_level << " elements " << hash_sizes[hash_level] << " size " << size_mb << " MB" << std::endl;
    }
    return true;
}
#else
bool hash_tt_init(std::string binary_path, bool show_log) {
    transposition_table.set_size();
    if (!hash_init(DEFAULT_HASH_LEVEL, binary_path)) {
        std::cerr << "[ERROR] can't get hash. you can ignore this error" << std::endl;
        hash_init_rand(DEFAULT_HASH_LEVEL);
    }
    global_hash_level = DEFAULT_HASH_LEVEL;
#if USE_CRC32C_HASH
    global_hash_bit_mask = (1U << DEFAULT_HASH_LEVEL) - 1;
#endif
    return true;
}

bool hash_tt_init(bool show_log) {
    transposition_table.set_size();
    if (!hash_init(DEFAULT_HASH_LEVEL)) {
        std::cerr << "[ERROR] can't get hash. you can ignore this error" << std::endl;
        hash_init_rand(DEFAULT_HASH_LEVEL);
    }
    global_hash_level = DEFAULT_HASH_LEVEL;
#if USE_CRC32C_HASH
    global_hash_bit_mask = (1U << DEFAULT_HASH_LEVEL) - 1;
#endif
    return true;
}
#endif

void delete_tt(Board *board, int depth) {
    transposition_table.del(board, board->hash());
    if (depth == 0) {
        return;
    }
    uint64_t legal = board->get_legal();
    if (legal == 0) {
        board->pass();
            if (board->get_legal()) {
                delete_tt(board, depth);
            }
        board->pass();
        return;
    }
    Flip flip;
    for (uint_fast8_t cell = first_bit(&legal); legal; cell = next_bit(&legal)) {
        calc_flip(&flip, board, cell);
        board->move_board(&flip);
            delete_tt(board, depth - 1);
        board->undo_board(&flip);
    }
}


// ===== FILE: Egaroucid/src/engine/umigame.hpp =====

ï»¿

#pragma once
#include <iostream>
#include <unordered_map>
#include "common_select.hpp"
#include "board.hpp"
#include "book.hpp"
#include "util.hpp"


constexpr int UMIGAME_UNDEFINED = -1;



struct Umigame_result {
    int b;
    int w;

    Umigame_result()
        : b(UMIGAME_UNDEFINED), w(UMIGAME_UNDEFINED) {}

    Umigame_result operator+(const Umigame_result& other) {
        Umigame_result res;
        res.b = b + other.b;
        res.w = w + other.w;
        return res;
    }
};

class Umigame {
    private:
        std::mutex mtx;
        std::unordered_map<Board, Umigame_result, Book_hash> umigame;

    public:
        void calculate(Board *board, int player, int depth) {
            umigame_search(board, player, depth);
        }

        void delete_all() {
            std::lock_guard<std::mutex> lock(mtx);
            umigame.clear();
        }

        
        Umigame_result get_umigame(Board *b) {
            std::lock_guard<std::mutex> lock(mtx);
            Board unique_board = representative_board(b->copy());
            return get_oneumigame(unique_board);
        }

    private:
        
        Umigame_result umigame_search(Board *b, int player, int depth) {
            Umigame_result umigame_res;
			if (!global_searching)
                return umigame_res;
			if (!book.contain(b) || b->n_discs() >= depth + 4) {
				umigame_res.b = 1;
                umigame_res.w = 1;
                return umigame_res;
            }
            umigame_res = get_umigame(b);
            if (umigame_res.b != UMIGAME_UNDEFINED)
                return umigame_res;
            int max_val = -INF;
            if (b->get_legal() == 0ULL) {
                player ^= 1;
                b->pass();
            }
            Flip flip;
            Book_elem book_elem = book.get(b);
            std::vector<int> best_moves = book.get_all_best_moves(b);
            
            if (best_moves.size() == 0) {
                umigame_res.b = 1;
                umigame_res.w = 1;
				reg(b, umigame_res);
                return umigame_res;
            }
            std::vector<Board> boards;
            for (uint_fast8_t cell: best_moves) {
                calc_flip(&flip, b, cell);
                boards.emplace_back(b->move_copy(&flip));
            }
            if (player == BLACK) {
                umigame_res.b = INF;
                umigame_res.w = 0;
                for (Board &nnb : boards) {
                    Umigame_result nres = umigame_search(&nnb, player ^ 1, depth);
                    umigame_res.b = std::min(umigame_res.b, nres.b);
                    umigame_res.w += nres.w;
                }
            } else {
                umigame_res.b = 0;
                umigame_res.w = INF;
                for (Board &nnb : boards) {
                    Umigame_result nres = umigame_search(&nnb, player ^ 1, depth);
                    umigame_res.w = std::min(umigame_res.w, nres.w);
                    umigame_res.b += nres.b;
                }
            }
            if (global_searching) {
                reg(b, umigame_res);
            }
            return umigame_res;
        }

        inline void reg(Board *b, Umigame_result val) {
            Board unique_board = representative_board(b->copy());
            std::lock_guard<std::mutex> lock(mtx);
            umigame[unique_board] = val;
        }

        
        inline Umigame_result get_oneumigame(Board b) {
            Umigame_result res;
            res.b = UMIGAME_UNDEFINED;
            res.w = UMIGAME_UNDEFINED;
            if (umigame.find(b) != umigame.end()) {
                res = umigame[b];
            }
            return res;
        }

        inline bool contain(Board b) {
            Board unique_board = representative_board(b);
            return umigame.find(unique_board) != umigame.end();
        }
};

Umigame umigame;


Umigame_result calculate_umigame(Board *b, int player, int depth) {
    Umigame_result res = umigame.get_umigame(b);
    if (res.b == UMIGAME_UNDEFINED) {
        umigame.calculate(b, player, depth);
        res = umigame.get_umigame(b);
    }
    return res;
}

// ===== FILE: Egaroucid/src/engine/util.hpp =====



#pragma once
#include <iostream>
#include <sstream>
#include <iomanip>
#include <string>
#include "board.hpp"
#include "search.hpp"

std::pair<Board, int> convert_board_from_str(std::string board_str) {
    Board board;
    board_str.erase(std::remove_if(board_str.begin(), board_str.end(), ::isspace), board_str.end());
    if (board_str.length() != HW2 + 1) {
        std::cerr << "[ERROR] invalid argument got length " << board_str.length() << " expected " << HW2 + 1 << std::endl;
        return std::make_pair(board, -1); 
    }
    if (!board.from_str(board_str)) {
        return std::make_pair(board, -1); 
    }
    int player = -1;
    if (is_black_like_char(board_str[HW2])) {
        player = BLACK;
    } else if (is_white_like_char(board_str[HW2])) {
        player = WHITE;
    }
    return std::make_pair(board, player);
}


Board input_board() {
    Board res;
    char elem;
    int player;
    std::cin >> player;
    res.player = 0;
    res.opponent = 0;
    for (int i = 0; i < HW2; ++i) {
        std::cin >> elem;
        if (elem == '0') {
            if (player == BLACK)
                res.player |= 1ULL << (HW2_M1 - i);
            else
                res.opponent |= 1ULL << (HW2_M1 - i);
        } else if (elem == '1') {
            if (player == WHITE)
                res.player |= 1ULL << (HW2_M1 - i);
            else
                res.opponent |= 1ULL << (HW2_M1 - i);
        }
    }
    return res;
}



bool input_board_base81(std::string board_str, Board *board) {
    if (board_str.length() != 16) {
        std::cerr << "[ERROR] invalid argument" << std::endl;
        return true;
    }
    board->player = 0;
    board->opponent = 0;
    int idx, d;
    char c;
    for (int i = 0; i < 16; ++i) {
        idx = i * 4 + 3;
        c = board_str[i] - '!';
        d = c / 32;
        if (d == 1) {
            board->player |= 1ULL << idx;
        } else if (d == 2) {
            board->opponent |= 1ULL << idx;
        }
        --idx;
        c %= 32;
        d = c / 9;
        if (d == 1) {
            board->player |= 1ULL << idx;
        } else if (d == 2) {
            board->opponent |= 1ULL << idx;
        }
        --idx;
        c %= 9;
        d = c / 3;
        if (d == 1) {
            board->player |= 1ULL << idx;
        } else if (d == 2) {
            board->opponent |= 1ULL << idx;
        }
        --idx;
        c %= 3;
        d = c;
        if (d == 1) {
            board->player |= 1ULL << idx;
        } else if (d == 2) {
            board->opponent |= 1ULL << idx;
        }
    }
    return false;
}


inline bool compare_representative_board(Board *res, Board *cmp) {
    if (res->player > cmp->player || (res->player == cmp->player && res->opponent > cmp->opponent)) {
        res->player = cmp->player;
        res->opponent = cmp->opponent;
        return true;
    }
    return false;
}

inline Board representative_board(Board b) {
    Board res = b;
    Board bt = b;   bt.board_black_line_mirror();       compare_representative_board(&res, &bt);
    Board bv =      b.get_vertical_mirror();            compare_representative_board(&res, &bv);
    Board btv =     bt.get_vertical_mirror();           compare_representative_board(&res, &btv);
                    b.board_horizontal_mirror();        compare_representative_board(&res, &b);
                    bt.board_horizontal_mirror();       compare_representative_board(&res, &bt);
                    b.board_vertical_mirror();          compare_representative_board(&res, &b);
                    bt.board_vertical_mirror();         compare_representative_board(&res, &bt);
    return res;
}

inline Board representative_board(Board b, int *idx) {
    Board res = b;                                                                                      *idx = 0; 
    Board bt = b;   bt.board_black_line_mirror();       if (compare_representative_board(&res, &bt))    *idx = 2; 
    Board bv =      b.get_vertical_mirror();            if (compare_representative_board(&res, &bv))    *idx = 1; 
    Board btv =     bt.get_vertical_mirror();           if (compare_representative_board(&res, &btv))   *idx = 3; 
                    b.board_horizontal_mirror();        if (compare_representative_board(&res, &b))     *idx = 6; 
                    bt.board_horizontal_mirror();       if (compare_representative_board(&res, &bt))    *idx = 4; 
                    b.board_vertical_mirror();          if (compare_representative_board(&res, &b))     *idx = 7; 
                    bt.board_vertical_mirror();         if (compare_representative_board(&res, &bt))    *idx = 5; 
    return res;
}

inline Board representative_board(Board *b, int *idx) {
    return representative_board(b->copy(), idx);
}

inline Board representative_board(Board *b) {
    return representative_board(b->copy());
}

inline int convert_coord_from_representative_board(int cell, int idx) {
    int res;
    int y = cell / HW;
    int x = cell % HW;
    switch (idx) {
        case 0:
            res = cell;
            break;
        case 1:
            res = (HW_M1 - y) * HW + x; 
            break;
        case 2:
            res = (HW_M1 - x) * HW + (HW_M1 - y); 
            break;
        case 3:
            res = (HW_M1 - x) * HW + y; 
            break;
        case 4:
            res = x * HW + (HW_M1 - y); 
            break;
        case 5:
            res = x * HW + y; 
            break;
        case 6:
            res = y * HW + (HW_M1 - x); 
            break;
        case 7:
            res = (HW_M1 - y) * HW + (HW_M1 - x); 
            break;
        default:
            res = MOVE_UNDEFINED;
            std::cerr << "converting coord error" << std::endl;
            break;
    }
    return res;
}

inline int convert_coord_to_representative_board(int cell, int idx) {
    int res;
    int y = cell / HW;
    int x = cell % HW;
    switch (idx) {
        case 0:
            res = cell;
            break;
        case 1:
            res = (HW_M1 - y) * HW + x; 
            break;
        case 2:
            res = (HW_M1 - x) * HW + (HW_M1 - y); 
            break;
        case 3:
            res = x * HW + (HW_M1 - y); 
            break;
        case 4:
            res = (HW_M1 - x) * HW + y; 
            break;
        case 5:
            res = x * HW + y; 
            break;
        case 6:
            res = y * HW + (HW_M1 - x); 
            break;
        case 7:
            res = (HW_M1 - y) * HW + (HW_M1 - x); 
            break;
        default:
            res = MOVE_UNDEFINED;
            std::cerr << "converting coord error" << std::endl;
            break;
    }
    return res;
}

bool is_valid_transcript(std::string transcript) {
    if (transcript.size() % 2) {
        return false;
    }
    Board board;
    Flip flip;
    board.reset();
    for (int i = 0; i < transcript.size() - 1 && board.check_pass(); i += 2) {
        if (!is_coord_like_chars(transcript[i], transcript[i + 1])) {
            return false;
        }
        int coord = get_coord_from_chars(transcript[i], transcript[i + 1]);
        if ((board.get_legal() & (1ULL << coord)) == 0) {
            return false;
        }
        calc_flip(&flip, &board, coord);
        board.move_board(&flip);
    }
    return true;
}

std::vector<uint_fast8_t> transcript_to_arr(std::string transcript) {
    std::vector<uint_fast8_t> res;
    for (int i = 0; i < transcript.size() - 1; i += 2) {
        uint_fast8_t x = transcript[i] - 'a';
        res.emplace_back(get_coord_from_chars(transcript[i], transcript[i + 1]));
    }
    return res;
}

// ===== FILE: Egaroucid/src/engine/version.hpp =====



#pragma once
#include <string>


#define EGAROUCID_ENGINE_VERSION "7.7"
#define USE_BETA_VERSION false



#ifdef _WIN64 
    #define EGAROUCID_OS (std::string)"Windows"
#elif defined _WIN32
    #define EGAROUCID_OS (std::string)"Windows"
#elif defined __APPLE__
    #define EGAROUCID_OS (std::string)"macOS"
#else
    #define EGAROUCID_OS (std::string)"Linux"
#endif


#if USE_ARM
    #if USE_64_BIT
        #define EGAROUCID_CPU (std::string)"ARM64"
    #else
        #define EGAROUCID_CPU (std::string)"ARM"
    #endif
#else
    #if USE_64_BIT
        #if USE_AMD
            #define EGAROUCID_CPU (std::string)"x64 (AMD)"
        #else
            #define EGAROUCID_CPU (std::string)"x64"
        #endif
    #else
        #if USE_AMD
            #define EGAROUCID_CPU (std::string)"x86 (AMD)"
        #else
            #define EGAROUCID_CPU (std::string)"x86"
        #endif
    #endif
#endif


#if USE_SIMD
    #if USE_AVX512
        #define EGAROUCID_REVISION (std::string)"AVX512"
    #else
        #define EGAROUCID_REVISION (std::string)"SIMD"
    #endif
#else
    #define EGAROUCID_REVISION (std::string)"Generic"
#endif


#ifdef __clang_version__
    #define EGAROUCID_COMPILER (std::string)"Clang"
#elif defined __GNUC__
    #define EGAROUCID_COMPILER (std::string)"GCC"
#elif defined _MSC_VER
    #define EGAROUCID_COMPILER (std::string)"MSVC"
#else
    #define EGAROUCID_COMPILER (std::string)"Unknown Compiler"
#endif

#define EGAROUCID_ENGINE_ENV_VERSION (EGAROUCID_OS + " " + EGAROUCID_CPU + " " + EGAROUCID_REVISION + " (" + EGAROUCID_COMPILER + ")")

// ===== FILE: Egaroucid/src/engine/ybwc.hpp =====



#pragma once
#include <iostream>
#include "setting.hpp"
#include "common_select.hpp"
#include "search.hpp"
#include "midsearch.hpp"
#include "endsearch.hpp"
#include "parallel.hpp"
#include "thread_pool.hpp"
#include "transposition_cutoff.hpp"


constexpr int YBWC_MID_SPLIT_MIN_DEPTH = 6;

constexpr int YBWC_END_SPLIT_MIN_DEPTH = 16;


constexpr int YBWC_N_YOUNGER_CHILD = 1;

constexpr int YBWC_NOT_PUSHED = -124;
constexpr int YBWC_PUSHED = 124;

int nega_alpha_ordering_nws(Search *search, int alpha, const int depth, const bool skipped, uint64_t legal, const bool is_end_search, std::vector<bool*> &searchings);
inline bool is_searching(std::vector<bool*> &searchings);


Parallel_task ybwc_do_task_nws(uint64_t player, uint64_t opponent, int_fast8_t n_discs, uint_fast8_t parity, uint_fast8_t mpc_level, bool is_presearch, thread_id_t thread_id, int parent_alpha, const int depth, uint64_t legal, const bool is_end_search, uint_fast8_t policy, int move_idx, std::vector<bool*> searchings, bool *n_searching) {
    Search search(player, opponent, n_discs, parity, mpc_level, (!is_end_search && depth > YBWC_MID_SPLIT_MIN_DEPTH) || (is_end_search && depth > YBWC_END_SPLIT_MIN_DEPTH), is_presearch, thread_id);
    Parallel_task task;
    task.value = -nega_alpha_ordering_nws(&search, -parent_alpha - 1, depth, false, legal, is_end_search, searchings);
    if (!is_searching(searchings)) {
        task.value = SCORE_UNDEFINED;
    } else if (parent_alpha < task.value) {
        *n_searching = false; 
    }
    task.n_nodes = search.n_nodes;
    task.cell = policy;
    task.move_idx = move_idx;
    return task;
}




inline int ybwc_split_nws(Search *search, int parent_alpha, const int depth, uint64_t legal, const bool is_end_search, std::vector<bool*> &searchings, bool *n_searching, uint_fast8_t policy, const int n_remaining_moves, const int move_idx, const int running_count, std::vector<std::future<Parallel_task>> &parallel_tasks) {
    if (
            
            n_remaining_moves >= YBWC_N_YOUNGER_CHILD    
            
    ) {
        
        
        
        
        
        
        
        
        
        if (is_searching(searchings)) {
            bool pushed;
            parallel_tasks.emplace_back(thread_pool.push(search->thread_id, &pushed, std::bind(&ybwc_do_task_nws, search->board.player, search->board.opponent, search->n_discs, search->parity, search->mpc_level, search->is_presearch, search->thread_id, parent_alpha, depth, legal, is_end_search, policy, move_idx, searchings, n_searching)));
            if (pushed) {
                return YBWC_PUSHED;
            } else {
                parallel_tasks.pop_back();
            }
        }
    }
    return YBWC_NOT_PUSHED;
}


#if USE_YBWC_NWS
inline void ybwc_search_young_brothers_nws(Search *search, int alpha, int *v, int *best_move, int n_available_moves, uint32_t hash_code, int depth, bool is_end_search, std::vector<Flip_value> &move_list, std::vector<bool*> &searchings) {
    std::vector<std::future<Parallel_task>> parallel_tasks;
    bool n_searching = true;
    searchings.emplace_back(&n_searching);
    int canput = (int)move_list.size();
    int running_count = 0;
    int g;
    bool searched;
    int n_searched = 0;
    int n_moves_seen = 0;
    for (int move_idx = 0; move_idx < canput && is_searching(searchings); ++move_idx) {
        
        if (move_list[move_idx].flip.flip) {
            ++n_moves_seen;
            searched = false;
            search->move(&move_list[move_idx].flip);
                int ybwc_split_state = ybwc_split_nws(search, alpha, depth - 1, move_list[move_idx].n_legal, is_end_search, searchings, &n_searching, move_list[move_idx].flip.pos, n_available_moves - n_moves_seen, move_idx, running_count, parallel_tasks);
                if (ybwc_split_state == YBWC_PUSHED) {
                    ++running_count;
                } else {
                    if (ybwc_split_state == YBWC_NOT_PUSHED) {
                        g = -nega_alpha_ordering_nws(search, -alpha - 1, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searchings);
                    } else{
                        g = ybwc_split_state;
                        ++search->n_nodes;
                    }
                    if (is_searching(searchings)) {
                        searched = true;
                        if (*v < g) {
                            *v = g;
                            *best_move = move_list[move_idx].flip.pos;
                            if (alpha < g) {
                                n_searching = false;
                            }
                        }
                    }
                }
            search->undo(&move_list[move_idx].flip);
            if (searched) {
                move_list[move_idx].flip.flip = 0;
                ++n_searched;
            }
        }
    }
    Parallel_task task_result;
#if USE_YBWC_SPLITTED_TASK_TERMINATION
    if (is_searching(searchings) && *v <= alpha && running_count >= 2 && ((is_end_search && depth >= 28) || (!is_end_search && depth >= 24))) {
        for (std::future<Parallel_task> &task: parallel_tasks) {
            if (task.valid()) {
                if (task.wait_for(std::chrono::seconds(0)) == std::future_status::ready) {
                    task_result = task.get();
                    --running_count;
                    search->n_nodes += task_result.n_nodes;
                    if (task_result.value != SCORE_UNDEFINED) {
                        if (*v < task_result.value) {
                            *v = task_result.value;
                            *best_move = move_list[task_result.move_idx].flip.pos;
                        }
                        move_list[task_result.move_idx].flip.flip = 0;
                        ++n_searched;
                    }
                }
            }
        }
        if (is_searching(searchings) && *v <= alpha && running_count >= 2) {
            n_searching = false; 
            for (std::future<Parallel_task> &task: parallel_tasks) {
                if (task.valid()) {
                    task_result = task.get();
                    search->n_nodes += task_result.n_nodes;
                }
            }
            searchings.pop_back(); 
            if (is_searching(searchings)) {
                ybwc_search_young_brothers_nws(search, alpha, v, best_move, n_moves_seen - n_searched, hash_code, depth, is_end_search, move_list, searchings);
            }
            return;
        }
    }
#endif
    for (std::future<Parallel_task> &task: parallel_tasks) {
        if (task.valid()) {
            task_result = task.get();
            search->n_nodes += task_result.n_nodes;
            if (task_result.value != SCORE_UNDEFINED) {
                if (*v < task_result.value) {
                    *v = task_result.value;
                    *best_move = move_list[task_result.move_idx].flip.pos;
                    
                    
                    
                }
            }
        }
    }
    searchings.pop_back();
}




inline void ybwc_search_young_brothers_nws(Search *search, int alpha, int *v, int *best_move, int n_available_moves, uint32_t hash_code, int depth, bool is_end_search, Flip_value move_list[], int canput, std::vector<bool*> &searchings) {
    std::vector<std::future<Parallel_task>> parallel_tasks;
    bool n_searching = true;
    searchings.emplace_back(&n_searching);
    int running_count = 0;
    int g;
    bool searched;
    int n_searched = 0;
    int n_moves_seen = 0;
    for (int move_idx = 0; move_idx < canput && is_searching(searchings); ++move_idx) {
        
        if (move_list[move_idx].flip.flip) {
            ++n_moves_seen;
            searched = false;
            search->move(&move_list[move_idx].flip);
                int ybwc_split_state = ybwc_split_nws(search, alpha, depth - 1, move_list[move_idx].n_legal, is_end_search, searchings, &n_searching, move_list[move_idx].flip.pos, n_available_moves - n_moves_seen, move_idx, running_count, parallel_tasks);
                if (ybwc_split_state == YBWC_PUSHED) {
                    ++running_count;
                } else {
                    if (ybwc_split_state == YBWC_NOT_PUSHED) {
                        g = -nega_alpha_ordering_nws(search, -alpha - 1, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searchings);
                    } else{
                        g = ybwc_split_state;
                        ++search->n_nodes;
                    }
                    if (is_searching(searchings)) {
                        searched = true;
                        if (*v < g) {
                            *v = g;
                            *best_move = move_list[move_idx].flip.pos;
                            if (alpha < g) {
                                n_searching = false;
                            }
                        }
                    }
                }
            search->undo(&move_list[move_idx].flip);
            if (searched) {
                move_list[move_idx].flip.flip = 0;
                ++n_searched;
            }
        }
    }
    Parallel_task task_result;
#if USE_YBWC_SPLITTED_TASK_TERMINATION
    if (is_searching(searchings) && *v <= alpha && running_count >= 2 && ((is_end_search && depth >= 28) || (!is_end_search && depth >= 24))) {
        for (std::future<Parallel_task> &task: parallel_tasks) {
            if (task.valid()) {
                if (task.wait_for(std::chrono::seconds(0)) == std::future_status::ready) {
                    task_result = task.get();
                    --running_count;
                    search->n_nodes += task_result.n_nodes;
                    if (task_result.value != SCORE_UNDEFINED) {
                        if (*v < task_result.value) {
                            *v = task_result.value;
                            *best_move = move_list[task_result.move_idx].flip.pos;
                        }
                        move_list[task_result.move_idx].flip.flip = 0;
                        ++n_searched;
                    }
                }
            }
        }
        if (is_searching(searchings) && *v <= alpha && running_count >= 2) {
            n_searching = false; 
            for (std::future<Parallel_task> &task: parallel_tasks) {
                if (task.valid()) {
                    task_result = task.get();
                    search->n_nodes += task_result.n_nodes;
                }
            }
            searchings.pop_back(); 
            if (is_searching(searchings)) {
                ybwc_search_young_brothers_nws(search, alpha, v, best_move, n_moves_seen - n_searched, hash_code, depth, is_end_search, move_list, searchings);
            }
            return;
        }
    }
#endif
    for (std::future<Parallel_task> &task: parallel_tasks) {
        if (task.valid()) {
            task_result = task.get();
            search->n_nodes += task_result.n_nodes;
            if (task_result.value != SCORE_UNDEFINED) {
                if (*v < task_result.value) {
                    *v = task_result.value;
                    *best_move = move_list[task_result.move_idx].flip.pos;
                    
                    
                    
                }
            }
        }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    searchings.pop_back();
}
#endif

#if USE_YBWC_NEGASCOUT
void ybwc_search_young_brothers(Search *search, int *alpha, int *beta, int *v, int *best_move, int n_available_moves, uint32_t hash_code, int depth, bool is_end_search, std::vector<Flip_value> &move_list, bool need_best_move, bool *searching) {
    std::vector<std::future<Parallel_task>> parallel_tasks;
    bool n_searching = true;
    std::vector<bool*> searchings = {searching, &n_searching};
    int canput = (int)move_list.size();
    int running_count = 0;
    int g;
    std::vector<int> research_idxes;
    int next_alpha = *alpha;
    int n_searched = 0;
    int n_moves_seen = 0;
    for (int move_idx = 0; move_idx < canput && *searching && n_searching; ++move_idx) {
        if (move_list[move_idx].flip.flip) {
            ++n_moves_seen;
            bool move_done = false;
            search->move(&move_list[move_idx].flip);
                int ybwc_split_state = ybwc_split_nws(search, *alpha, depth - 1, move_list[move_idx].n_legal, is_end_search, searchings, &n_searching, move_list[move_idx].flip.pos, n_available_moves - n_moves_seen, move_idx, running_count, parallel_tasks);
                if (ybwc_split_state == YBWC_PUSHED) {
                    ++running_count;
                } else{
                    if (ybwc_split_state == YBWC_NOT_PUSHED) {
                        g = -nega_alpha_ordering_nws(search, -(*alpha) - 1, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searchings);
                    } else{
                        g = ybwc_split_state;
                        ++search->n_nodes;
                    }
                    if (*searching && n_searching) {
                        if (*v < g) {
                            *v = g;
                            *best_move = move_list[move_idx].flip.pos;
                        }
                        if (*alpha < g) {
                            next_alpha = std::max(next_alpha, g);
                            n_searching = false;
                            research_idxes.emplace_back(move_idx);
                        } else{
                            move_done = true;
                        }
                    }
                }
            search->undo(&move_list[move_idx].flip);
            if (move_done) {
                move_list[move_idx].flip.flip = 0;
                ++n_searched;
            }
        }
    }
    if (running_count) {
        Parallel_task task_result;
        for (std::future<Parallel_task> &task: parallel_tasks) {
            if (task.valid()) {
                task_result = task.get();
                --running_count;
                search->n_nodes += task_result.n_nodes;
                if (task_result.value != SCORE_UNDEFINED) {
                    if (*v < task_result.value) {
                        *v = task_result.value;
                        *best_move = move_list[task_result.move_idx].flip.pos;
                    }
                    if (*alpha < task_result.value) {
                        next_alpha = std::max(next_alpha, task_result.value);
                        research_idxes.emplace_back(task_result.move_idx);
                    } else {
                        move_list[task_result.move_idx].flip.flip = 0;
                        ++n_searched;
                    }
                }
            }
        }
    }
    if (research_idxes.size() && next_alpha < *beta && *searching) {
        int prev_alpha = *alpha;
        *alpha = next_alpha;
        for (const int &research_idx: research_idxes) {
            search->move(&move_list[research_idx].flip);
                g = -nega_scout(search, -(*beta), -(*alpha), depth - 1, false, move_list[research_idx].n_legal, is_end_search, searching);
            search->undo(&move_list[research_idx].flip);
            move_list[research_idx].flip.flip = 0;
            ++n_searched;
            if (*searching) {
                if (*v < g) {
                    *v = g;
                    *best_move = move_list[research_idx].flip.pos;
                }
                if (*alpha < g) {
                    *alpha = g;
                    if (*alpha >= *beta) {
                        break;
                    }
                }
            }
        }
        if (*alpha < *beta && *searching) {
            ybwc_search_young_brothers(search, alpha, beta, v, best_move, n_moves_seen - n_searched, hash_code, depth, is_end_search, move_list, need_best_move, searching);
        }
    }
}




void ybwc_search_young_brothers(Search *search, int *alpha, int *beta, int *v, int *best_move, int n_available_moves, uint32_t hash_code, int depth, bool is_end_search, Flip_value move_list[], int canput, bool need_best_move, bool *searching) {
    std::vector<std::future<Parallel_task>> parallel_tasks;
    bool n_searching = true;
    std::vector<bool*> searchings = {searching, &n_searching};
    int running_count = 0;
    int g;
    std::vector<int> research_idxes;
    int next_alpha = *alpha;
    int n_searched = 0;
    int n_moves_seen = 0;
    for (int move_idx = 0; move_idx < canput && *searching && n_searching; ++move_idx) {
        if (move_list[move_idx].flip.flip) {
            ++n_moves_seen;
            bool move_done = false;
            search->move(&move_list[move_idx].flip);
                int ybwc_split_state = ybwc_split_nws(search, *alpha, depth - 1, move_list[move_idx].n_legal, is_end_search, searchings, &n_searching, move_list[move_idx].flip.pos, n_available_moves - n_moves_seen, move_idx, running_count, parallel_tasks);
                if (ybwc_split_state == YBWC_PUSHED) {
                    ++running_count;
                } else{
                    if (ybwc_split_state == YBWC_NOT_PUSHED) {
                        g = -nega_alpha_ordering_nws(search, -(*alpha) - 1, depth - 1, false, move_list[move_idx].n_legal, is_end_search, searchings);
                    } else{
                        g = ybwc_split_state;
                        ++search->n_nodes;
                    }
                    if (*searching && n_searching) {
                        if (*v < g) {
                            *v = g;
                            *best_move = move_list[move_idx].flip.pos;
                        }
                        if (*alpha < g) {
                            next_alpha = std::max(next_alpha, g);
                            n_searching = false;
                            research_idxes.emplace_back(move_idx);
                        } else{
                            move_done = true;
                        }
                    }
                }
            search->undo(&move_list[move_idx].flip);
            if (move_done) {
                move_list[move_idx].flip.flip = 0;
                ++n_searched;
            }
        }
    }
    if (running_count) {
        Parallel_task task_result;
        for (std::future<Parallel_task> &task: parallel_tasks) {
            if (task.valid()) {
                task_result = task.get();
                --running_count;
                search->n_nodes += task_result.n_nodes;
                if (task_result.value != SCORE_UNDEFINED) {
                    if (*v < task_result.value) {
                        *v = task_result.value;
                        *best_move = move_list[task_result.move_idx].flip.pos;
                    }
                    if (*alpha < task_result.value) {
                        next_alpha = std::max(next_alpha, task_result.value);
                        research_idxes.emplace_back(task_result.move_idx);
                    } else {
                        move_list[task_result.move_idx].flip.flip = 0;
                        ++n_searched;
                    }
                }
            }
        }
    }
    if (research_idxes.size() && next_alpha < *beta && *searching) {
        int prev_alpha = *alpha;
        *alpha = next_alpha;
        for (const int &research_idx: research_idxes) {
            search->move(&move_list[research_idx].flip);
                g = -nega_scout(search, -(*beta), -(*alpha), depth - 1, false, move_list[research_idx].n_legal, is_end_search, searching);
            search->undo(&move_list[research_idx].flip);
            move_list[research_idx].flip.flip = 0;
            ++n_searched;
            if (*searching) {
                if (*v < g) {
                    *v = g;
                    *best_move = move_list[research_idx].flip.pos;
                }
                if (*alpha < g) {
                    *alpha = g;
                    if (*alpha >= *beta) {
                        break;
                    }
                }
            }
        }
        if (*alpha < *beta && *searching) {
            ybwc_search_young_brothers(search, alpha, beta, v, best_move, n_moves_seen - n_searched, hash_code, depth, is_end_search, move_list, canput, need_best_move, searching);
        }
    }
}
#endif